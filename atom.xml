<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pudding 日常</title>
  <icon>https://www.gravatar.com/avatar/00dc32454135c01a0b80be2cbf59b5ab</icon>
  <subtitle>a week is 2% of the year</subtitle>
  <link href="https://wu3227834.github.io/atom.xml" rel="self"/>
  
  <link href="https://wu3227834.github.io/"/>
  <updated>2025-08-05T12:14:15.016Z</updated>
  <id>https://wu3227834.github.io/</id>
  
  <author>
    <name>Pudding</name>
    <email>wu3227834@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能分析思路</title>
    <link href="https://wu3227834.github.io/2025/08/04/2025-08-04-xing-neng-fen-xi-si-lu/"/>
    <id>https://wu3227834.github.io/2025/08/04/2025-08-04-xing-neng-fen-xi-si-lu/</id>
    <published>2025-08-04T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.016Z</updated>
    
    <content type="html"><![CDATA[<p>我还年轻的时候，经常听一些大会或者演讲。有些人说，思路逻辑非常重要。我那时就想，你肯定是瞎忽悠的，因为我怎么就没听懂你说的思路呢？而现在轮到自己来写或者讲一些东西的时候，才发现他们说得对，而我之所以不理解，也是有原因的。性能分析思路和具体实现之间，有一道鸿沟，那就是操作的能力。之前我为什么听不懂那些人的思路，其实是因为我没有操作的功底。而有了操作的功底之后，还有一个大的鸿沟要越过去，那就是从操作到对监控计数器的理解。这一步可以说让很多性能测试人员都望而却步了。但是这还不算完，这一步迈过去之后，还有一个跳跃，就是相关性分析和证据链分析的过程。</p><p>如此一来，就会得到一张性能测试分析的能力阶梯视图，如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image.png" alt="性能分析能力阶梯视图"></p><ol><li>工具操作：包括压力工具、监控工具、剖析工具、调试工具</li><li>数值理解：包括上面工具中所有输出的数据</li><li><strong>趋势分析、相关性分析、证据链分析</strong>：就是了解了工具产生的数值之后，还要把它们的逻辑关系明白。这才是性能测试分析中最重要的一环</li><li>最后才是调优：有了第 3 步之后，调优的方案策略就有很多种了，具体选择取决于调优成本和产生的效果</li></ol><p>那么怎么把这些内容都融会贯通呢？下面我们就来说说性能测试分析的几个重要环节。</p><p>应该说，从我十几年的性能工作中，上面讲的这些内容是我觉得最有价值的内容了。在今天的文章中，我们将对它做一次系统的说明。我先把性能分析思路大纲列在这里：</p><ol><li>瓶颈的精确判断</li><li>线程递增的策略</li><li>性能衰退的过程</li><li>响应时间的拆分</li><li>构建分析决策树</li><li>场景的比对</li></ol><h2 id="瓶颈的精确判断"><a href="#瓶颈的精确判断" class="headerlink" title="瓶颈的精确判断"></a>瓶颈的精确判断</h2><h3 id="TPS-曲线"><a href="#TPS-曲线" class="headerlink" title="TPS 曲线"></a>TPS 曲线</h3><p>对性能瓶颈做出判断是性能分析的第一步，有了问题才能分析调优。之前有很多人在描述性能测试的过程中，说要找到性能测试中曲线上的“拐点”。我也明确说，大部分系统其实没有明确的拐点的。举例来说，TPS 的试图如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image2.png" alt="TPS图 1"></p><p>显然，这是一个阶梯式增加的场景，非常好。但是拐点在哪呢？有人说，显然在 1200TPS左右的时候。也有人说了，显然是到 1500TPS 才是拐点呀。但是也有人说，这都已经能到2000TPS 了，显然 2000TPS 是拐点。</p><p>我们再来看一下这张图对应的响应时间视图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image2.png" alt="响应时间图 1"></p><p>是不是有人要说响应时间为 4.5ms 时是拐点了？其实这些对拐点的判断，都是不合理的。如果我们对 TPS 的增加控制得更为精确的话，那么这个 TPS 的增加是是有一个有清晰的弧度，而不是有一个非常清晰的拐点。</p><p>但是至少我们可以有一个非常明确的判断，那就是瓶颈在第二个压力阶梯上已经出现了。因为响应时间增加了，TPS 增加得却没有那么多，到第三个阶梯时，显然增加的 TPS 更少了，响应时间也在不断地增加，所以，性能瓶颈在加剧，越往后就越明显。</p><p>那么我们的判断就是：</p><ol><li>有瓶颈！</li><li>瓶颈和压力有关</li><li>压力呈阶梯，并且增长幅度在衰减</li></ol><p>如果你觉得上面的瓶颈还算清晰的话，那么我们再来看一张图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image4.png" alt="TPS图 2"></p><p>在这个 TPS 的曲线中，你还能判断出拐点在哪吗？</p><p>显然是判断不出来拐点的，但是我们根据图得出以下几个结论：</p><ol><li>有瓶颈！</li><li>瓶颈和压力有关</li><li>压力也是阶梯的，但是并没有明确的拐点</li></ol><p>我们再来看一个 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image5.png" alt="TPS图 3"></p><p>看到这张图，是不是明显感觉系统有瓶颈呢？那么瓶颈是不是和压力大小有关呢？</p><p>这种比较有规律的问题，显然不是压力大小的原因。为什么呢？因为 TPS 周期性地出现降低，并且最大的 TPS 也都恢复到了差不多的水位上。所以，即使是压力降低，也最多降低最大的 TPS 水位，会让问题出现得更晚一点，但是不会不出现。</p><p>综合以上，如果画一个示意图的话，TPS 的衰减过程大概会如下所示：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image6.png" alt="示意图"></p><ol><li>随着用户数的增加，响应时间也在缓慢增加</li><li>TPS 前期一直都在增加，但是增加的幅度在变换，直至变平</li></ol><p>在这样的曲线图中，我们是看不到明确的观点的。但是我们能做的清晰的判断就是：有瓶颈！</p><p>所以对 TPS 曲线来说，它可以明确告诉我们的就是：</p><ol><li>有没有瓶颈：其实准确来说所有的系统都有性能瓶颈，只看我们在哪个量级上做性能测试了</li><li>瓶颈和压力有没有关系：TPS 随着压力的变化而变化，那就是有关系。不管压力增不增加，TPS 都会出现曲线趋势问题，那就是无关</li></ol><p>这时你可能会问，为什么不看响应时间就武断地下此结论呢？其实响应时间用来判断业务有多快的，而 TPS 才是用来判断容量有多大的。</p><h3 id="响应时间的曲线"><a href="#响应时间的曲线" class="headerlink" title="响应时间的曲线"></a>响应时间的曲线</h3><p>我们还是来看看响应时间，下面看一张响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image7.png" alt="响应时间图"></p><p>它对应的线程图是：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image8.png" alt="线程图"></p><p>多明显的问题，随着线程的增多，响应时间也在增加，是吧。再来看它们对应的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image9.png" alt="TPS图"></p><p>到第 40 个线程时，TPS 基本上达到上限，为 2500 左右。响应时间随着线程数的增加而增加了，系统的瓶颈显而易见地出现了。</p><p>但是，如果只让你看 TPS 曲线，你是不是也会有同样的判断？那就是：有瓶颈！并且和压力有关？所以说，其实 TPS 就可以告诉我们系统有没有瓶颈了，而响应时间是用来判断业务有多块的。</p><p>后面我们还会提到响应时间会是性能分析调优地重要分析对象。</p><h2 id="线程递增的策略"><a href="#线程递增的策略" class="headerlink" title="线程递增的策略"></a>线程递增的策略</h2><p>讲完响应时间之后，我们再来看下线程递增。在见识了很多性能测试人员做的场景之后，必须得承认，有些场景地问题太多了。</p><p>首先，我们来看两个场景地执行对比。</p><p>场景 1 的线程图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image10.png" alt="线程图 1"></p><p>场景 1 的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image11.png" alt="TPS图 1"></p><p>场景 1 的响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image12.png" alt="响应时间图 1"></p><p>场景 2 的线程图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image13.png" alt="线程图 2"></p><p>场景 2 的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image14.png" alt="TPS图 2"></p><p>场景 2 的响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image15.png" alt="响应时间图 2"></p><p>这两个场景的比对如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image16.png" alt="比对图"></p><table><thead><tr><th>对比项</th><th>场景 1</th><th>场景 2</th></tr></thead><tbody><tr><td>线程数</td><td>一次性加到500</td><td>10线程递增，并且递增中也是有梯度的</td></tr><tr><td>TPS</td><td>最大值达到400</td><td>最大值达到400，但递增过程中有抖动</td></tr><tr><td>响应时间</td><td>在600ms~660ms之间</td><td>在20ms~150ms之间</td></tr><tr><td>错误率</td><td>无</td><td>无</td></tr><tr><td>粒度</td><td>以分钟为粒度</td><td>以2秒为粒度</td></tr></tbody></table><p>有了这些对比数据之后，你是不是觉得哪里似乎是有问题的？</p><p>对的！</p><p>TPS 都是达到 400，但两个场景中线程递增的策略不同。产生的响应时间完全不同。虽然都没有报错，但是第一种场景是完全不符合真实的业务场景的。这是为什么呢？</p><p>在场景的执行过程中，首先，响应时间是从低到高的，而在场景 1 中不是这样。其次，线程应该是递增的，而场景 1 并没有这样做（这里或许有人会想到秒杀的场景，认为场景 1 符合秒杀的业务设定，这个问题我们稍后提及）。最后，在两个场景中，TPS 的上限都达到了 400 TPS。但是你可以看到，在场景 2 中，只要 40 线程即可达到，但场景 1 中居然用到了 500 线程，显然压力过大，所以响应时间才那么长。</p><p>其实在生产环境中，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我还年轻的时候，经常听一些大会或者演讲。有些人说，思路逻辑非常重要。我那时就想，你肯定是瞎忽悠的，因为我怎么就没听懂你说的思路呢？而现在轮到自己来写或者讲一些东西的时候，才发现他们说得对，而我之所以不理解，也是有原因的。性能分析思路和具体实现之间，有一道鸿沟，那就是操作的能</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="极客时间" scheme="https://wu3227834.github.io/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何用perf工具分析Java程序</title>
    <link href="https://wu3227834.github.io/2025/07/21/2025-07-21-ru-he-yong-perf-gong-ju-fen-xi-java-cheng-xu/"/>
    <id>https://wu3227834.github.io/2025/07/21/2025-07-21-ru-he-yong-perf-gong-ju-fen-xi-java-cheng-xu/</id>
    <published>2025-07-21T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何分析容器内的进程"><a href="#如何分析容器内的进程" class="headerlink" title="如何分析容器内的进程"></a>如何分析容器内的进程</h2><p><img src="/img/2025-07-21-%E5%A6%82%E4%BD%95%E7%94%A8perf%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90Java%E7%A8%8B%E5%BA%8F/image.png" alt="perf record"></p><p>当使用 perf 工具时，看到 16 进制地址而不是函数名，通常是因为缺少符号信息（symbol information）或调试信息，导致 perf 无法将地址解析为对应的函数名或源代码行。比较常见的场景是分析容器内的子进程，因为容器应用依赖的库都在镜像里面。</p><p>针对容器的情况，总结了一下四种解决方法。</p><p><strong>第一种方法，再容器外构建相同路径的依赖库。</strong>这种方法从原理上可行，但是并不推荐，一方面是因为找出这些依赖库比较麻烦，更重要的是，构建这些路径，会污染容器主机环境</p><p><strong>第二种方法，在容器内部运行 perf。</strong>不过，这需要容器运行在特权模式下，但实际的应用程序往往只以普通容器的方式运行。所以，容器内部一般没有权限执行 perf 分析。</p><p>比方说，如何你在普通容器内运行 perf record，你将会看到下面这个错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@efbd40d93ebf /]# perf record -g -p 1</span><br><span class="line"></span><br><span class="line">perf_event_open(…, PERF_FLAG_FD_CLOEXEC) failed with unexpected error 1 (Operation not permitted)</span><br><span class="line"></span><br><span class="line">perf_event_open(…, 0) failed unexpectedly with error 1 (Operation not permitted)</span><br><span class="line"></span><br><span class="line">Error:</span><br><span class="line"></span><br><span class="line">No permission to enable cycles event.</span><br><span class="line">You may not have permission to collect stats.</span><br><span class="line">Consider tweaking /proc/sys/kernel/perf_event_paranoid,</span><br><span class="line">which controls use of the performance events system by</span><br><span class="line">unprivileged users (without CAP_SYS_ADMIN).</span><br><span class="line">The current value is -1:</span><br><span class="line">-1: Allow use of (almost) all events by all users</span><br><span class="line"></span><br><span class="line"> Ignore mlock limit after perf_event_mlock_kb without CAP_IPC_LOCK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 0: Disallow ftrace <span class="keyword">function</span> tracepoint by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line"></span><br><span class="line"> Disallow raw tracepoint access by users without CAP_SYS_ADMIN</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 1: Disallow CPU event access by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 2: Disallow kernel profiling by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line">To make this setting permanent, edit /etc/sysctl.conf too, e.g.:</span><br><span class="line">kernel.perf_event_paranoid = -1</span><br></pre></td></tr></table></figure><p>从<a href="https://docs.docker.com/engine/security/seccomp/">docker seccomp</a>文档中可以看出，由于安全问题，系统调用 “perf*” 和 “ptrace” 默认被禁止。当然，其实你可以通过配置 /proc/sys/kernel/perf_event_paranoid（比如改成 -1），来允许非特权用户执行 perf 事件分析；不过还是那句话，为了安全起见，这种方式不太推荐。</p><p><strong>第三种方法，指定符号路径为容器文件系统的路径。</strong></p><p>举个例子：我们要分析一个在 Nginx 容器中运行的 worker 进程，可以执行一下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 worker 在宿主机上的进程号</span></span><br><span class="line">PID = $(docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; mynginx)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机上创建临时目录作为挂载点</span></span><br><span class="line">mkdir /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 bindfs 进行挂载 (需要 root 权限)</span></span><br><span class="line">bindfs /proc/$PID/root /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 perf record 记录性能数据</span></span><br><span class="line">perf record -p $PID -g -- sleep 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 perf report 分析数据并指定符号路径</span></span><br><span class="line">perf report --symfs /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载 bindfs 挂载</span></span><br><span class="line">umount /tmp/foo/</span><br></pre></td></tr></table></figure><p>不过要注意，bindfs 这个工具需要你额外安装。bindfs 的基本功能是实现目录绑定（类似于 mount –bind）。</p><p><strong>第四种方法，在容器外吧分析记录保存下来，再去容器里查看结果。</strong>这样，库和符号的路径也就都对了。比如，你可以这么做。先运行 <code>perf record -g -p &lt;pid&gt;</code>，执行一会儿（比如 15 秒）后，按 Ctrl+C 停止。</p><p>然后，把生成的 perf.data 文件，拷贝到容器里边来分析，不过，这里也需要注意 perf 工具的版本问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker cp perf.data mynginx:/tmp </span><br><span class="line">docker exec -i -t mynginx bash</span><br><span class="line"></span><br><span class="line">cd /tmp/ </span><br><span class="line">yum install perf</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><p>当你按照前面这几种方法操作后，你就可以在容器内部看到：</p><p><img src="/img/2025-07-21-%E5%A6%82%E4%BD%95%E7%94%A8perf%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90Java%E7%A8%8B%E5%BA%8F/image2.png" alt="perf report"></p><h2 id="为何看不到原生的Java的调用栈"><a href="#为何看不到原生的Java的调用栈" class="headerlink" title="为何看不到原生的Java的调用栈"></a>为何看不到原生的Java的调用栈</h2><p>分析 Java 应用时，perf 工具面临一个根本挑战：Java 代码并非直接在 CPU 上执行原生机器码，而是运行在一个名为 JVM（Java 虚拟机）的托管环境中：</p><ul><li>JIT 编译的抽象层：JVM 会在运行时通过即时编译（JIT）技术将热点的 Java 字节码动态编译成高效的机器码。这个过程意味着 perf 采样到的是这些动态生成的、无明确符号（函数名）的机器码地址</li><li>非标准调用栈：perf 默认只能识别操作系统层面的函数调用，因此它能看到 JVM 自身的函数（如 JavaMain），但是无法理解 JVM 内部的、属于 Java 应用程序的调用关系</li></ul><p>为了让 perf 发挥最用，必须建立一座桥梁，将 JVM 内的函数调用信息与 perf 的系统级采样数据关联起来。可以采用以下方案解决：</p><p>步骤一：保留帧指针（Preserve Frame Pointer），这是确保调用栈能被正常回溯的基础</p><ul><li>操作：在启动 Java 应用时，添加 JVM 参数 <code>-XX:-PreserveFramePointer</code></li><li>原理：处于性能优化，JIT 编译器默认会省略帧指针，这会释放一个寄存器提供其他用途。然后，perf 等多数性能分析工具依赖帧指针来遍历和回溯函数调用栈。启动此选项可以强制 JVM 保留该信息，从而生成完整、可追溯的调用栈。</li></ul><p>步骤二：生成 Java 符合映射表</p><p>此步骤的目的是将 perf 看到的内存地址翻译成可读的 Java 函数名</p><ul><li>工具：使用 <a href="https://github.com/jvm-profiling-tools/perf-map-agent">perf-map-agent</a>，这是一个专门为此设计的开源工具</li><li>原理：perf-map-agent 会作为一个 Java Agent 附加到目标 JVM 进程上，查询 JIT 编译后的机器码地址与原始 Java 方法名的对应关系，并将其写入一个 perf 能够识别的映射文件（通常是 /tmp/perf-<pid>.map）。perf 在生成报告时会自动检测并使用此文件。</li></ul><p>步骤三：使用 perf 采样与分析</p><p>完成上述准备后，就可以使用标准的 perf 命令进行性能分析。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -F 99 -p &lt;pid&gt; -g -- sleep 30 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-F 99：以 99Hz 的频率采样</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g：记录调用图（Call Graph）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分析采样数据</span></span><br><span class="line">sudo perf report</span><br></pre></td></tr></table></figure><p><strong>拓展</strong>：目前有现成的工具解决上述问题，<a href="https://github.com/async-profiler/async-profiler">async-profiler</a>，是一个专为 Java 设计的低开销、高精度的性能分析器，它集成了 perf 的功能并做了大量优化，是目前 Java 性能分析的优选工具。</p>]]></content>
    
    
    <summary type="html">使用 perf 分析 Java 程序需解决符号缺失和调用栈问题，可通过容器内外路径映射、保留 JVM 帧指针、使用 perf-map-agent 或 async-profiler 优化分析</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：网络</title>
    <link href="https://wu3227834.github.io/2025/06/17/2025-06-17-linux-tracing-network/"/>
    <id>https://wu3227834.github.io/2025/06/17/2025-06-17-linux-tracing-network/</id>
    <published>2025-06-17T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux网络性能指标"><a href="#Linux网络性能指标" class="headerlink" title="Linux网络性能指标"></a>Linux网络性能指标</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li>带宽，表示链路的<strong>最大传输速率</strong>，单位通常为 b/s（比特/秒）</li><li>吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特/秒）或者 B/s(字节/秒)。<strong>吞吐量受带宽限制</strong>，而吞吐量/带宽，也就是该网络的使用率</li><li>延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同的涵义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）</li><li>PSS，是 Packet Per Second（包/秒）的缩写，表示以<strong>网络包为单位的传输速率</strong>。PSS 通常用来评估<strong>网络的转发能力</strong>，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响</li></ul><p>另外，<strong>网络的可用性</strong>（网络能否正常通信）、<strong>并发连接数</strong>（TCP 连接数量）、<strong>丢包率</strong>（丢包百分比）、<strong>重传率</strong>（重新传输的网络包比例）等也是常用的性能指标。</p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>使用命令 ifconfig 或者 ip 查看</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth1</span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 9.134.194.74  netmask 255.255.248.0  broadcast 9.134.199.255</span><br><span class="line">        ether 52:54:00:82:12:e8  txqueuelen<span class="number"> 1000 </span> (Ethernet)</span><br><span class="line">        RX packets<span class="number"> 70297502 </span> bytes<span class="number"> 34143392231 </span>(31.7 GiB)</span><br><span class="line">        RX errors<span class="number"> 0 </span> dropped<span class="number"> 0 </span> overruns<span class="number"> 0 </span> frame 0</span><br><span class="line">        TX packets<span class="number"> 78816203 </span> bytes<span class="number"> 45528648722 </span>(42.4 GiB)</span><br><span class="line">        TX errors<span class="number"> 0 </span> dropped<span class="number"> 0 </span>overruns<span class="number"> 0 </span> carrier<span class="number"> 0 </span> collisions 0</span><br><span class="line"></span><br><span class="line">$ ip -s  addr show dev eth1</span><br><span class="line">2: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu<span class="number"> 1500 </span>qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 52:54:00:82:12:e8 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 9.134.194.74/21 brd 9.134.199.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">   <span class="number"> 34143407013 </span>70297654<span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>      </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns </span><br><span class="line">   <span class="number"> 45528723929 </span>78816328<span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span> </span><br></pre></td></tr></table></figure><p>第一，网络接口的状态标志。ifconfig 输出 RUNNING，或者 ip 输出中的 LOWER_UP，都表示物理网络是连通，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了。</p><p>第二，MTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。</p><p>第三，网络接口的 IP 地址、子网以及 MAC 地址。这些地址都是保障网络功能正常工作所必须的，你需要确保配置正确。</p><p>第四，网络收发的字节数、包数、错误数以及丢包情况，特别是 TX 和 RX 部分的 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，通常表示出现了网络 I/O 问题。其中：</p><ul><li>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等</li><li>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包</li><li>overruns 表示超限数据丢包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包</li><li>carrier 表示发生 carrirer 错误的数据报数，比如双工模式不匹配、物理电缆出现问题等</li><li>collisions 表示碰撞数据包数</li></ul><h3 id="嵌套字信息"><a href="#嵌套字信息" class="headerlink" title="嵌套字信息"></a>嵌套字信息</h3><p>使用 netstat 或 ss 来表示<strong>嵌套字、网络栈、网络接口以及路由表的信息</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nlp | head -n <span class="number">3</span></span><br><span class="line">Active Internet connections (<span class="keyword">only</span> servers)</span><br><span class="line">Proto Recv-Q Send-Q <span class="keyword">Local</span> Address           <span class="keyword">Foreign</span> Address         State       PID/Program <span class="type">name</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10248</span>         <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:*               <span class="keyword">LISTEN</span>      <span class="number">624565</span>/kubelet</span><br><span class="line"></span><br><span class="line">$ ss -ltnp | head -n <span class="number">3</span></span><br><span class="line">State      Recv-Q Send-Q <span class="keyword">Local</span> Address:Port               Peer Address:Port</span><br><span class="line"><span class="keyword">LISTEN</span>     <span class="number">0</span>      <span class="number">65535</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10248</span>                    *:*                   users:((&quot;kubelet&quot;,pid=<span class="number">624565</span>,fd=<span class="number">29</span>))</span><br><span class="line"><span class="keyword">LISTEN</span>     <span class="number">0</span>      <span class="number">65535</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10249</span>                    *:*                   users:((&quot;kube-proxy&quot;,pid=<span class="number">624952</span>,fd=<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>其中，<strong>接收队列（Recv-Q）和发送队列（Send-Q）</strong>需要关注，它们通常是 0。当你发现它们不是 0 时，说明有网络包的堆积发生</p><p>当嵌套字处于连接状态（Established）时，</p><ul><li>Recv-Q 表示嵌套字缓冲还没有被应用程序取走的字节数（即接收队列长度）</li><li>Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）</li></ul><p>当嵌套字处于监听状态（Listening）时，</p><ul><li>Recv-Q 表示当前全连接队列（accept 队列）长度</li><li>Send-Q 表示全连接队列的最大长度</li></ul><h3 id="协议栈统计信息"><a href="#协议栈统计信息" class="headerlink" title="协议栈统计信息"></a>协议栈统计信息</h3><p>使用 netstat 或 ss 命令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -s</span><br><span class="line">Ip:</span><br><span class="line">   <span class="number"> 11236847787 </span>total packets received</span><br><span class="line">   <span class="number"> 76906 </span>forwarded</span><br><span class="line">   <span class="number"> 0 </span>incoming packets discarded</span><br><span class="line">   <span class="number"> 10964584370 </span>incoming packets delivered</span><br><span class="line">   <span class="number"> 10948611259 </span>requests sent out</span><br><span class="line">   <span class="number"> 448 </span>outgoing packets dropped</span><br><span class="line">   <span class="number"> 4 </span>dropped because of missing route</span><br><span class="line">Icmp:</span><br><span class="line">   <span class="number"> 37370022 </span>ICMP messages received</span><br><span class="line">   <span class="number"> 158 </span>input ICMP message failed.</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 141016</span><br><span class="line">        echo requests: 20256273</span><br><span class="line">        echo replies: 16972733</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@pudding-161 ~]<span class="comment"># ss -s</span></span><br><span class="line">Total:<span class="number"> 1434 </span>(kernel 1816)</span><br><span class="line">TCP:  <span class="number"> 1144 </span>(estab 894, closed 164, orphaned 0, synrecv 0, timewait 158/0), ports 0</span><br><span class="line"></span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line">*        <span class="number"> 1816 </span>     -         -</span><br><span class="line">RAW      <span class="number"> 2 </span>       <span class="number"> 1 </span>        1</span><br><span class="line">UDP      <span class="number"> 13 </span>      <span class="number"> 7 </span>        6</span><br><span class="line">TCP      <span class="number"> 980 </span>     <span class="number"> 349 </span>      631</span><br><span class="line">INET     <span class="number"> 995 </span>     <span class="number"> 357 </span>      638</span><br><span class="line">FRAG     <span class="number"> 0 </span>       <span class="number"> 0 </span>        0</span><br></pre></td></tr></table></figure><h3 id="网络吞吐-和-PPS"><a href="#网络吞吐-和-PPS" class="headerlink" title="网络吞吐 和 PPS"></a>网络吞吐 和 PPS</h3><p>使用 sar 命令，加上 -n 参数，可以查看网络的统计信息，比如网络接口（DEV）、网络接口错误（EDEV）、TCP、UDP、ICMP 等</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sar <span class="operator">-</span>n DEV <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span><span class="operator">-</span><span class="number">957</span>.el7.x86_64 (xxx)       <span class="number">06</span><span class="symbol">/18/2025</span>      _x86_64_        (<span class="number">8</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">42</span> PM     IFACE   rxpck<span class="symbol">/s</span>   txpck<span class="symbol">/s</span>    rxkB<span class="symbol">/s</span>    txkB<span class="symbol">/s</span>   rxcmp<span class="symbol">/s</span>   txcmp<span class="symbol">/s</span>  rxmcst<span class="symbol">/s</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM    dummy0      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM      eth0    <span class="number">695.00</span>    <span class="number">663.00</span>   <span class="number">6938.75</span>   <span class="number">3796.65</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM        lo    <span class="number">112.00</span>    <span class="number">112.00</span>     <span class="number">39.30</span>     <span class="number">39.30</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM kube-ipvs0      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure><ul><li>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包/秒</li><li>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/s</li><li>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包/秒</li></ul><p>带宽可以用 ethtool 来查询，它的单位通常是 Gb/s 或者 Mb/s（千兆网卡或者万兆网卡的单位都是 bit）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool enp4s0f0 <span class="string">| grep Speed</span></span><br><span class="line">        Speed<span class="punctuation">:</span> <span class="number">1000</span>Mb/s</span><br></pre></td></tr></table></figure><h3 id="连通性和延时"><a href="#连通性和延时" class="headerlink" title="连通性和延时"></a>连通性和延时</h3><p>使用命令 ping，来测试远程主机的连通性和延时（基于 ICMP 协议）</p><p>如下，测试本机到 baidu.com 这个地址的连通性和延时</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in"> ping </span>-c3 baidu.com<span class="built_in"></span></span><br><span class="line"><span class="built_in">PING </span>baidu.com (182.61.201.211) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=29.1 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=27.2 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=27.8 ms</span><br><span class="line"></span><br><span class="line">--- baidu.com<span class="built_in"> ping </span>statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 27.280/28.097/29.158/0.785 ms</span><br></pre></td></tr></table></figure><p>ping 的输出，可以分为两部分：</p><ul><li>每个 ICMP 请求的信息，包括 ICMP 序列号（icmp_seq）、TTL（生存时间，或者跳数）以及往返延时</li><li>三次 ICMP 请求的汇总</li></ul><h2 id="C10K和C100K问题"><a href="#C10K和C100K问题" class="headerlink" title="C10K和C100K问题"></a>C10K和C100K问题</h2><h3 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h3><p>C10K 代表同时处理 10000 个请求</p><p>从资源上来说，对 2GB 内存和千兆网卡的服务器来说，同时处理 10000 个请求，只要每个请求处理占用不到 200KB（2GB/10000）的内存和 100Kbit（1000Mbit/10000）的网络带宽就可以。</p><p>从软件上来看，主要是网络 I/O 模型的问题，在 C10K 之前，Linux 主要是<strong>同步阻塞</strong>的方式，每个请求都分配一个进程或者线程，而 10000 个进程或者线程的调度、上下文切换和内存，都可能成为瓶颈。</p><p>需要解决的问题：</p><ul><li>怎样在一个线程内处理多个请求，也就是要在一个线程内响应多个网络 I/O？</li></ul><h4 id="I-O-模型优化"><a href="#I-O-模型优化" class="headerlink" title="I/O 模型优化"></a>I/O 模型优化</h4><p>异步、非阻塞 I/O 的思路：I/O 多路复用</p><blockquote><p>两种 I/O 时间通知的方式：水平触发和边缘触发<br>水平触发：只要文件描述符可以非阻塞地执行 I/O，就会触发通知。也就是说，应用程序可以随时检查文件描述符地状态，然后再根据状态，进行 I/O 操作。<br>边缘触发：只有在文件描述符的状态发生改变（也就是 I/O 请求达到）时，才会发送一次通知。这时候，应用程序需要尽可能多地执行 I/O，知道无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了</p></blockquote><ul><li>第一种，使用非阻塞 I/O 和水平触发通知，比如使用 select 或者 poll</li><li>第二种，使用非阻塞 I/O 和边缘触发通知，比如 epoll（在 select 和 poll 基础上进行优化）</li><li>第三种，使用异步 I/O（Asynchronous I/O，简称为 AIO）</li></ul><h4 id="工作模型优化"><a href="#工作模型优化" class="headerlink" title="工作模型优化"></a>工作模型优化</h4><p>I/O 多路复用有两种主要的工作模式：</p><p><strong>第一种</strong>：主进程 + 多个 worker 子进程（比如 nginx），主要流程是：</p><ul><li>主进程执行 bind() + listen() 后，创建多个子进程；</li><li>在每个子进程中，都通过 accept() 或 epoll_wait() ，来处理相同的套接字</li></ul><p><img src="/img/2025-06-17-linux_tracing_network/image.png" alt="示意图"></p><p><strong>注意</strong>：accept() 和 epoll_wait() 调用，还存在一个<strong>惊群</strong>的问题（当网络 I/O 事件发生时，多个进程被同时唤醒，但实际上只有一个进程来响应这个事件，其他被唤醒的进程都会重新休眠）</p><p>为了避免<strong>惊群问题</strong>，Nginx 在每个 worker 进程中，都会增加一个全局锁（accept_mutex）。这些 worder 进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到 epoll 中，这样就确保只有一个 worker 子进程被唤醒</p><p><strong>第二种</strong>：监听到相同端口的多进程模型，所有的进程都监听相同的端口，有各自的套接字，开启 SO_REUSEPORT 选项（Linux 3.9+ 才支持），由内核负责将请求负载均衡到这些监听进程中去</p><p><img src="/img/2025-06-17-linux_tracing_network/image2.png" alt="示意图"></p><h3 id="C1000K"><a href="#C1000K" class="headerlink" title="C1000K"></a>C1000K</h3><p>C1000K 代表同时 100w 个请求</p><ul><li>从物理资源上来说，100 万个请求需要大量的系统资源<ul><li>内存：假设每个请求需要 16KB 内存的化，那么总共就需要大约 15GB 内存</li><li>带宽：假设只有 20% 活跃连接，即使每个连接只需要 1KB/s 的吞吐量，总共需要 200000 * 8 / 1024 / 1024 = 1.6 Gb/s 的吞吐量，千兆网卡已经不能够满足，需要配置万兆网卡</li></ul></li><li>从软件资源上来说，大量的连接也会占用大量的软件资源，比如<strong>文件描述符的数据、连接状态的跟踪（CONNTRACK）、网络协议栈的缓存大小（比如套接字读写缓存、TCP 读写缓存）</strong>等等，也会带来<strong>大量的中断处理</strong></li></ul><p><strong>优化</strong>：在 I/O 多路复用的基础上，需要多队列网卡、硬中断负载均衡、CPU 绑定、RPS/RFS（软中断负载均衡到多个 CPU 核上），以及将网络包的处理卸载（Offload）到网络设备（如 TSO/GSO、LRO/GRO、VXLAN OFFLOAD）等各种硬件和软件的优化。</p><h3 id="C10M"><a href="#C10M" class="headerlink" title="C10M"></a>C10M</h3><p>同时有 1000w 个请求，解决方法是<strong>跳过内核协议栈</strong>，将网络包直接发送到要处理的应用程序</p><p>第一种机制：DPDK（Data Plane Development Kit），用户网络的标准，跳过内核协议栈，直接由用户态进程通过轮询的方式来处理网络请求</p><p><img src="/img/2025-06-17-linux_tracing_network/image3.png" alt="示意图"></p><p>第二种机制：XDP（eXpress Data Path），Linux 内核提供的一种高性能网络数据路径，它允许网络包，在进入内核协议栈之前，就进行处理</p><p><img src="/img/2025-06-17-linux_tracing_network/image4.png" alt="示意图"></p><h2 id="怎么评估系统的网络性能"><a href="#怎么评估系统的网络性能" class="headerlink" title="怎么评估系统的网络性能"></a>怎么评估系统的网络性能</h2><h3 id="各协议层的性能测试"><a href="#各协议层的性能测试" class="headerlink" title="各协议层的性能测试"></a>各协议层的性能测试</h3><h4 id="转发性能"><a href="#转发性能" class="headerlink" title="转发性能"></a>转发性能</h4><p>hping3 工具，测试网络包的处理能力：<a href="https://wangchujiang.com/linux-command/c/hping3.html"> hping3 手册 </a></p><h4 id="TCP-UDP-性能"><a href="#TCP-UDP-性能" class="headerlink" title="TCP/UDP 性能"></a>TCP/UDP 性能</h4><p>iperf 网络性能测试工具：<a href="https://wangchujiang.com/linux-command/c/iperf.html"> iperf 手册 </a></p><p>iperf3 是 iperf 的重写版本，一些常用参数：</p><table><thead><tr><th>主要参数</th><th>参数说明</th></tr></thead><tbody><tr><td>-s</td><td>服务端专用参数，表示 iperf3 以服务端模式运行</td></tr><tr><td>-c</td><td>客户端专用参数，表示 iperf3 以客户端模式运行</td></tr><tr><td>-i</td><td>设置每次报告之间的时间间隔，单位为秒</td></tr><tr><td>-p</td><td>服务端：指定服务端监听的端口，默认为 5201，同时监听 TCP/UDP。<br> 客户端：指定客户端连接服务端的端口，默认为 5201。如果同时有 -u 参数，表示通过 UDP 发起连接，否则默认使用 TCP 连接</td></tr><tr><td>-u</td><td>表示使用 UDP 协议发送报文。若不指定该参数则表示使用 TCP 协议</td></tr><tr><td>-l</td><td>设置读写缓冲区的长度。通常测试包转发性能时建议该值设为 16，测试带宽时建议该值设为 1400</td></tr><tr><td>-b</td><td>UDP 模式使用的带宽，单位 bit/s</td></tr><tr><td>-t</td><td>设置传输的总时间。iperf3 在指定时间内，重复发送指定长度数据包的时间，默认值为 10 秒</td></tr><tr><td>-A</td><td>设置 CPU 亲和性，可以将 iperf3 进程绑定对应编号的逻辑 CPU，避免 iperf3 进程在不同的 CPU 间被调度</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文介绍 Linux 网络性能指标、调优方法及 C10K/C1000K 问题的应对策略</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：I/O</title>
    <link href="https://wu3227834.github.io/2025/06/02/2025-06-02-linux-tracing-io/"/>
    <id>https://wu3227834.github.io/2025/06/02/2025-06-02-linux-tracing-io/</id>
    <published>2025-06-02T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统和磁盘的区别"><a href="#文件系统和磁盘的区别" class="headerlink" title="文件系统和磁盘的区别"></a>文件系统和磁盘的区别</h2><p>磁盘是一个存储设备（确切来说是块设备），可以划分为不同的磁盘分区。而在磁盘或者磁盘分区上，还可以在创建文件系统，并挂载到系统的某个目录。这样，系统就可以通过这个挂载目录，来读写文件。</p><p>换句话说，磁盘是存储数据的块设备，也是文件系统的载体。所以，文件系统确实还是要通过磁盘，来保证数据的持久化存储。</p><p><strong>Linux 中一切皆文件</strong>。可以通过相同的文件接口，来访问磁盘和文件（比如 open、read、write、close 等）</p><ul><li>通常说的“文件”，是指普通文件</li><li>磁盘和分区，是指块设备文件</li></ul><p>在读写普通文件时，I/O 请求会首先经过文件系统，然后由文件系统负责，来与磁盘进行交互。而读写块设备文件时，会跳过文件系统，直接与磁盘交互，也就是所谓的“裸 I/O”。文件系统管理的缓存，是 Cache 的一部分；而裸磁盘的缓存，用的正是 Buffer。</p><blockquote><p>裸磁盘，也称为原始磁盘，是一种未被任何文件系统（如NTFS、FAT32）格式化或管理的磁盘。换句话说，它是直接与磁盘硬件交互，而不通过操作系统的文件系统层进行访问。</p></blockquote><p>缓存 I/O 与直接 I/O（裸磁盘 I/O ）的对比</p><table><thead><tr><th>特性</th><th>缓存I/O（文件系统）</th><th>直接I/O（裸磁盘）</th></tr></thead><tbody><tr><td>数据流</td><td>磁盘 → 内核缓冲区 → 应用程序地址空间</td><td>磁盘 → 直接应用程序地址空间</td></tr><tr><td>缓存使用</td><td>使用文件系统管理的Cache</td><td>使用磁盘的Buffer</td></tr><tr><td>性能</td><td>适合常规文件操作，减少磁盘读写次数</td><td>适合高性能场景，如数据库，减少文件系统开销</td></tr><tr><td>应用场景</td><td>普通文件读写，系统默认方式</td><td>虚拟化、数据库优化、低级别磁盘操作</td></tr><tr><td>优点</td><td>保护系统安全，减少直接磁盘访问风险</td><td>降低数据复制开销，提高I/O效率</td></tr><tr><td>缺点</td><td>数据复制开销高，CPU和内存占用多</td><td>需要应用程序管理缓存，可能增加复杂性</td></tr></tbody></table><h2 id="Linux-文件系统如何工作"><a href="#Linux-文件系统如何工作" class="headerlink" title="Linux 文件系统如何工作"></a>Linux 文件系统如何工作</h2><h3 id="索引节点和目录项"><a href="#索引节点和目录项" class="headerlink" title="索引节点和目录项"></a>索引节点和目录项</h3><ul><li>索引节点（inode），和文件一一对应，存储在磁盘中，记录文件的元数据</li><li>目录项（dentry），记录文件的名字、索引节点以及其他目录项的关联关系</li></ul><p>举例说明，为文件创建的硬链接，会对应不同的目录项，他们都连接到同一个文件，索引节点相同。</p><p>磁盘的最小单位是<strong>扇区</strong>，文件系统将连续的扇区组成逻辑块，以逻辑块为最小单位，来读写磁盘数据。常见的逻辑块 4KB，由连续的 8 个扇区组成。</p><p><img src="/img/2025-06-02-linux_tracing_io/image.png" alt="示意图"></p><p>磁盘在执行文件系统格式化时，分为三个区域：超级块、索引节点和数据块：</p><ul><li>超级块：整个文件系统的状态</li><li>索引节点区：存储索引节点</li><li>数据块区：存储文件数据</li></ul><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><img src="/img/2025-06-02-linux_tracing_io/image2.png" alt="示意图"></p><p>文件系统分类：</p><ul><li>基于磁盘的文件系统：常见的 ext4、XFS、OverlayFS 等，都是这类文件系统</li><li>基于内存的文件系统：常说的虚拟文件系统，不需要磁盘空间，但是占用内存。比如，/proc 和 /sys</li><li>网络文件系统：用于访问其他计算机的文件系统，比如 NFS、SMB、ISCSI 等</li></ul><p><strong>注意</strong>：这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为<strong>挂载点</strong>），然后才能访问其中的文件。</p><h3 id="文件系统-I-O"><a href="#文件系统-I-O" class="headerlink" title="文件系统 I/O"></a>文件系统 I/O</h3><p>根据是否利用标准库缓存，分为<strong>缓冲 I/O 和非缓冲 I/O</strong>：</p><ul><li>缓存 I/O：利用标准库缓存，加速文件访问，标准库内部利用系统调用访问文件</li><li>非缓存 I/O：直接通过系统调用访问文件，不再经过标准库缓存</li></ul><p><strong>注意</strong>：这里的“缓冲”，是指<strong>标准库内部实现的缓存</strong>，最终还是需要通过系统调用，而系统调用还会通过<strong>页缓存</strong>，来较少磁盘的 I/O 操作</p><p>根据是否利用操作系统的<strong>页缓存</strong>，分为<strong>直接 I/O 和非直接 I/O</strong>：</p><ul><li>直接 I/O：跳过操作系统的页缓存，直接和<strong>文件系统</strong>交互来访问文件</li><li>非直接 I/O：先通过页缓存，再通过内核或者额外的系统调用，真正和磁盘交互（O_DIRECT 标志）</li></ul><p>根据应用程序是否阻塞自身，分为<strong>阻塞 I/O 和非阻塞 I/O</strong>：</p><ul><li>阻塞 I/O：是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程</li><li>非阻塞 I/O：是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过<strong>轮询或者事件通知</strong>的形式，获取调用的结果</li></ul><p>根据是否等待相应结果，分为<strong>同步 I/O 和异步 I/O</strong>：</p><ul><li>同步 I/O：应用程序执行 I/O 操作之后，要等到整个 I/O 完成后，才能获得 I/O 响应</li><li>异步 I/O：应用程序不用等待 I/O 完成，会继续执行，等到 I/O 执行完成，会以事件的方式通知应用程序</li></ul><p>设置 O_SYNC 或者 O_DSYNC，代表同步 I/O。如果是 O_DSYNC，要等到文件数据写入磁盘之后，才能返回，如果是 O_SYNC，是在 O_DSYNC 的基础上，要求文件<strong>元数据</strong>写入磁盘，才返回。</p><p>设置 O_ASYNC，代表异步 I/O，系统会再通过 SIGIO 或者 SIFPOLL 通知进程。</p><h3 id="性能观测"><a href="#性能观测" class="headerlink" title="性能观测"></a>性能观测</h3><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>df 命令查看磁盘空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -h /dev/vdb</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vdb        400G   95G  306G  24% /var/lib/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引节点所占的空间</span></span><br><span class="line">$ <span class="built_in">df</span> -i /dev/vdb</span><br><span class="line">Filesystem        Inodes  IUsed     IFree IUse% Mounted on</span><br><span class="line">/dev/vdb       209715200 546727 209168473    1% /var/lib/docker</span><br></pre></td></tr></table></figure><p>当索引节点空间不足，但是索引空间充足时，可能是过多小文件导致的。<strong>解决方法</strong>一般是删除这些小文件，或者移动到索引节点充足的其他磁盘区。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>可以使用 free 或者 vmstat，观察页缓存的大小；也可以查看 /proc/meminfo</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="keyword">/proc/</span>meminfo | grep -E <span class="string">&quot;SReclaimable|Cached&quot;</span></span><br><span class="line"><span class="symbol">Cached:</span>          <span class="number">3987272</span> kB</span><br><span class="line"><span class="symbol">SwapCached:</span>       <span class="number">109532</span> kB</span><br><span class="line"><span class="symbol">SReclaimable:</span>    <span class="number">4095228</span> kB</span><br></pre></td></tr></table></figure><p>内核使用 slab 机制，管理目录项和索引节点的缓存，/proc/meminfo 给出了整体的 slab 大小，/proc/slabinfo 可以查看每一种 slab 的缓存</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]<span class="comment"># cat /proc/slabinfo | grep -E &#x27;^#|dentry|inode&#x27;</span></span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line">fuse_inode          <span class="number"> 189 </span>  <span class="number"> 189 </span>  <span class="number"> 768 </span> <span class="number"> 21 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 9 </span>    <span class="number"> 9 </span>     0</span><br><span class="line">ovl_inode         <span class="number"> 11534 </span><span class="number"> 15600 </span>  <span class="number"> 680 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 650 </span>  <span class="number"> 650 </span>     0</span><br><span class="line">xfs_inode        <span class="number"> 175054 </span>175372   <span class="number"> 960 </span> <span class="number"> 34 </span>  <span class="number"> 8 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 5158 </span> <span class="number"> 5158 </span>     0</span><br><span class="line">mqueue_inode_cache   <span class="number"> 288 </span>  <span class="number"> 288 </span>  <span class="number"> 896 </span> <span class="number"> 36 </span>  <span class="number"> 8 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 8 </span>    <span class="number"> 8 </span>     0</span><br><span class="line">hugetlbfs_inode_cache    <span class="number"> 52 </span>   <span class="number"> 52 </span>  <span class="number"> 608 </span> <span class="number"> 26 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 2 </span>    <span class="number"> 2 </span>     0</span><br><span class="line">sock_inode_cache   <span class="number"> 2255 </span> <span class="number"> 2475 </span>  <span class="number"> 640 </span> <span class="number"> 25 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata    <span class="number"> 99 </span>   <span class="number"> 99 </span>     0</span><br><span class="line">shmem_inode_cache  <span class="number"> 6783 </span> <span class="number"> 7056 </span>  <span class="number"> 680 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 294 </span>  <span class="number"> 294 </span>     0</span><br><span class="line">proc_inode_cache  <span class="number"> 28816 </span><span class="number"> 29688 </span>  <span class="number"> 656 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 1237 </span> <span class="number"> 1237 </span>     0</span><br><span class="line">inode_cache       <span class="number"> 34463 </span><span class="number"> 35208 </span>  <span class="number"> 592 </span> <span class="number"> 27 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 1304 </span> <span class="number"> 1304 </span>     0</span><br><span class="line">dentry           <span class="number"> 20014134 </span>20014134   <span class="number"> 192 </span> <span class="number"> 21 </span>  <span class="number"> 1 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata<span class="number"> 953054 </span>953054      0</span><br><span class="line">selinux_inode_security <span class="number"> 15708 </span><span class="number"> 15708 </span>   <span class="number"> 40 </span><span class="number"> 102 </span>  <span class="number"> 1 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 154 </span>  <span class="number"> 154 </span>     0</span><br></pre></td></tr></table></figure><p>其中 dentry 代表目录项缓存，inode_cache 代表 VFS 索引节点缓存，其他的就是各种文件系统的索引节点缓存。</p><p>实际性能分析中，更常使用 slabtop 命令，来找出占用内存最多的缓存类型。</p><p>示例如下：可以看到，目录项占用了最多的 Slab 缓存，大约 3.91 G</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下c按照缓存大小排序，按下a按照活跃对象数排序 </span></span><br><span class="line">$ slabtop</span><br><span class="line"> Active / Total Objects (% used)    :<span class="number"> 22757396 </span>/<span class="number"> 23018218 </span>(98.9%)</span><br><span class="line"> Active / Total Slabs (% used)      :<span class="number"> 1067320 </span>/<span class="number"> 1067320 </span>(100.0%)</span><br><span class="line"> Active / Total Caches (% used)     :<span class="number"> 72 </span>/<span class="number"> 103 </span>(69.9%)</span><br><span class="line"> Active / Total Size (% used)       : 4462258.28K / 4545420.86K (98.2%)</span><br><span class="line"> Minimum / Average / Maximum Object : 0.01K / 0.20K / 8.00K</span><br><span class="line"></span><br><span class="line">  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME</span><br><span class="line">21574896<span class="number"> 21574735 </span> 99%    0.19K<span class="number"> 1027376 </span>     <span class="number"> 21 </span>  4109504K dentry</span><br><span class="line">355914<span class="number"> 286236 </span> 80%    0.10K  <span class="number"> 9126 </span>     <span class="number"> 39 </span>    36504K buffer_head</span><br><span class="line">223872<span class="number"> 205323 </span> 91%    0.06K  <span class="number"> 3498 </span>     <span class="number"> 64 </span>    13992K kmalloc-64</span><br><span class="line">175372<span class="number"> 175125 </span> 99%    0.94K  <span class="number"> 5158 </span>     <span class="number"> 34 </span>   165056K xfs_inode</span><br><span class="line"><span class="number"> 57600 </span><span class="number"> 57529 </span> 99%    0.16K  <span class="number"> 2400 </span>     <span class="number"> 24 </span>     9600K xfs_ili</span><br><span class="line">136528 <span class="number"> 53170 </span> 38%    0.57K  <span class="number"> 4876 </span>     <span class="number"> 28 </span>    78016K radix_tree_node</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Linux-磁盘-I-O-工作原理"><a href="#Linux-磁盘-I-O-工作原理" class="headerlink" title="Linux 磁盘 I/O 工作原理"></a>Linux 磁盘 I/O 工作原理</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>根据存储介质，磁盘分为：</p><ul><li>机械磁盘，也称为硬盘驱动器（Hard Disk Driver），通常缩写为 HDD。机械磁盘主要有盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位数据所在的磁道，才能访问数据。如果 I/O 请求刚好连续，就不需要磁道寻址，可以获得最佳性能。这就是连续 I/O 的工作原理。与之对应的是随机 I/O，它需要不停地移动磁头，来定位数据位置，读写速度就会比较慢。</li><li>固态磁盘（Silid State Disk），通常缩写为 SSD，由固态电子元件组成。固态磁盘不需要磁盘寻址，不管是连续 I/O，还是随机 I/O 的性能，都比机械磁盘要好得多。</li></ul><p>无论是机械磁盘，还是固态磁盘，相同磁盘的随机 I/O 都要比连续 I/O 慢得多，原因是：</p><ul><li>随机 I/O 需要更多的磁头寻道和盘片旋转，它的性能自然要比连续 I/O 慢</li><li>对于固态硬盘来说，虽然它的随机性能比机械磁盘好很多，但同样存在“先擦除再写入”的限制。随机读写会导致大量的垃圾回收，所以相对应的，随机 I/O 的性能比起连续 I/O 来，也还差了很多</li><li>连续 I/O 还可以通过预读的方式，来减少 I/O 请求的次数，这也是其性能优异的一个原因</li></ul><p>最小读写单位：</p><ul><li>机械硬盘的最小读写单位是扇区，一般是 512 字节</li><li>固态硬盘的最小读写单位是页，一般是 4KB 或者 8KB</li></ul><p>按照接口，磁盘可分为 IDE（Integrated Drive Electronics）、SCSI（Small Computer System Interface） 、SAS（Serial Attached SCSI） 、SATA（Serial ATA） 、FC（Fibre Channel）等。</p><p>磁盘介入服务器时，按照不通的使用方式，会划分为不用的架构：</p><ul><li>最简单的直接作为独立磁盘设备来使用</li><li>将多块磁盘组合成一个逻辑磁盘，构成冗余独立磁盘阵列（RAID），提高数据访问的性能，并增强数据存储的可靠性</li><li>最后一种，是将磁盘组合成网络存储集群，再通过 NFS、SMB、ISCSI 等网络存储协议，暴露给服务器使用</li></ul><p>在 Linux 中，磁盘是作为一个块设备来管理，以块为单位来读写，支持随机读写。每个块设备赋予两个设备号，分别是主、次设备号，主设备号用在驱动程序中，用来区分设备类型；次设备号用来在多个同类设备编号。</p><h3 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h3><p>和 VFS 类似，为了减少不同设备的差异带来的影响，Linux 通过统一的通用块（块 I/O 层），管理不同的块设备。</p><p>块设备层是处在文件系统和磁盘驱动中间的一个块设备抽象层，主要功能是：</p><ul><li>向上为文件系统和应用程序提供访问块设备的标准接口；向下，把各种异构的磁盘块设备抽象为统一的块设备，提供统一框架管理这些设备的驱动程序</li><li>通用块层还会给文件系统和应用程序发来 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率</li></ul><p>对 I/O 请求排序的过程就是 I/0 调度，Linux 支持的四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine：</p><ul><li>NONE，不适用任何调度，对 I/O 不做任何处理（常用在虚拟机，此时磁盘 I/O 完全由物理机复杂）</li><li>NOOP，先入先出调度（常用在 SSD）</li><li>CFQ（Completely Fair Schedule）完全公平调度器，很多 Linux 发行版的默认调度器，它为每个进程维护了一个 I/O 调度队列，按照时间片来均匀分配每个进程的 I/O 请求；还支持优先级调度，适用于大量进程的系统（如桌面、多媒体应用等）</li><li>DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保打到最终期限（deadline）的请求被优化处理，多用在 I/O 压力比较重的场景，比如数据库等</li></ul><h3 id="I-O-栈"><a href="#I-O-栈" class="headerlink" title="I/O 栈"></a>I/O 栈</h3><p><img src="/img/2025-06-02-linux_tracing_io/image3.png" alt="示意图"></p><p>根据这张 I/O 栈的全景图，可以看出存储系统 I/O 的工作原理</p><ul><li>文件系统层，包括虚拟文件系统和其他文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过快层，来存储和管理磁盘资源</li><li>通用块层，包括块设备 I/O 队列和 I/O 调度器。他会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发给下一级的设备层</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作</li></ul><p>存储系统的 I/O，通常是整个系统最慢的一环。</p><p>Linux 通过多种缓存机制来优化 I/O 效率。为了优化文件访问的性能，会使用页缓存、索引节点缓存等多种机制，以减少对下层块设配的直接调用。同样，为了优化块设备，会使用缓冲区，来缓存块设备的数据。</p><h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><p>使用率、饱和度、IOPS、吞吐量以及响应时间五个指标，是磁盘性能的基本指标</p><ul><li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈</li><li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求</li><li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数</li><li>吞吐量，是指每秒 I/O 请求大小</li><li>响应时间，是指 I/O 请求从发出到收到响应的间隔时间</li></ul><p>注意：</p><ol><li>使用率只考虑有没有 I/O，而不考虑 I/O 的大小。换句话说，当使用率是 100% 的时候，磁盘依然有可能接受到新的 I/O 请求</li><li>随即读写多（如数据库、大量小文件）的情况下主要关注 IOPS，而顺序读写（如流媒体）的情况下，主要关注吞吐量</li></ol><p>在为应用程序的服务器选型时，要先对磁盘的 I/O 性能进行基准测试，以便可以准确评估，磁盘性能是否可以满足应用程序的需求</p><h3 id="磁盘-I-O-观测"><a href="#磁盘-I-O-观测" class="headerlink" title="磁盘 I/O 观测"></a>磁盘 I/O 观测</h3><p>使用 iostat 观测每块磁盘的使用情况，提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，这些指标实际上来自 /proc/diskstats</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ iostat <span class="operator">-</span>dx <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span><span class="operator">-</span><span class="number">1160.76</span>.<span class="number">1</span>.el7.x86_64 (idc16)       <span class="number">2025</span>年<span class="number">06</span>月<span class="number">16</span>日  _x86_64_        (<span class="number">40</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="params">Device:</span>         rrqm<span class="symbol">/s</span>   wrqm<span class="symbol">/s</span>     r<span class="symbol">/s</span>     w<span class="symbol">/s</span>    rkB<span class="symbol">/s</span>    wkB<span class="symbol">/s</span> avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               <span class="number">0.00</span>     <span class="number">0.69</span>    <span class="number">1.56</span>   <span class="number">25.12</span>    <span class="number">62.56</span>   <span class="number">270.97</span>    <span class="number">25.01</span>     <span class="number">0.27</span>   <span class="number">10.01</span>    <span class="number">0.84</span>   <span class="number">10.58</span>   <span class="number">1.18</span>   <span class="number">3.14</span></span><br><span class="line">sdd               <span class="number">0.00</span>     <span class="number">0.27</span>    <span class="number">0.17</span>    <span class="number">1.33</span>    <span class="number">10.66</span>    <span class="number">42.08</span>    <span class="number">70.12</span>     <span class="number">0.01</span>    <span class="number">8.48</span>    <span class="number">6.95</span>    <span class="number">8.68</span>   <span class="number">0.26</span>   <span class="number">0.04</span></span><br><span class="line">sdc               <span class="number">0.00</span>     <span class="number">0.61</span>    <span class="number">0.27</span>    <span class="number">9.80</span>    <span class="number">13.02</span>   <span class="number">193.43</span>    <span class="number">41.03</span>     <span class="number">0.04</span>    <span class="number">3.52</span>    <span class="number">0.82</span>    <span class="number">3.59</span>   <span class="number">0.06</span>   <span class="number">0.06</span></span><br><span class="line">sde               <span class="number">0.00</span>     <span class="number">0.22</span>    <span class="number">0.21</span>    <span class="number">1.38</span>    <span class="number">11.79</span>    <span class="number">43.80</span>    <span class="number">70.07</span>     <span class="number">0.01</span>    <span class="number">8.43</span>    <span class="number">7.23</span>    <span class="number">8.61</span>   <span class="number">0.26</span>   <span class="number">0.04</span></span><br><span class="line">sdf               <span class="number">0.00</span>     <span class="number">0.24</span>    <span class="number">0.07</span>    <span class="number">1.29</span>    <span class="number">13.02</span>    <span class="number">18.95</span>    <span class="number">47.09</span>     <span class="number">0.00</span>    <span class="number">3.29</span>   <span class="number">17.06</span>    <span class="number">2.56</span>   <span class="number">0.20</span>   <span class="number">0.03</span></span><br><span class="line">sdh               <span class="number">0.00</span>     <span class="number">0.26</span>    <span class="number">0.01</span>    <span class="number">1.32</span>     <span class="number">1.49</span>    <span class="number">19.72</span>    <span class="number">31.78</span>     <span class="number">0.00</span>    <span class="number">1.70</span>    <span class="number">9.23</span>    <span class="number">1.63</span>   <span class="number">0.09</span>   <span class="number">0.01</span></span><br><span class="line">sdg               <span class="number">0.00</span>     <span class="number">0.23</span>    <span class="number">0.05</span>    <span class="number">1.30</span>    <span class="number">11.18</span>    <span class="number">21.33</span>    <span class="number">48.10</span>     <span class="number">0.01</span>    <span class="number">4.07</span>   <span class="number">24.12</span>    <span class="number">3.28</span>   <span class="number">0.21</span>   <span class="number">0.03</span></span><br><span class="line">sdi               <span class="number">0.00</span>     <span class="number">0.28</span>    <span class="number">0.04</span>    <span class="number">1.67</span>     <span class="number">9.65</span>    <span class="number">19.50</span>    <span class="number">33.96</span>     <span class="number">0.00</span>    <span class="number">1.86</span>   <span class="number">25.33</span>    <span class="number">1.26</span>   <span class="number">0.15</span>   <span class="number">0.03</span></span><br><span class="line">sdj               <span class="number">0.00</span>     <span class="number">0.24</span>    <span class="number">0.36</span>    <span class="number">2.35</span>    <span class="number">21.61</span>   <span class="number">247.35</span>   <span class="number">198.58</span>     <span class="number">0.14</span>   <span class="number">51.46</span>    <span class="number">4.47</span>   <span class="number">58.60</span>   <span class="number">0.49</span>   <span class="number">0.13</span></span><br><span class="line">sdb               <span class="number">0.00</span>     <span class="number">0.46</span>    <span class="number">1.66</span>    <span class="number">8.00</span>   <span class="number">180.35</span>   <span class="number">210.13</span>    <span class="number">80.81</span>     <span class="number">0.08</span>    <span class="number">8.74</span>    <span class="number">2.84</span>    <span class="number">9.97</span>   <span class="number">0.20</span>   <span class="number">0.19</span></span><br><span class="line">dm-<span class="number">0</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.85</span>   <span class="number">18.11</span>    <span class="number">38.11</span>   <span class="number">144.32</span>    <span class="number">19.24</span>     <span class="number">0.17</span>    <span class="number">8.82</span>    <span class="number">0.56</span>    <span class="number">9.21</span>   <span class="number">1.14</span>   <span class="number">2.16</span></span><br><span class="line">dm-<span class="number">1</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">49.16</span>     <span class="number">0.00</span>   <span class="number">11.10</span>   <span class="number">11.10</span>    <span class="number">0.00</span>   <span class="number">9.62</span>   <span class="number">0.00</span></span><br><span class="line">scd0              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">80.31</span>     <span class="number">0.00</span>  <span class="number">813.35</span>  <span class="number">813.35</span>    <span class="number">0.00</span> <span class="number">809.27</span>   <span class="number">0.00</span></span><br><span class="line">dm-<span class="number">2</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.21</span>     <span class="number">0.04</span>    <span class="number">16.16</span>   <span class="number">155.78</span>     <span class="number">0.02</span>   <span class="number">99.54</span>    <span class="number">2.63</span>  <span class="number">100.60</span>   <span class="number">1.79</span>   <span class="number">0.04</span></span><br><span class="line">dm-<span class="number">3</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.68</span>    <span class="number">4.54</span>    <span class="number">22.80</span>    <span class="number">72.63</span>    <span class="number">36.54</span>     <span class="number">0.07</span>   <span class="number">14.35</span>    <span class="number">1.04</span>   <span class="number">16.35</span>   <span class="number">1.31</span>   <span class="number">0.69</span></span><br><span class="line">dm-<span class="number">4</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.02</span>    <span class="number">2.93</span>     <span class="number">0.38</span>    <span class="number">37.73</span>    <span class="number">25.90</span>     <span class="number">0.03</span>   <span class="number">10.70</span>    <span class="number">4.72</span>   <span class="number">10.73</span>   <span class="number">1.32</span>   <span class="number">0.39</span></span><br></pre></td></tr></table></figure><p>各个指标解读如下</p><p><img src="/img/2025-06-02-linux_tracing_io/image4.png" alt="iostat 指标解读图"></p><p>注意：</p><ul><li>%util，就是我们前面提到的磁盘 I/O 使用率</li><li>r/s + w/s，就是 IOPS</li><li>rkB/s + wkB/s，就是吞吐量</li><li>r_await+w_await，就是响应时间</li></ul><p>在观测指标时，可以结合请求的大小（rareq-sz 和 wareq-sz）一起分析。</p><h3 id="进程-I-O-观测"><a href="#进程-I-O-观测" class="headerlink" title="进程 I/O 观测"></a>进程 I/O 观测</h3><p>pidstat 可以实时查看某个进程的 I/O 情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -d 1</span><br><span class="line">Linux 3.10.0-957.el7.x86_64 (xxx)       06/17/2025      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">07:12:18 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">07:12:19 PM   <span class="number"> 27 </span>  <span class="number"> 362006 </span>     0.00    594.17    590.29  mysqld</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362323 </span>     0.00      3.88      3.88  docker-containe</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362403 </span>     0.00      7.77      0.00  kundb-meta-serv</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362518 </span>     0.00      3.88      0.00  java</span><br><span class="line">07:12:19 PM<span class="number"> 65534 </span>  <span class="number"> 363123 </span>     0.00      3.88      0.00  prometheus</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 372218 </span>     0.00      7.77      0.00  java</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 383196 </span>     0.00     19.42      0.00  dockerd</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 389626 </span>     0.00     23.30      0.00  kube-apiserver</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 389731 </span>     0.00     62.14      0.00  etcd</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 391157 </span>     0.00     11.65      0.00  kubelet</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 760300 </span>     0.00     11.65      0.00  kundb-meta-serv</span><br></pre></td></tr></table></figure><p>指标如下：</p><ul><li>用户 ID（UID）和进程 ID（PID）</li><li>每秒读取的数据大小（kB_rd/s），单位是 KB</li><li>每秒发出的写请求数据大小（kB_wr/s），单位是 KB</li><li>每秒取消的写请求数据大小（KB_ccwr/s），单位是 KB</li></ul>]]></content>
    
    
    <summary type="html">本文深入探讨Linux文件系统与磁盘I/O的工作原理，分析缓存I/O与直接I/O的差异，详解索引节点、虚拟文件系统及I/O调度算法，并提供df、iostat等工具的性能观测方法，助力系统性能调优。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何“快准狠”找到系统内存的问题</title>
    <link href="https://wu3227834.github.io/2025/05/30/2025-05-30-ru-he-kuai-zhun-hen-de-zhao-dao-xi-tong-nei-cun-wen-ti/"/>
    <id>https://wu3227834.github.io/2025/05/30/2025-05-30-ru-he-kuai-zhun-hen-de-zhao-dao-xi-tong-nei-cun-wen-ti/</id>
    <published>2025-05-30T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存性能指标"><a href="#内存性能指标" class="headerlink" title="内存性能指标"></a>内存性能指标</h2><p>系统调用内存分配请求后，并不会立刻为其分配物理内存，而是在请求首次访问时，通过缺页异常来分配</p><p>缺页异常又分为以下两种场景：</p><ul><li>可以直接从物理内存中分配时，被称为<strong>次缺页异常</strong></li><li>需要磁盘 I/O 介入（比如 Swap）时，被称为<strong>主缺页异常</strong></li></ul><p><img src="/img/2025-05-30-%E5%A6%82%E4%BD%95%E5%BF%AB%E5%87%86%E7%8B%A0%E7%9A%84%E6%89%BE%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/image.png" alt="内存性能指标"></p><h2 id="分析内存性能瓶颈"><a href="#分析内存性能瓶颈" class="headerlink" title="分析内存性能瓶颈"></a>分析内存性能瓶颈</h2><p>分析过程如下图</p><ul><li>先用 free 和 top，查看系统整体的内存使用情况</li><li>再用 vmstat 和 pidstat，查看一段时间的趋势，从而判断出内存问题的类型</li><li>最后进行详细分析，比如内存分配分析、缓存/缓冲区分析、具体进程的内存使用分析等</li></ul><p><img src="/img/2025-05-30-%E5%A6%82%E4%BD%95%E5%BF%AB%E5%87%86%E7%8B%A0%E7%9A%84%E6%89%BE%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/image2.png" alt="分析内存性能"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内存常见的优化思路有这么几种</p><ul><li>最好禁止 Swap。如果必须开启 Swap，降低 swappiness 的值，减少内存回收时 Swap 的使用倾向</li><li>减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等</li><li>尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问</li><li>使用 cgroups 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽</li><li>通过 /proc/pid/oom_adj，调整核心应用的 oom_score。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死</li></ul>]]></content>
    
    
    <summary type="html">本文介绍如何通过工具快速定位 Linux 系统内存瓶颈并提供优化建议</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：内存</title>
    <link href="https://wu3227834.github.io/2025/05/28/2025-05-28-linux-tracing-mem/"/>
    <id>https://wu3227834.github.io/2025/05/28/2025-05-28-linux-tracing-mem/</id>
    <published>2025-05-28T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux内存工作原理"><a href="#Linux内存工作原理" class="headerlink" title="Linux内存工作原理"></a>Linux内存工作原理</h2><h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。</p><p>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。</p><p>对大块内存（大于 128K），则使用内存映射 mmap() 来分配，也就是在文件映射找一块空闲内存分配出去。</p><p>各自的<strong>优缺点</strong>：</p><ul><li>brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率；不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片</li><li>mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大</li></ul><p>整体来说，Linux 使用<strong>伙伴系统</strong>来管理内存分配。前面我们提到过，这些内存在 MMU 中以页为单位进行管理，伙伴系统也一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如 brk 方法造成的内存碎片）。</p><p>在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 通过 slab 分配器来管理小内存，可以把 slab 堪称构建在<strong>伙伴系统上的一个缓存</strong>，主要作用就是分配并释放内核中的小对象。</p><p>系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统会通过一系列机制来回收内存：</p><ul><li>回收内存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面</li><li>回收不常访问的内存，把不常用的内存交换分区直接写到磁盘中（会用到交换分区）</li><li>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程</li></ul><p>OOM 是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：</p><ul><li>进程消耗的内存越大，oom_score 就越大</li><li>进程运行占用的 CPU 越多，oom_score 就越小</li></ul><p>可以手动设置进程的 oom_adj 来调整 oom_score。oom_adj 的范围是 [-17, 15]，数值越大，进程越容易被杀死；反之，越不容易被杀死。</p><h3 id="如何查看内存使用情况"><a href="#如何查看内存使用情况" class="headerlink" title="如何查看内存使用情况"></a>如何查看内存使用情况</h3><p>1、free 命令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:     <span class="number"> 262695500 </span> <span class="number"> 106731876 </span> <span class="number"> 141173212 </span>   <span class="number"> 4257008 </span>  <span class="number"> 14790412 </span>  149168720</span><br><span class="line">Swap:            <span class="number"> 0 </span>         <span class="number"> 0 </span>          0</span><br></pre></td></tr></table></figure><ul><li>total：总内存</li><li>used：已使用内存，包括共享内存</li><li>free：空闲内存</li><li>shared：共享内存</li><li>buff/cache：缓存内存，包括缓冲区和缓存</li><li>available：可用内存，包括空闲内存和缓存内存</li></ul><p><strong>注意</strong>：available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>2、top 命令</p><p>可以查看每个进程的内存使用情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top - 19:28:02 up<span class="number"> 201 </span>days,  2:48, <span class="number"> 2 </span>users,  load average: 134.36, 136.81, 111.38</span><br><span class="line">Tasks:<span class="number"> 1284 </span>total,  <span class="number"> 6 </span>running,<span class="number"> 1278 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s): 87.2 us,  8.9 sy,  0.0 ni,  0.9 id,  0.0 wa,  1.8 hi,  1.1 si,  0.0 st</span><br><span class="line">MiB Mem : 256538.6 total, 137892.3 free, 104201.3 used,  14445.0 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used. 145701.9 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number"> 607070 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> 266.3g  82.5g <span class="number"> 79228 </span>S <span class="number"> 4861 </span> 33.0  40025:32 tabletserver_ma</span><br><span class="line"><span class="number"> 835494 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>8557368<span class="number"> 207048 </span><span class="number"> 10872 </span>S 121.7   0.1 357:04.40 java</span><br><span class="line"><span class="number"> 842048 </span>1001     <span class="number"> 20 </span> <span class="number"> 0 </span>  32.8g <span class="number"> 31168 </span><span class="number"> 14888 </span>S 113.0   0.0   0:03.41 java</span><br><span class="line"><span class="number"> 840498 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 727932 </span><span class="number"> 31336 </span> <span class="number"> 7304 </span>R  91.3   0.0   2164:46 node_exporter</span><br><span class="line"><span class="number"> 653917 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>  12.3g<span class="number"> 997944 </span><span class="number"> 46948 </span>S  78.3   0.4  15877:42 kubelet</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>VIRT：虚拟内存，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内</li><li>RES：实际内存，也就是进程<strong>实际使用的物理内存</strong>大小，但<strong>不包括 Swap 和共享内存</strong></li><li>SHR：共享内存，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等</li><li>%MEM：进程占用的物理内存占系统总内存的百分比</li></ul><p><strong>注意</strong>：</p><ul><li>虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都大于实际内存，这是因为虚拟内存是进程申请的内存，即使进程没有真正分配物理内存，也会计算在内。</li><li>共享内存 SHR 并不一定是共享的，比方说，<strong>程序的代码段、非共享的动态内存链接库</strong>，也都在 SHR 里。SHR 也包括了<strong>进程间真正共享的内存</strong>。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果</li></ul><h2 id="内存的-Buffer-和-Cache"><a href="#内存的-Buffer-和-Cache" class="headerlink" title="内存的 Buffer 和 Cache"></a>内存的 Buffer 和 Cache</h2><h3 id="free-的数据来源"><a href="#free-的数据来源" class="headerlink" title="free 的数据来源"></a>free 的数据来源</h3><p>man free 查看</p><p><img src="/img/2025-05-28-linux_tracing_mem/image.png" alt="man free"></p><p>从手册看到：</p><ul><li>Buffers：Memory used by kernel buffers (Buffers in /proc/meminfo)</li><li>Cache：Memory used by the page cache and slabs (Cached and Slab in /proc/meminfo)</li></ul><h3 id="proc-文件系统"><a href="#proc-文件系统" class="headerlink" title="proc 文件系统"></a>proc 文件系统</h3><p>man proc 查看</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Buffers %lu</span><br><span class="line">       Relatively temporary storage <span class="keyword">for</span> raw disk blocks <span class="keyword">that</span> shouldn&#x27;t <span class="keyword">get</span> tremendously large (<span class="number">20</span>MB <span class="keyword">or</span> so).</span><br><span class="line"></span><br><span class="line">Cached %lu</span><br><span class="line">       In-memory cache <span class="keyword">for</span> files <span class="built_in">read</span> <span class="keyword">from</span> <span class="keyword">the</span> disk (<span class="keyword">the</span> page cache).  Doesn&#x27;t include SwapCached.</span><br><span class="line">...</span><br><span class="line">SReclaimable %lu (<span class="keyword">since</span> Linux <span class="number">2.6</span><span class="number">.19</span>)</span><br><span class="line">       Part <span class="keyword">of</span> Slab, <span class="keyword">that</span> might be reclaimed, such <span class="keyword">as</span> caches.</span><br><span class="line"></span><br><span class="line">SUnreclaim %lu (<span class="keyword">since</span> Linux <span class="number">2.6</span><span class="number">.19</span>)</span><br><span class="line">       Part <span class="keyword">of</span> Slab, <span class="keyword">that</span> cannot be reclaimed <span class="keyword">on</span> memory pressure.</span><br></pre></td></tr></table></figure><p>通过文档可以看到：</p><ul><li>Buffers 是对原始磁盘的临时存储，也就是用来缓存磁盘的数据，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写入合并成单次大的写等等。</li><li>Cached 是从单磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li><li>Slab 代表内核数据结构缓存，包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。</li></ul><h2 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h2><h3 id="场景一：磁盘和文件写"><a href="#场景一：磁盘和文件写" class="headerlink" title="场景一：磁盘和文件写"></a>场景一：磁盘和文件写</h3><p>运行 vmstat 命令</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16790772</span>     <span class="number">60 8758252</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218088</span> <span class="number">16779960</span>     <span class="number">60 8762060</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">159 15274</span> <span class="number">28820 16</span>  <span class="number">9</span> <span class="number">75</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">16779968</span>     <span class="number">60 8761840</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">154 13467</span> <span class="number">26984</span>  <span class="number">9</span>  <span class="number">4</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16778620</span>     <span class="number">60 8762068</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">212 13980</span> <span class="number">26715</span>  <span class="number">6</span>  <span class="number">5</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">0 1218088</span> <span class="number">16773376</span>     <span class="number">60 8762136</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">170 12838</span> <span class="number">25315</span>  <span class="number">4</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">16780544</span>     <span class="number">60 8762164</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">343 13195</span> <span class="number">25313</span>  <span class="number">5</span>  <span class="number">4</span> <span class="number">91</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16783260</span>     <span class="number">60 8762392</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">116 18099</span> <span class="number">33200 13 10</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16782896</span>     <span class="number">60 8762400</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">40 10645</span> <span class="number">21760</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16780616</span>     <span class="number">60 8762412</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">97 12603</span> <span class="number">24496</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16780708</span>     <span class="number">60 8762436</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">90 14724</span> <span class="number">27729</span>  <span class="number">9</span>  <span class="number">4</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16779376</span>     <span class="number">60 8762472</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">116 12702</span> <span class="number">25101</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16775968</span>     <span class="number">60 8765976</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">133 16290</span> <span class="number">29873 19 10</span> <span class="number">71</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16783224</span>     <span class="number">60 8765996</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">89 13359</span> <span class="number">25299</span>  <span class="number">4</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16782604</span>     <span class="number">60 8766016</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">73 10976</span> <span class="number">22399</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">16775272</span>     <span class="number">60 8766032</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">122 13109</span> <span class="number">26159</span>  <span class="number">4</span>  <span class="number">2</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>buff 和 cache 就是我们前面看到的 Buffers 和 Cache，单位是 KB</li><li>bi 和 bo 则分别表示块设备读取和写入的大小，单位为 块/秒。因为 Linux 中块的大小是 1KB，所以这个单位也就等价于 KB/s</li></ul><p>在另一中端执行 dd 命令通过读取随机设备，生成一个 500MB 大小的文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/urandom <span class="attribute">of</span>=/mnt/disk1/log <span class="attribute">bs</span>=1M <span class="attribute">count</span>=500</span><br></pre></td></tr></table></figure><p>继续观察 buff 和 cache 的变化如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu--<span class="language-yaml"><span class="meta">---</span></span></span><br><span class="line"><span class="language-yaml"> <span class="string">r</span>  <span class="string">b</span>   <span class="string">swpd</span>   <span class="string">free</span>   <span class="string">buff</span>  <span class="string">cache</span>   <span class="string">si</span>   <span class="string">so</span>    <span class="string">bi</span>    <span class="string">bo</span>   <span class="string">in</span>   <span class="string">cs</span> <span class="string">us</span> <span class="string">sy</span> <span class="string">id</span> <span class="string">wa</span> <span class="string">st</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">6</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16808024</span>     <span class="number">60</span> <span class="number">8706284</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">135</span> <span class="number">17194</span> <span class="number">30511</span> <span class="number">12</span>  <span class="number">5</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">2</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16812680</span>     <span class="number">60</span> <span class="number">8706316</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">108</span> <span class="number">14214</span> <span class="number">27386</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">0</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16822344</span>     <span class="number">60</span> <span class="number">8706268</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">82</span> <span class="number">12608</span> <span class="number">25281</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">0</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16828356</span>     <span class="number">60</span> <span class="number">8706284</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">65</span> <span class="number">16971</span> <span class="number">31578</span>  <span class="number">6</span>  <span class="number">5</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"><span class="string">...</span></span></span><br><span class="line"><span class="number"> 1 </span><span class="number"> 2 </span>1218088<span class="number"> 16438876 </span>   <span class="number"> 60 </span>9110220   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>264629<span class="number"> 19007 </span>27977 <span class="number"> 5 </span>20<span class="number"> 73 </span><span class="number"> 1 </span> 0</span><br><span class="line"><span class="number"> 8 </span><span class="number"> 1 </span>1218088<span class="number"> 16324916 </span>   <span class="number"> 60 </span>9227456   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>22966<span class="number"> 20049 </span>31235<span class="number"> 13 </span>21<span class="number"> 61 </span><span class="number"> 5 </span> 0</span><br><span class="line"><span class="number"> 2 </span><span class="number"> 0 </span>1218088<span class="number"> 16329904 </span>   <span class="number"> 60 </span>9227244   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 327 </span>11770<span class="number"> 24005 </span><span class="number"> 4 </span><span class="number"> 3 </span>87 <span class="number"> 7 </span> 0</span><br><span class="line"><span class="number"> 0 </span><span class="number"> 0 </span>1218088<span class="number"> 16329340 </span>   <span class="number"> 60 </span>9227248   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>  <span class="number"> 91 </span>11558<span class="number"> 22878 </span><span class="number"> 3 </span><span class="number"> 2 </span>95 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 5 </span><span class="number"> 0 </span>1218088<span class="number"> 16329532 </span>   <span class="number"> 60 </span>9227264   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>  <span class="number"> 88 </span>14350<span class="number"> 28661 </span>10 <span class="number"> 5 </span>85 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 1 </span><span class="number"> 0 </span>1218088<span class="number"> 16325480 </span>   <span class="number"> 60 </span>9227056   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 162 </span>16735<span class="number"> 30309 </span>11 <span class="number"> 8 </span>81 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 2 </span><span class="number"> 1 </span>1218088<span class="number"> 16325424 </span>   <span class="number"> 60 </span>9230360   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>225680<span class="number"> 15589 </span>31332<span class="number"> 15 </span>10<span class="number"> 72 </span><span class="number"> 2 </span> 1</span><br><span class="line"><span class="number"> 1 </span><span class="number"> 0 </span>1218088<span class="number"> 16325160 </span>   <span class="number"> 60 </span>9231060   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 124 </span>14815<span class="number"> 26517 </span>10 <span class="number"> 6 </span>79 <span class="number"> 5 </span> 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>在 dd 命令运行时，Cache 在不停地增长，而 Buffer 基本保持不变</li><li>在 dd 命令结束后，Cache 不再增长，但是块设备写还会持续一段时间，并且，多次 1/0 写的结果加起来，才是 dd 要写的 500M 的数据</li></ul><p>下面的命令对环境要求很高，需要你的系统配置多块磁盘，并且磁盘分区 /dev/sdb1 还要处于未使用状态。<strong>如果你只有一块磁盘，千万不要尝试，否则将会对你的磁盘分区造成损坏</strong>。</p><p>如果你的系统符合标准，就可以继续在第二个终端中，运行下面的命令。清理缓存后，向磁盘分区 /dev/sdb1 写入 2GB 的随机数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先清理缓存</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后运行 <span class="built_in">dd</span> 命令向磁盘分区 /dev/sdb1 写入 2G 数据$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=/dev/sdb1 bs=1M count=2048</span></span><br></pre></td></tr></table></figure><p>然后，再回到终端一，观察内存和 I/O 的变化情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">procs</span> -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> <span class="attribute">r</span> b swpd free buff cache si so bi bo in cs us sy id wa st</span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7584780</span> <span class="number">153592</span> <span class="number">97436</span> <span class="number">0</span> <span class="number">0</span> <span class="number">684</span> <span class="number">0</span> <span class="number">31</span> <span class="number">423</span> <span class="number">1</span> <span class="number">48</span> <span class="number">50</span> <span class="number">2</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7418580</span> <span class="number">315384</span> <span class="number">101668</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">32</span> <span class="number">144</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7253664</span> <span class="number">475844</span> <span class="number">106208</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">20</span> <span class="number">137</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7093352</span> <span class="number">631800</span> <span class="number">110520</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">23</span> <span class="number">223</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6930056</span> <span class="number">790520</span> <span class="number">114980</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12804</span> <span class="number">23</span> <span class="number">168</span> <span class="number">0</span> <span class="number">50</span> <span class="number">42</span> <span class="number">9</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6757204</span> <span class="number">949240</span> <span class="number">119396</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">183804</span> <span class="number">24</span> <span class="number">191</span> <span class="number">0</span> <span class="number">53</span> <span class="number">26</span> <span class="number">21</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6591516</span> <span class="number">1107960</span> <span class="number">123840</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">77316</span> <span class="number">22</span> <span class="number">232</span> <span class="number">0</span> <span class="number">52</span> <span class="number">16</span> <span class="number">33</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>从这里你会看到，虽然同是写数据，写磁盘跟写文件的现象还是不同的。写磁盘时（也就是 bo 大于 0 时），Buffer 和 Cache 都在增长，但显然 Buffer 的增长快得多。</p><h3 id="场景二：磁盘和文件读"><a href="#场景二：磁盘和文件读" class="headerlink" title="场景二：磁盘和文件读"></a>场景二：磁盘和文件读</h3><p>运行文件读的命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件读</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/mnt/disk1/log of=/dev/null</span></span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="number">3</span> &gt; /proc/sys/vm/drop_caches</span><br><span class="line">$ mstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">22631652</span>      <span class="number">0 3037032</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">792</span>   <span class="number">225 15443</span> <span class="number">29060 17</span>  <span class="number">8</span> <span class="number">75</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">22629780</span>      <span class="number">0 3037096</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">48</span>    <span class="number">33 13210</span> <span class="number">25184</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">22474456</span>      <span class="number">0 3192744</span>    <span class="number">0</span>    <span class="number">0 155593</span>   <span class="number">379 11851</span> <span class="number">21896</span>  <span class="number">4</span>  <span class="number">6</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">0 1218088</span> <span class="number">22184464</span>      <span class="number">0 3471364</span>    <span class="number">0</span>    <span class="number">0 282644</span>   <span class="number">181 13324</span> <span class="number">22371</span>  <span class="number">5</span> <span class="number">12</span> <span class="number">83</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">22119672</span>      <span class="number">0 3549248</span>    <span class="number">0</span>    <span class="number">0 73920</span>    <span class="number">82 14720</span> <span class="number">26164</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">84</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">22118224</span>      <span class="number">0 3549468</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">136</span>    <span class="number">29 17030</span> <span class="number">32835 13</span>  <span class="number">9</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">22116736</span>      <span class="number">0 3549488</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">80</span>   <span class="number">327 11854</span> <span class="number">23476</span>  <span class="number">4</span>  <span class="number">2</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>运行磁盘读的命令如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 磁盘读</span></span><br><span class="line">$ dd <span class="attribute">if</span>=/dev/vdc <span class="attribute">of</span>=/dev/null <span class="attribute">bs</span>=1M <span class="attribute">count</span>=1024</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ dvmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">6</span>  <span class="number">0 1218088</span> <span class="number">21827684</span>      <span class="number">0 3716568</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218088</span> <span class="number">21816680</span>      <span class="number">0 3721036</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">117 16130</span> <span class="number">30199 16 11</span> <span class="number">73</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">21819240</span>      <span class="number">0 3720212</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">9</span>   <span class="number">195 14200</span> <span class="number">26901</span>  <span class="number">6</span>  <span class="number">4</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">21818228</span>      <span class="number">0 3720252</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">4</span>   <span class="number">123 11836</span> <span class="number">23517</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">95</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">21802832</span>  <span class="number">14336</span> <span class="number">3720200</span>    <span class="number">0</span>    <span class="number">0 17369</span>   <span class="number">248 10953</span> <span class="number">21760</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">91</span>  <span class="number">4</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21740512</span>  <span class="number">75776</span> <span class="number">3720308</span>    <span class="number">0</span>    <span class="number">0 58416</span>    <span class="number">77 14897</span> <span class="number">27732</span>  <span class="number">4</span>  <span class="number">5</span> <span class="number">79</span> <span class="number">11</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">3</span>  <span class="number">1 1218088</span> <span class="number">21696460</span> <span class="number">133120</span> <span class="number">3720692</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">76 20717</span> <span class="number">40621 14 10</span> <span class="number">66</span>  <span class="number">9</span>  <span class="number">0</span></span><br><span class="line"><span class="number">10</span>  <span class="number">0 1218088</span> <span class="number">21639256</span> <span class="number">190464</span> <span class="number">3720328</span>    <span class="number">0</span>    <span class="number">0 57372</span>   <span class="number">349 18512</span> <span class="number">29321 11</span>  <span class="number">5</span> <span class="number">75</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21600056</span> <span class="number">247808</span> <span class="number">3720308</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">72 17332</span> <span class="number">28977 10</span>  <span class="number">5</span> <span class="number">74</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">1 1218088</span> <span class="number">21539120</span> <span class="number">296960</span> <span class="number">3720340</span>    <span class="number">0</span>    <span class="number">0 49152</span>   <span class="number">688 22618</span> <span class="number">37060 16</span>  <span class="number">8</span> <span class="number">66</span>  <span class="number">9</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">1 1218088</span> <span class="number">21473532</span> <span class="number">354304</span> <span class="number">3720184</span>    <span class="number">0</span>    <span class="number">0 57348</span>   <span class="number">109 18331</span> <span class="number">30615</span>  <span class="number">9</span>  <span class="number">5</span> <span class="number">74</span> <span class="number">11</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">1 1218088</span> <span class="number">21414276</span> <span class="number">407552</span> <span class="number">3723624</span>    <span class="number">0</span>    <span class="number">0 53248</span>   <span class="number">150 16057</span> <span class="number">29868 17</span>  <span class="number">9</span> <span class="number">64</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">1 1218088</span> <span class="number">21356020</span> <span class="number">464896</span> <span class="number">3723924</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">29 14159</span> <span class="number">25301 12</span>  <span class="number">4</span> <span class="number">74</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21302964</span> <span class="number">518144</span> <span class="number">3723736</span>    <span class="number">0</span>    <span class="number">0 53248</span>   <span class="number">147 10678</span> <span class="number">21725</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">84</span> <span class="number">12</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">21278632</span> <span class="number">542720</span> <span class="number">3724092</span>    <span class="number">0</span>    <span class="number">0 24576</span>   <span class="number">428 10163</span> <span class="number">21080</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">91</span>  <span class="number">5</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">21269044</span> <span class="number">542720</span> <span class="number">3724072</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">73 15601</span> <span class="number">29313</span>  <span class="number">7</span>  <span class="number">5</span> <span class="number">88</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">23</span>  <span class="number">0 1218088</span> <span class="number">21272568</span> <span class="number">542720</span> <span class="number">3724488</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">33 20061</span> <span class="number">36123 22 12</span> <span class="number">67</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到，读取文件时（也就是 bi 大于 0 时），Buffer 保持不变，而 Cache 则在不停增长；而读取磁盘时，Cache 保持不变，Buffer 不断增长。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。</p>]]></content>
    
    
    <summary type="html">深入剖析 Linux 内存管理机制，涵盖 malloc、brk、mmap、slab 分配器、OOM 杀手原理，并结合 free、top、vmstat 等命令，详解内存分析与调优实践，助你高效定位系统内存瓶颈。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>系统的Swap机制</title>
    <link href="https://wu3227834.github.io/2025/05/16/2025-05-16-xi-tong-de-swap-ji-zhi/"/>
    <id>https://wu3227834.github.io/2025/05/16/2025-05-16-xi-tong-de-swap-ji-zhi/</id>
    <published>2025-05-16T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.015Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文件页</strong>：代表可回收内存，文件页的大部分可以直接回收，以后有需要时，再从磁盘重新读取；而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放</p><p>脏页一般以两个方式写入磁盘：</p><ul><li>在应用程序中，通过系统调用 fync，把脏页同步到磁盘中</li><li>由内核线程 pdflush 负载这些脏页的刷新</li></ul><p><strong>匿名页</strong>：应用程序动态分配的<strong>堆空间</strong>，使用 swap 机制回收</p><h2 id="Swap-原理"><a href="#Swap-原理" class="headerlink" title="Swap 原理"></a>Swap 原理</h2><p>Swap 简单来说就是把一块磁盘空间或者一个本地文件夹，当成内存来使用。它包括换出和换入两个过程：</p><ul><li><strong>换出</strong>，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存</li><li><strong>换入</strong>，则是把进程再次访问这些内存的时候，把它们从磁盘读到内存中来</li></ul><p>常见的笔记本电脑的休眠和快速开机功能，也基于 Swap。休眠时，把系统的内存存入磁盘，这样等到再次开机时，只要从磁盘中加载内存就可以。这样省去了很多应用程序的初始化过程，加快了开机速度。</p><p>内存回收的时机：</p><p>1、<strong>直接内存回收</strong>：当有新的大块内存分配请求，但是剩余内存不足，这个时候系统就需要回收一部分内存</p><p>2、<strong>内核线程 kswapd0</strong>来定期回收内存，它定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页最低阈值（pages_low）和页最高阈值（pages_high）。剩余内存，则使用 pages_free 表示</p><p><img src="/img/2025-05-16-%E7%B3%BB%E7%BB%9F%E7%9A%84Swap%E6%9C%BA%E5%88%B6/image.png" alt="pages_free"></p><p>kswapd0 定期扫描内存的使用情况，并根据剩余内存落在这三个阈值的空间位置，进行内存的会后操作：</p><ul><li>剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配空间</li><li>剩余内存落在页最小阈值和页最低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止</li><li>剩余内存落在页最低阈值和页最高阈值中间，说明内存有一定压力，但还可以满足新压力请求</li><li>剩余内存大于页内存阈值，说明剩余内存比较多，没有内存压力</li></ul><p><strong>页低阈值</strong>是由内核选项 /proc/sys/vm/min_free_kbytes 设置，其他两个阈值，都是根据页最小阈值计算生成的</p><h2 id="NUMA-和-Swap"><a href="#NUMA-和-Swap" class="headerlink" title="NUMA 和 Swap"></a>NUMA 和 Swap</h2><p>在 NUMA 架构下，多个处理器被划分到不同 Node 上，且每个 Node 都拥有自己的本地内存空间。而同一个 Node 内部的内存空间，实际上又可以在进一步分为不同的内存域（Zone），比如直接内存访问区（DMA）、普通内存区（NORMAL）、伪内存区（MOVABLE）等，如下图所示：</p><p><img src="/img/2025-05-16-%E7%B3%BB%E7%BB%9F%E7%9A%84Swap%E6%9C%BA%E5%88%B6/image2.png" alt="Node 内部的内存空间"></p><p>使用 numactl 命令查看 Node 的分布情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --hardware</span><br><span class="line">available:<span class="number"> 2 </span>nodes (0-1)</span><br><span class="line">node<span class="number"> 0 </span>cpus:<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 20 </span>21<span class="number"> 22 </span>23<span class="number"> 24 </span>25<span class="number"> 26 </span>27<span class="number"> 28 </span>29</span><br><span class="line">node<span class="number"> 0 </span>size:<span class="number"> 130960 </span>MB</span><br><span class="line">node<span class="number"> 0 </span>free:<span class="number"> 7308 </span>MB</span><br><span class="line">node<span class="number"> 1 </span>cpus:<span class="number"> 10 </span>11<span class="number"> 12 </span>13<span class="number"> 14 </span>15<span class="number"> 16 </span>17<span class="number"> 18 </span>19<span class="number"> 30 </span>31<span class="number"> 32 </span>33<span class="number"> 34 </span>35<span class="number"> 36 </span>37<span class="number"> 38 </span>39</span><br><span class="line">node<span class="number"> 1 </span>size:<span class="number"> 131072 </span>MB</span><br><span class="line">node<span class="number"> 1 </span>free:<span class="number"> 17581 </span>MB</span><br><span class="line">node distances:</span><br><span class="line">node  <span class="number"> 0 </span>  1</span><br><span class="line">  0: <span class="number"> 10 </span> 21</span><br><span class="line">  1: <span class="number"> 21 </span> 10</span><br></pre></td></tr></table></figure><p>前面提到的三个内存阈值（页最小阈值、页低阈值和页高阈值），都可以通过内存域在 proc 文件系统中的接口 /proc/zoneinfo 来查看</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat /<span class="keyword">proc</span>/zoneinfo|<span class="title"> head</span> -n 20<span class="title"></span></span><br><span class="line"><span class="title">Node</span> 0,<span class="title"> zone</span> <span class="title">     DMA</span></span><br><span class="line"><span class="title">  pages</span> free     3957<span class="title"></span></span><br><span class="line"><span class="title">        min</span>      7<span class="title"></span></span><br><span class="line"><span class="title">        low</span>      8<span class="title"></span></span><br><span class="line"><span class="title">        high</span>     10<span class="title"></span></span><br><span class="line"><span class="title">        scanned</span>  0<span class="title"></span></span><br><span class="line"><span class="title">        spanned</span>  4095<span class="title"></span></span><br><span class="line"><span class="title">        present</span>  3992<span class="title"></span></span><br><span class="line"><span class="title">        managed</span>  3971<span class="title"></span></span><br><span class="line"><span class="title">    nr_free_pages</span> 3957<span class="title"></span></span><br><span class="line"><span class="title">    nr_alloc_batch</span> 2<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_anon</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_anon</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_file</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_file</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_unevictable</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mlock</span>     0<span class="title"></span></span><br><span class="line"><span class="title">    nr_anon_pages</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mapped</span>    0<span class="title"></span></span><br><span class="line"><span class="title">    nr_file_pages</span> 0</span><br></pre></td></tr></table></figure><p>主要指标包括：</p><ul><li>pages 处的 min、low、high，就是上面提到的三个内存阈值，而 free 是<strong>剩余内存页数</strong>，它跟后边的 nr_free_pages 相同</li><li>nr_zone_active_anon 和 nr_zone_inactive_anon，分别代表<strong>活跃匿名页</strong>和<strong>不活跃匿名页</strong>的数量</li><li>nr_zone_active_file 和 nr_zone_inactive_file，分别代表<strong>活跃文件页</strong>和<strong>不活跃文件页</strong>的数量</li></ul><p>某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存种回收内存。具体选哪种模式，你可以通过 /proc/sys/vm/zone_reclaim_mode 来调整。它支持以下几个选项：</p><ul><li>默认的是 0，也就是刚刚提到的模式，表示既可以从其他 Node 寻找空闲内存，也可以从本地内存中回收</li><li>1、2、4 都表示只回收本地内存，2 表示可以回写脏数据来回收内存，4 表示可以用 Swap 方式回收内存</li></ul><h2 id="swapness"><a href="#swapness" class="headerlink" title="swapness"></a>swapness</h2><p>内存回收包括文件页和匿名页：</p><ul><li>对文件页的回收，是直接回收缓存，或者把脏页写回磁盘后再回收</li><li>对匿名页的回收，是通过 Swap 机制，把它们写入磁盘后再释放内存</li></ul><p>Linux 提供了一个 /proc/sys/vm/swapiness 选项，用来调整使用 Swap 的积极程度；swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p><h2 id="系统-Swap-升高的原因"><a href="#系统-Swap-升高的原因" class="headerlink" title="系统 Swap 升高的原因"></a>系统 Swap 升高的原因</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>Linux 本身支持两种类型的 Swap，即 Swap 分区和 Swap 文件，以 Swap 文件为例子，例如如下命令开启 Swap 文件</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 创建swap文件</span></span><br><span class="line"><span class="title">fallocate</span> -l 500M /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 修改权限，仅root用户可读写</span></span><br><span class="line"><span class="title">chmod</span> <span class="number">600</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 配置swap文件</span></span><br><span class="line"><span class="title">mkswap</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 开启swap</span></span><br><span class="line"><span class="title">swapon</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br></pre></td></tr></table></figure><p>执行 free 看到 swap 添加成功</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      <span class="number"> 16092196 </span>    <span class="number"> 562160 </span>    <span class="number"> 613616 </span>    <span class="number"> 295992 </span>  <span class="number"> 14916420 </span>   15135272</span><br><span class="line">Swap:       <span class="number"> 511996 </span>         <span class="number"> 0 </span>     511996</span><br></pre></td></tr></table></figure><p>执行 dd 命令，模拟大文件的读取</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/vdb1 <span class="attribute">of</span>=/dev/null <span class="attribute">bs</span>=1G <span class="attribute">count</span>=400</span><br></pre></td></tr></table></figure><p>执行 sar 查看内存和 swap 指标</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ sar -rS 3</span><br><span class="line">Linux 3.10.107-1-tlinux2_kvm_guest-0051 (VM_194_74_centos)      07/05/20        _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">20:16:14    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:17    <span class="number"> 12016228 </span> <span class="number"> 4075968 </span>    25.33  <span class="number"> 1944876 </span>  <span class="number"> 394804 </span> <span class="number"> 3089884 </span>    18.61  <span class="number"> 2364636 </span> <span class="number"> 1364468 </span>       88</span><br><span class="line"></span><br><span class="line">20:16:14    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:17      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line"></span><br><span class="line">20:16:17    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:20    <span class="number"> 11542068 </span> <span class="number"> 4550128 </span>    28.28  <span class="number"> 2405684 </span>  <span class="number"> 394868 </span> <span class="number"> 3089856 </span>    18.61  <span class="number"> 2364984 </span> <span class="number"> 1825212 </span>      120</span><br><span class="line"></span><br><span class="line">20:16:17    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:20      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:16:50    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:53     <span class="number"> 6331744 </span> <span class="number"> 9760452 </span>    60.65  <span class="number"> 7474548 </span>  <span class="number"> 395052 </span> <span class="number"> 3089736 </span>    18.61  <span class="number"> 2364948 </span> <span class="number"> 6894124 </span>       84</span><br><span class="line"></span><br><span class="line">20:16:50    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:53      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:17:44    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:17:47       <span class="number"> 90140 </span><span class="number"> 16002056 </span>    99.44 <span class="number"> 13573540 </span>  <span class="number"> 392440 </span> <span class="number"> 3089728 </span>    18.61  <span class="number"> 2180308 </span><span class="number"> 13149900 </span>      164</span><br><span class="line"></span><br><span class="line">20:17:44    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:17:47      <span class="number"> 486836 </span>   <span class="number"> 25160 </span>     4.91      <span class="number"> 120 </span>     0.48</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:18:44    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:18:47       <span class="number"> 87988 </span><span class="number"> 16004208 </span>    99.45 <span class="number"> 13658536 </span>  <span class="number"> 354504 </span> <span class="number"> 3089760 </span>    18.61  <span class="number"> 2112144 </span><span class="number"> 13218932 </span>      140</span><br><span class="line"></span><br><span class="line">20:18:44    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:18:47      <span class="number"> 403652 </span>  <span class="number"> 108344 </span>    21.16      <span class="number"> 140 </span>     0.13</span><br></pre></td></tr></table></figure><p>可以看到，总的内存使用率（%memused）在不断增长，从开始的 25% 一直涨到了 99%，并且主要内存都被缓冲区（kbbuffers）占用，大致的变化过程为：</p><ul><li>刚开始，剩余内存（kbmemfree）不断减少，而缓冲区（kbbuffers）则不断增大，由此可知，剩余内存不断分配给了缓冲区</li><li>一段时间后，剩余内存已经很小了，而缓存区占用了大部分内存。此时，Swap 的使用开始逐渐增大，缓冲区和剩余内存则只在小范围内波动</li></ul><p>为什么 Swap 会升高呢？（按理来说，应该先回收缓冲区的内存，这属于可回收内存），观察 /proc/zoneinfo 指标如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d grep -A <span class="number">15</span> &#x27;Normal&#x27; /<span class="keyword">proc</span>/zoneinfo<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">Every</span> 2.0s:<span class="title"> grep</span> -A 15<span class="title"> Normal</span> /<span class="keyword">proc</span>/zoneinfo<span class="title">                                                             Sun</span> Jul  5 20:19:39 2020<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">Node</span> 0,<span class="title"> zone</span> <span class="title">  Normal</span></span><br><span class="line"><span class="title">  pages</span> free     5200<span class="title"></span></span><br><span class="line"><span class="title">        min</span>      3268<span class="title"></span></span><br><span class="line"><span class="title">        low</span>      4085<span class="title"></span></span><br><span class="line"><span class="title">        high</span>     4902<span class="title"></span></span><br><span class="line"><span class="title">        scanned</span>  24<span class="title"></span></span><br><span class="line"><span class="title">        spanned</span>  3407872<span class="title"></span></span><br><span class="line"><span class="title">        present</span>  3407872<span class="title"></span></span><br><span class="line"><span class="title">        managed</span>  3276302<span class="title"></span></span><br><span class="line"><span class="title">    nr_free_pages</span> 5200<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_anon</span> 134532<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_anon</span> 246943<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_file</span> 2466171<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_file</span> 280987<span class="title"></span></span><br><span class="line"><span class="title">    nr_unevictable</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mlock</span>     0</span><br></pre></td></tr></table></figure><p>可以看到，剩余内存（pages free）在一个很小范围内不停地波动。当它小于页低阈值（pages low）时，又会突然增大到一个大于页高阈值（pages high）的数值</p><ul><li>当剩余内存小于页低阈值时，系统会回收一些缓存和匿名内存，使剩余内存增大。其中，缓存的回收导致 sar 中的缓冲区减少，而匿名内存的回收导致了 Swap 的使用增大。其中，缓存的回收导致 sar 中的缓冲区减少，而匿名内存的回收导致了 Swap 的使用增大。</li><li>同事由于 dd 还在继续，剩余内存又会重新分配给缓存，导致剩余内存减少，缓冲区增大</li></ul><p>利用 proc 文件系统，可以查看 Swap 换出的虚拟内存大小，它保存在 /proc/pid/status 中 VmSwap</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ for file in /proc/*/status ; do awk &#x27;/VmSwap|Name|^Pid/&#123;printf $2 &quot; &quot; $3&#125;END&#123; print &quot;&quot;&#125;&#x27; $file; done | sort -k<span class="number"> 3 </span>-n -r | head</span><br><span class="line">systemd-journal<span class="number"> 3048 </span>86160 kB</span><br><span class="line">writeback<span class="number"> 50 </span></span><br><span class="line">watchdog/7<span class="number"> 41 </span></span><br><span class="line">watchdog/6<span class="number"> 36 </span></span><br><span class="line">watchdog/5<span class="number"> 31 </span></span><br><span class="line">watchdog/4<span class="number"> 26 </span></span><br><span class="line">watchdog/3<span class="number"> 21 </span></span><br><span class="line">watchdog/2<span class="number"> 16 </span></span><br><span class="line">watchdog/1<span class="number"> 11 </span></span><br><span class="line">watchdog/0<span class="number"> 10 </span></span><br></pre></td></tr></table></figure><p>可以看到，使用 swap 较多的是 systemd-journal</p><p>结束之后，需要关闭 swap</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>一般关闭 swap 并重新打开，可以这么执行（是一种常见的 swap 清理方法）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">swapoff</span> -a &amp;&amp; swapon /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在内存资源紧张时，Linux 会通过 Swap，把不常访问的匿名页换出到磁盘中，下次访问的时候再从磁盘换入到内存中来。你可以设置 /proc/sys/vm/min_free_kbytes，来调整系统定期回收内存的阈值；也可以设置 /proc/sys/vm/swappiness，来调整文件页和匿名页的回收倾向。</p><p>当 Swap 变高时，你可以用 sar、/proc/zoneinfo、/proc/pid/status 等方法，查看系统和进程的内存使用情况，进而找出 Swap 升高的根源和受影响的进程。</p><p>通常，降低 Swap 的使用，可以提高系统的整体性能。有几种常见的降低方法：</p><ul><li>禁用 Swap，现在服务器的内存走足够大，所有除非有必要，一般会<strong>禁用 Swap</strong>，大部分云平台中的虚拟机都默认禁用 Swap</li><li>如果实在需要用到 Swap，可以尝试<strong>降低 swappiness</strong>值，减少内存回收时 Swap 的使用倾向</li><li>响应延迟敏感的应用，如果它们可能在开启 Swap 的服务器中运行，你还可以使用库函数 mlock() 或者 mlockall() <strong>锁定内存</strong>，阻止它们的内存换出</li></ul><p>常见的三种清理缓存的方法：</p><p>1、清理 pagecache</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 1</span></span><br></pre></td></tr></table></figure><p>2、清理 dentries 和 inodes</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">2</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 2</span></span><br></pre></td></tr></table></figure><p>3、清理 pagecache、dentries 和 inodes</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 3</span></span><br></pre></td></tr></table></figure><p>4、使用 sync 命令来清理文件系统内存，还会清理僵尸（zombie）对象和它们占用的内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sync</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 的 Swap 机制通过将磁盘空间用作虚拟内存，缓解物理内存不足的问题。Swap 包括换出（将不常用内存数据存至磁盘，释放内存）和换入（再次访问时从磁盘读回内存）两个过程。内存回收分为文件页和匿名页：文件页可直接回收或写入磁盘后释放，匿名页则通过 Swap 回收。内核线程 kswapd0 根据页最小、最低和最高阈值定期回收内存，当剩余内存低于阈值时触发回收。NUMA 架构下，内存分为不同 Node 和 Zone，回收策略可通过 /proc/sys/vm/zone_reclaim_mode 调整。Swap 使用倾向由 /proc/sys/vm/swappiness 控制，值越大越倾向回收匿名页。Swap 升高可能因缓存占用或匿名页回收，需用 sar、/proc/zoneinfo 等工具分析。优化方法包括禁用 Swap、降低 swappiness、锁定内存，或清理缓存（如 pagecache、dentries）。合理配置 Swap 可提升性能，但需避免过度使用以降低延迟。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：cpu</title>
    <link href="https://wu3227834.github.io/2025/05/15/2025-05-15-linux-tracing-cpu/"/>
    <id>https://wu3227834.github.io/2025/05/15/2025-05-15-linux-tracing-cpu/</id>
    <published>2025-05-15T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="怎么理解“平均负载”"><a href="#怎么理解“平均负载”" class="headerlink" title="怎么理解“平均负载”"></a>怎么理解“平均负载”</h2><p>简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它和 CPU 使用率没有直接关系，因为 CPU 使用率是指单位时间内 CPU 繁忙程度的百分比。</p><blockquote><p>可运行状态：进程正在运行或准备运行。也就是我们常用 ps 命令看到的处于 R 状态的进程<br>不可中断状态：进程正在等待某个事件的完成，例如 I/O 操作、等待锁、等待信号量等。也就是我们常用 ps 命令看到的处于 D 状态的进程</p></blockquote><p>那么，在实际生产环境中，平均负载多高时，需要我们重点关注呢？</p><p>在我看来，当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但是平均负载本身，我们不能直接发现到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</p><ul><li>平均负载高可能是 CPU 密集型进程导致的</li><li>平均负载高不一定代表 CPU 利用率高，还有可能是 I/0 更繁忙了</li><li>当发现负载高的时候，你可看到使用 mpstat、pidstat 等工具，辅助分析负载的来源</li></ul><h2 id="CPU-上下文切换（上）"><a href="#CPU-上下文切换（上）" class="headerlink" title="CPU 上下文切换（上）"></a>CPU 上下文切换（上）</h2><ul><li>CPU 上下文：包括 CPU 寄存器和程序计数器</li><li>CPU 寄存器：是 CPU 内置的容量小、但速度极快的内存</li><li>程序计数器：是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置的寄存器</li></ul><p><img src="/img/2025-05-15-linux_tracing_cpu/image.png" alt="cpu 架构"></p><ul><li>CPU 上下文切换：是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载到新任务的上下文到这些寄存器和程序计数器，然后再跳转到程序计数器指向的新位置，运行新任务</li><li>这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载出来</li></ul><p>根据任务的不同，CPU 的上下文切换可分为进程上下文切换、线程上下文切换和中断上下文切换。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，对应着下图，CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源</li></ul><p><img src="/img/2025-05-15-linux_tracing_cpu/image2.png" alt="运行空间"></p><p>从进程用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，系统调用的过程中会发生<strong>两次 CPU 上下文切换</strong>。CPU 里原本用户态指令的执行位置需要先保存起来，然后更新为内核态的指令位置，最后跳转到内核态运行内核任务；在系统调用结束后，CPU 寄存器需要恢复原本保存的用户态，然后再切换到用户空间，继续执行进程。</p><p><strong>注意：</strong></p><ol><li>系统调用的过程中，不会涉及到虚拟内存等进程态的资源，不会切换进程，系统调用过程和进程上下文切换不一样，整个过程都是同一个进程</li><li>系统调用称为特权模式切换，不是上下文切换</li></ol><p>进程上下文切换和系统调用的区别是，进程的上下文切换比系统调用多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p><img src="/img/2025-05-15-linux_tracing_cpu/image3.png" alt="进程上下文切换"></p><p><strong>保存上下文和恢复上下文的过程需要内核在 CPU 上运行才能完成</strong>（上下文切换过程是 CPU 密集型），每次上下文切换都需要几十纳秒到数微妙的 CPU 时间。</p><p>在进程上下文切换次数过多的情况下，很容易导致 CPU 将大量时间耗费在<strong>寄存器、内核栈以及虚拟内存</strong>等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，从而导致系统平均负载升高。</p><p>Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在<strong>多处理器系统</strong>上，缓存是被多个处理器<strong>共享</strong>的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选在最需要 CPU 的进程，也就是<strong>优先级最高和等待 CPU 时间最长</strong>的进程来运行。</p><p>进程被 CPU 重新调度的时机：</p><ol><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其它进程运行</li><li>进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度</li><li>有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序</li></ol><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程和进程的区别：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p><p>所谓内核中的任务调度，实际上的调度对象是<strong>线程</strong>；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul><p>因此，线程的上下文切换分为两种情况：</p><ul><li>前后两个进程属于不同进程。此时，因为资源部共享，所以切换过程就跟进程上下文切换是一样的</li><li>前后两个线程属于用一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<strong>私有数据、寄存器</strong>等不共享的资源</li></ul><p><strong>注意：</strong>同进程的线程切换要比进程间的切换消耗更少的资源，更加轻量级</p><h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>为了响应硬件事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p><p>中断上下文切换不会涉及进程的用户态，它其实只包括内核态中断服务程序执行所必需的状态，包括 <strong>CPU 寄存器、内核堆栈、硬件中断参数</strong>等</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以<strong>中断上下文切换不会与进程上下文切换同步发生</strong></p><p>大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>中断上下文切换也需要消耗 CPU，切换次数过多也会消耗大量的 CPU，甚至严重降低系统的整体性能</p><h2 id="CPU上下文切换（下）"><a href="#CPU上下文切换（下）" class="headerlink" title="CPU上下文切换（下）"></a>CPU上下文切换（下）</h2><h3 id="查看上下文切换"><a href="#查看上下文切换" class="headerlink" title="查看上下文切换"></a>查看上下文切换</h3><p>1、查看系统的总体情况</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">5</span> <span class="number">5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218196</span> <span class="number">17324820</span>     <span class="number">60 8417344</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">25</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218196</span> <span class="number">17311424</span>     <span class="number">60 8426964</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">900</span>    <span class="number">97 15273</span> <span class="number">28505 11</span>  <span class="number">6</span> <span class="number">83</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218196</span> <span class="number">17399080</span>     <span class="number">60 8343224</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">410</span>   <span class="number">310 15800</span> <span class="number">29604</span>  <span class="number">8</span>  <span class="number">6</span> <span class="number">86</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">0 1218196</span> <span class="number">17385124</span>     <span class="number">60 8350312</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">787</span>   <span class="number">300 13754</span> <span class="number">26351</span>  <span class="number">7</span>  <span class="number">4</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218196</span> <span class="number">17415052</span>     <span class="number">60 8336488</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">276</span>   <span class="number">132 15567</span> <span class="number">29585</span>  <span class="number">8</span>  <span class="number">5</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cs：context switch，每秒上下文切换的次数</li><li>in：interrupt，每秒中断的次数</li><li>r：运行队列的长度（正在运行和等待CPU的进程数）</li><li>b：处于阻塞状态的进程数</li></ul><p>2、查看进程的详细信息</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -w 5</span><br><span class="line">Linux 3.10.0-957.el7.x86_64 (xxx)       05/27/2025      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">07:35:35 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 1 </span>     3.77      0.40  systemd</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 3 </span>     2.58      0.00  ksoftirqd/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 7 </span>     7.34      0.00  migration/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 9 </span>   218.45      0.00  rcu_sched</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 11 </span>     0.40      0.00  watchdog/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 12 </span>     0.40      0.00  watchdog/1</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 13 </span>     3.57      0.00  migration/1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cswch/s：每秒自愿上下文切换的次数</li><li>nvcswch/s：每秒非自愿上下文切换的次数</li></ul><blockquote><p>自愿上下文切换：进程无法获取所需资源导致的上下文切换，比如 I/O，内存等系统资源不足时发生的上下文切换<br>非自愿上下文切换：进程因时间片已到等原因，被系统强制调度发生的上下文切换，比如多个进程竞争 CPU 是发生的上下文切换</p></blockquote><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>sysbench 模拟多线程调度切换</p><p>1、运行 sysbench</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line">$ sysbench <span class="attribute">--threads</span>=10 <span class="attribute">--max-time</span>=300 threads run</span><br></pre></td></tr></table></figure><p>2、运行 vmstat</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">9</span>  <span class="number">0</span>      <span class="number">0 107736672</span>     <span class="number">64 88038080</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>   <span class="number">199</span>    <span class="number">0</span>    <span class="number">1</span>  <span class="number">2</span>  <span class="number">1</span> <span class="number">97</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0</span>      <span class="number">0 107731792</span>     <span class="number">64 88045280</span>    <span class="number">0</span>    <span class="number">0 16384</span>    <span class="number">40 105267</span> <span class="number">1167081 12</span> <span class="number">15</span> <span class="number">72</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">0</span>      <span class="number">0 107733720</span>     <span class="number">64 88038080</span>    <span class="number">0</span>    <span class="number">0</span>  <span class="number">4192</span>    <span class="number">20 100233</span> <span class="number">1237404</span>  <span class="number">6</span> <span class="number">16</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">0</span>      <span class="number">0 107726368</span>     <span class="number">64 88045280</span>    <span class="number">0</span>    <span class="number">0 14464</span>    <span class="number">68 128551</span> <span class="number">1548455</span>  <span class="number">6</span> <span class="number">17</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">10</span>  <span class="number">0</span>      <span class="number">0 107735168</span>     <span class="number">64 88039216</span>    <span class="number">0</span>    <span class="number">0</span>  <span class="number">4096</span>    <span class="number">64 111126</span> <span class="number">1468157</span>  <span class="number">6</span> <span class="number">16</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>指标观察：</p><ul><li>cs 列：上升到 100w</li><li>r 列：就绪队列长度上升到 10</li><li>in 列：终端次数上升到 10w</li><li>us（user）和sy（system）列：使用率加起来接近 100%，sy 为 78%，主要被内核占用</li></ul><p>3、查看进程情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line">$ pidstat -w -u 1</span><br><span class="line">19时34分55秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 561077 </span>   0.00    1.00    0.00    1.00    <span class="number"> 2 </span> sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 562599 </span> 100.00  100.00    0.00  100.00   <span class="number"> 13 </span> sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 566600 </span>   0.00    2.00    0.00    2.00   <span class="number"> 32 </span> pidstat</span><br><span class="line"></span><br><span class="line">19时34分55秒   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 256312 </span>     1.00      0.00  kworker/37:31</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 263655 </span>     1.00      0.00  kworker/33:2</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 299865 </span>     1.00      0.00  kworker/21:2</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 562931 </span>     1.00      2.00  vmstat</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 560904 </span>     1.00      0.00  sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 561077 </span>    78.00      0.00  sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 566600 </span>     1.00    671.00  pidstat</span><br></pre></td></tr></table></figure><p>分析：CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd</p><p><strong>注意：</strong>pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 100 万明显小了太多？</p><table><thead><tr><th>工具</th><th>统计粒度</th><th>上下文切换数据来源</th><th>显示内容</th></tr></thead><tbody><tr><td>pidstat</td><td>按进程/线程级别</td><td>/proc/[pid]/sched 或 /proc/[pid]/status</td><td>显示某些（非全部）PID 的上下文切换次数</td></tr><tr><td>vmstat</td><td>系统全局级别</td><td>内核调度器</td><td>显示全系统每秒上下文切换总数</td></tr></tbody></table><p>4、查看线程情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">$ pidstat -wt 1</span><br><span class="line">19时34分55秒  UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 616348 </span>        -      0.00      0.00  sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616348 </span>     0.00      0.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616349 </span> 67080.00      6.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616350 </span> 63009.00      3.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616351 </span> 68060.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616352 </span> 69808.00      4.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616353 </span> 68806.00      5.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616354 </span> 73688.00      6.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616355 </span> 72296.00      4.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616356 </span> 63978.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616357 </span> 67409.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616358 </span> 67859.00      2.00  |__sysbench</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。上下文切换罪魁祸首，还是过多的 sysbench 线程</p><p>5、查看中断升高的原因</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d cat /<span class="keyword">proc</span>/interrupts<span class="title"></span></span><br><span class="line"><span class="title">           CPU0</span> <span class="title">      CPU1</span> <span class="title">      CPU2</span></span><br><span class="line">...<span class="title"></span></span><br><span class="line"><span class="title"> RES:</span>  117962220   27310354   17986708<span class="title">   Rescheduling</span> interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察发现，变化速度最快的是重调度中断（RES），它代表唤醒空闲状态的 CPU 来调度新的任务运行，这是在多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）</p><p><strong>分析：</strong>过多任务导致了重调度中断的升高，和前面分析结果一致</p><h2 id="每秒上下文切换多少次正常"><a href="#每秒上下文切换多少次正常" class="headerlink" title="每秒上下文切换多少次正常"></a>每秒上下文切换多少次正常</h2><p><strong>上下文切换次数取决于系统本身的CPU性能。</strong>如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级增长时，就很有可能出现了性能问题，这时根据具体上下文切换的类型具体分析：</p><ul><li>资源上下文切换变多了，说明进程在等在资源，可能发生了 I/O 等其他问题</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还序号通过查看 /proc/interrupts 文件来分析具体的中断类型</li></ul>]]></content>
    
    
    <summary type="html">本文深入讲解 Linux 系统性能调优中的 CPU 相关知识，重点解析平均负载的含义及其与 CPU 使用率的关系，探讨 CPU 上下文切换（进程、线程、中断）的机制与影响，并通过 sysbench 案例分析高负载场景下的诊断方法，指导如何使用 vmstat、pidstat 等工具定位性能瓶颈。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何迅速分析出CPU的瓶颈</title>
    <link href="https://wu3227834.github.io/2025/05/15/2025-05-15-ru-he-xun-su-fen-xi-chu-cpu-de-ping-jing/"/>
    <id>https://wu3227834.github.io/2025/05/15/2025-05-15-ru-he-xun-su-fen-xi-chu-cpu-de-ping-jing/</id>
    <published>2025-05-15T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h2><p>性能指标总览</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image.png" alt="性能指标总览"></p><h3 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h3><p>CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/0 CPU、软中断和硬中断等。用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态：</p><ul><li>CPU 使用率（nice），表示 CPU 在<strong>用户态</strong>运行的时间百分比。用户 CPU 使用率高，通常说明有<strong>应用程序</strong>比较繁忙</li><li>系统 CPU 使用率，表示 CPU 在内核状态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明<strong>内核</strong>比较繁忙</li><li>等待 I/O 的 CPU 使用率，通常为 iowait，表示<strong>等待 I/O</strong> 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互比较长</li><li>软中断和硬中断的 CPU 利用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断</li><li>除了上述这些，还有在虚拟化环境中会用到的<strong>窃取 CPU 利用率（steal）和客户 CPU 使用率（guest）</strong>，分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比</li></ul><h3 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h3><p>系统的活跃进程数。反映了系统的整体负载情况，主要包括三个数值，分别表示过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。理想情况下，平均负载等于逻辑 CPU 个数，这个代表每个 CPU 都恰好被充分利用。如果负载大于逻辑 CPU 个数，就表示负载比较重了。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>进程上下文切换分为：自愿上下文切换和非自愿上下文切换</p><p>注意：过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在<strong>寄存器、内核栈以及虚拟内存等数据的保存和恢复上</strong>，缩短进程真正进行的时间，成为性能瓶颈。</p><h3 id="CPU-缓存命中率"><a href="#CPU-缓存命中率" class="headerlink" title="CPU 缓存命中率"></a>CPU 缓存命中率</h3><p>CPU 缓存的速度介于 CPU 和内存之间，缓存的是<strong>热点的内存数据</strong>。</p><p>如下图，根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常在单核中，L3 则在多核中。从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次减少（当然内存还是好得多）。而它们的命中率，衡量的是 <strong>CPU 缓存的复用情况</strong>，命中率越高，则表示性能越好。</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image2.png" alt="CPU 缓存"></p><h2 id="CPU-性能工具"><a href="#CPU-性能工具" class="headerlink" title="CPU 性能工具"></a>CPU 性能工具</h2><p>平均负载案例：使用 uptime 查看平均负载，在平均负载升高时，使用 mpstat 和 pidstat 分别观察每个 CPU 和每个进程 CPU 的使用情况，找到导致平均负载升高的 stress 进程</p><p>上下文切换的案例：先使用 vmstat，查看系统上下文切换次数和中断次数；然后使用 pidstat（-w 参数）观察进程的自愿上下文切换和非自愿上下文切换；最后通过 vmstat（-wt参数）查看线程的上下文切换情况，从而找到了线程上下文切换增多的原因是 sysbench 工具</p><p>进程 CPU 使用率升高的案例：先使用 top 找出系统和进程 CPU 的使用情况，发现了 CPU 使用率很高的进程 php-fpm，再使用 perf top 找出热点函数 sqrt()；如果是 Python 应用，可以使用 profiler 工具 pyflame 对指定进程分析（pyflame -p pid –threads -s 检测时间 -r 取样间隔 -o &lt;file.txt&gt;），再通过 flamegraph.pl 将输出的 txt 文件转换为 *.svg 格式的火焰图（./flamegraph.pl prof.txt &gt; prof.svg）</p><p>不可中断进程和僵尸进程的案例：</p><ul><li>不可中断进程分析过程：先使用 top 查看，发现存在 D 状态（不可中断休眠进程）和 Z 状态（僵尸进程），并且 iowait 较高；使用 dstat 分析磁盘 I/O，发现 app 进程有大量的磁盘读请求；使用 pidstat（-d -p 参数）分析 app 进程的 I/O 操作，发现没有大量的 I/O 操作，再用 pidstat -d 分析系统的 I/O 情况，发现还是 app 进程在进行磁盘读；再使用 strace 跟踪 D 状态进程对应进程号的系统调用，发现没有权限；ps 查看发现对应进程号的进程已经变成僵尸进程；之后，通过 perf record -g 和 perf report 生成报告，查看 app 进程的调用栈，发现 CPU 使用主要是在 sys_read() 函数，定位到是在对磁盘进行直接读（direct_IO）；查看代码发现 open() 系统调用使用了 O_DIRECT 参数</li><li>僵尸进程分析：使用 pstree 命令找出僵尸进程的父进程是 app 进程，然后查看 app.c 文件，发现 wait() 使用位置不当导致不能回收子进程</li></ul><p>软中断的案例：先使用 top 查看系统指标，发现系统 CPU 使用率很低，但是主要是在软中断 si 上，然后查看 /proc/softirqs 查看系统软中断变化情况，发现 NET_RX 变化率很快，再使用 sar 工具查看系统的网络收发情况，发现 eth0 网卡接收到了大量的小包；在通过抓包工具 tcpdump，发现 eth0 接受到了大量的 SYN 包，最终确定了是 SYN FLOOD 攻击</p><h3 id="性能指标找工具"><a href="#性能指标找工具" class="headerlink" title="性能指标找工具"></a>性能指标找工具</h3><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image3.png" alt="性能指标找工具"></p><h3 id="工具找指标"><a href="#工具找指标" class="headerlink" title="工具找指标"></a>工具找指标</h3><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image4.png" alt="工具对应指标"></p><h2 id="如何分析-CPU-的性能瓶颈"><a href="#如何分析-CPU-的性能瓶颈" class="headerlink" title="如何分析 CPU 的性能瓶颈"></a>如何分析 CPU 的性能瓶颈</h2><p>重点：弄清楚性能指标之间的关联性</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image5.png" alt="指标关联性"></p><h2 id="CPU-性能优化的几个思路"><a href="#CPU-性能优化的几个思路" class="headerlink" title="CPU 性能优化的几个思路"></a>CPU 性能优化的几个思路</h2><h3 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h3><p>确定三个问题：</p><ul><li>判断所做的性能优化是否有效？优化后，能提升多少性能，有多少收益？</li><li>如果有多个性能问题同时存在，应该先优先哪一个？</li><li>当有多个优化方法，应该选择哪一种</li></ul><p><strong>怎么评估性能优化结果：</strong></p><p>三步走原则：</p><ol><li>确定优化的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ol><p>第一步，性能的量化指标包括 CPU 使用率、应用的吞吐量，响应时间等等，<strong>不要局限在单一维度的指标上</strong>。例如，以 web 应用为例：</p><ul><li>应用程序的维度，使用<strong>吞吐量和请求延时</strong>来评估</li><li>系统资源的维度，使用<strong>CPU 使用率</strong>来评估</li></ul><p>好的应用程序是性能优化的最终结果和目的，要使用应用程序的指标，来评估性能优化的整体效果；而系统资源的使用情况是影响应用程序的根源，需要用资源的指标，来分析应用性能的瓶颈来源。</p><p>第二三步，对比第一部确定的<strong>量化指标</strong>在优化前后的差距，拿数据说话。例如，使用 ab 工具测试 Web 应用的并发请求数和响应延时，同时使用 vmstat，pidstat 等工具，观察系统和进程的 CPU 使用率，同时获得了应用和系统两个维度的性能指标</p><p><strong>进行性能测试需要注意的是：</strong></p><ul><li>要避免性能测试工具干扰应用程序的性能</li><li>避免外部环境的变化影响性能指标的评估。在优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致</li></ul><p><strong>多个性能问题同时存在，怎么选择？</strong></p><p>遵循<strong>二八原则</strong>，80% 的性能问题都是由于 20% 的代码导致的，<strong>并不是所有的性能问题都值得优化</strong></p><p>分析的步骤：</p><ul><li>挨个分析出所有的性能瓶颈，排除掉有因果关系的性能问题</li><li>在剩下的几个性能问题中，选择能明显提升应用性能的问题进行修复，有两种方法：<ul><li>如果系统资源出现瓶颈，首先优化系统资源使用的问题</li><li>针对不同类型的指标，首先优化导致<strong>性能指标变化幅度最大</strong>的那些瓶颈问题</li></ul></li></ul><p><strong>有多种优化方法时，如何选择？</strong></p><p>性能优化并非没有成本。</p><p>一个很典型的例子网络中的 DPDK（Data Plane Development Kit）。DPDK 是一种优化网络处理速度的方法，它通过绕开内核网络协议栈的方法，提升网络的处理能力。不过它有一个很典型的要求，就是要独占一个 CPU 以及一定数量的内存大页，并且总是以 100% 的 CPU 使用率运行。所以，如果你的 CPU 核数很少，就有点得不偿失了。</p><p>因此，在考虑性能优化方法时，要结合实际情况，考虑多方面的因素，进行权衡在做选择</p><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>常见的几种应用程序方法：</strong></p><ul><li><strong>编译器优化</strong>：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如，gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化</li><li><strong>算法优化</strong>：使用复杂度更低的算法，显著加快处理速度</li><li><strong>异步处理</strong>：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题</li><li><strong>多线程代替多进程</strong>：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本</li><li><strong>善用缓存</strong>：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度</li></ul><p><strong>常见的系统优化方法：</strong></p><ul><li><strong>CPU 绑定</strong>：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题</li><li><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU</li><li><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。可以适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理</li><li><strong>为进程设置资源限制</strong>：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源</li><li><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会将内存划分为多个 node，每个 node 关联到系统的一个处理器。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存</li><li><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把<strong>中断处理过程自动负载均衡到多个 CPU 上</strong></li></ul><p><strong>避免过早优化：</strong></p><p>性能优化最好是<strong>逐步完善，动态进行</strong>，不追求一步到位，而要<strong>首先保证能满足当前的性能要求</strong>。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>要忍住“把 CPU 性能优化到极致”的冲动</strong>，因为 CPU 并不是唯一的性能因素，还会有其他的性能问题，比如内存、网络、I/O 甚至是架构设计的问题。</p><p>如果不做全方位的分析和测试，只是单纯地把某个指标提升到极致，并不一定能带来整体的收益。</p>]]></content>
    
    
    <summary type="html">分析 CPU 性能瓶颈是优化 Linux 系统性能的关键。CPU 使用率反映非空闲时间占比，分为用户态、系统态、I/O 等待、软硬中断等，分别指示应用程序、内核、I/O 交互或中断的繁忙程度。平均负载表示活跃进程数，理想值等于逻辑 CPU 数量，超载提示系统压力。上下文切换包括自愿和非自愿切换，过多切换会消耗 CPU 时间，降低进程运行效率。CPU 缓存命中率衡量热点数据复用，高命中率提升性能。分析工具如 uptime、mpstat、pidstat 监测负载与 CPU 使用，vmstat 观察上下文切换，perf 定位热点函数，strace 跟踪系统调用。优化方法包括编译器优化、算法改进、异步处理、多线程替换多进程、善用缓存等系统层面优化，如 CPU 绑定、独占、优先级调整及中断负载均衡。性能优化需遵循二八原则，优先解决主要瓶颈，避免过早优化，确保量化指标（如吞吐量、响应时间）提升，结合多维度分析以实现整体性能收益。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Python 传参机制与对象传递</title>
    <link href="https://wu3227834.github.io/2025/02/24/2025-02-24-qian-tan-python-chuan-can-ji-zhi-yu-dui-xiang-chuan-di/"/>
    <id>https://wu3227834.github.io/2025/02/24/2025-02-24-qian-tan-python-chuan-can-ji-zhi-yu-dui-xiang-chuan-di/</id>
    <published>2025-02-24T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.015Z</updated>
    
    <content type="html"><![CDATA[<p>Python 的传参机制是其内存管理和函数设计的重要组成部分，尤其在处理可变和不可变对象时，可能会导致意想不到的行为。本报告将详细探讨 Python 的传参方式（按值还是按引用），并深入分析如何理解“传对象”，涵盖对象引用的概念、可变性对传参的影响，以及开发者如何在实践中管理这些行为。</p><h2 id="背景与问题概述"><a href="#背景与问题概述" class="headerlink" title="背景与问题概述"></a>背景与问题概述</h2><p>在编程语言中，传参通常分为按值传递（pass by value）和按引用传递（pass by reference）。按值传递意味着函数接收的是参数的副本，修改不会影响原始变量；按引用传递意味着函数接收的是原始变量的引用，修改会影响原始变量。Python 的传参机制与这些传统概念有所不同，官方文档和社区讨论中常提到“按对象引用传递”（call by object reference）或“按赋值传递”（pass by assignment）。</p><h2 id="Python-传参的本质：按对象引用传递"><a href="#Python-传参的本质：按对象引用传递" class="headerlink" title="Python 传参的本质：按对象引用传递"></a>Python 传参的本质：按对象引用传递</h2><p>根据官方文档和权威资源，Python 的传参方式是按对象引用传递。这意味着当你将参数传递给函数时，函数接收的是指向同一个对象的引用，而不是对象的副本。具体来说：</p><ul><li>函数的参数成为函数局部命名空间中的一个新变量，这个变量绑定到与调用者传递的对象相同的对象。</li><li>这种绑定是通过赋值完成的，因此也被称为按赋值传递。</li></ul><p>为了理解这一点，我们需要回顾 Python 的对象模型：</p><ul><li>Python 中一切都是对象，变量只是指向对象的引用（reference）。 </li><li>当你执行 <code>x = 5</code>，<code>x</code> 是一个名称，绑定到整数对象 5。</li><li>当你调用 <code>func(x)</code>，函数 <code>func</code> 的参数绑定到同一个对象 5。</li></ul><h2 id="可变与不可变对象的影响"><a href="#可变与不可变对象的影响" class="headerlink" title="可变与不可变对象的影响"></a>可变与不可变对象的影响</h2><p>Python 对象的可变性（mutability）对传参行为有显著影响：</p><ol><li><strong>不可变对象</strong>（immutable objects）：如整数（int）、字符串（str）、元组（tuple）。这些对象一旦创建就不能修改。<ul><li>如果函数尝试修改不可变对象的参数（例如重新赋值），实际上是创建了一个新对象，并绑定到参数名称上，但这不会影响调用者的原始变量。</li><li>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_num</span>(<span class="params">num</span>):</span><br><span class="line">    num = <span class="number">10</span>  <span class="comment"># 创建新整数对象 10，绑定到 num</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">modify_num(x)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出 5，原始变量未变</span></span><br></pre></td></tr></table></figure></li><li>在这种情况下，行为类似于按值传递，因为无法修改原始对象。</li></ul></li><li><strong>可变对象</strong>（mutable objects）：如列表（list）、字典（dict）、集合（set）。这些对象可以被修改。<ul><li>如果函数修改可变对象的状态（例如追加列表元素），这些修改会反映到调用者的原始对象上，因为两者引用的是同一个对象。</li><li>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_list</span>(<span class="params">lst</span>):</span><br><span class="line">    lst.append(<span class="number">4</span>)  <span class="comment"># 修改列表，影响原始对象</span></span><br><span class="line"></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">modify_list(y)</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出 [1, 2, 3, 4]，原始列表已改变</span></span><br></pre></td></tr></table></figure></li><li>在这种情况下，行为类似于按引用传递，因为可以修改原始对象。</li></ul></li></ol><p>然而，需要注意的是，如果函数内重新赋值参数（而不是修改对象内容），这不会影响原始变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reassign_list</span>(<span class="params">lst</span>):</span><br><span class="line">    lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]  <span class="comment"># 重新绑定 lst 到新列表，原始对象不变</span></span><br><span class="line"></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">reassign_list(y)</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出 [1, 2, 3]，原始列表未变</span></span><br></pre></td></tr></table></figure><p>这表明，参数的重新赋值只影响函数内的局部命名空间，不会改变调用者的绑定。</p><h2 id="如何理解“传对象”"><a href="#如何理解“传对象”" class="headerlink" title="如何理解“传对象”"></a>如何理解“传对象”</h2><p>“传对象”意味着函数接收的是对象的引用，而不是对象本身的副本。以下是关键点：</p><ul><li>Python 中的变量是对象的引用，传递参数时，函数的参数绑定到与调用者相同的对象。</li><li>函数可以通过这个引用访问对象的内容，并根据对象的可变性决定是否能修改它。</li><li>如果对象是可变的，函数可以修改其状态，影响原始对象；如果对象是不可变的，函数只能创建新对象，原始对象不受影响。</li></ul><p>为了更直观地理解，可以将变量想象为指向对象的标签（label）。传递参数时，函数得到的是同一个标签的副本，但标签指向的对象是共享的：</p><ul><li>对于可变对象，修改对象内容相当于在同一个对象上操作，所有标签都会看到变化。</li><li>对于不可变对象，试图修改会创建新对象，函数内的标签指向新对象，而原始标签仍指向旧对象。</li></ul><h2 id="按值、引用、对象传递对比与总结"><a href="#按值、引用、对象传递对比与总结" class="headerlink" title="按值、引用、对象传递对比与总结"></a>按值、引用、对象传递对比与总结</h2><p>以下表格对比了按值传递、按引用传递与 Python 传参的差异：</p><table><thead><tr><th>机制</th><th>描述</th><th>Python 示例</th><th>影响原始变量</th></tr></thead><tbody><tr><td>按值传递（Pass by Value）</td><td>函数接收参数的副本，修改不影响原变量</td><td>num = 10，函数内赋值新值</td><td>否</td></tr><tr><td>按引用传递（Pass by Reference）</td><td>函数接收变量的引用，修改影响原变量</td><td>C++ 中的指针或引用传递</td><td>是</td></tr><tr><td>Python 按对象引用传递</td><td>函数接收对象的引用，可变对象可修改</td><td>列表追加元素，字典修改键值</td><td>是（可变对象，修改内容）</td></tr></tbody></table><p>Python 的传参机制结合了按值和按引用的特性，具体行为取决于对象的可变性。这种灵活性适合大多数场景，但需要开发者理解对象模型以避免误用。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad_append</span>(<span class="params">new_item, a_list=[]</span>):</span><br><span class="line">    a_list.append(new_item)</span><br><span class="line">    <span class="keyword">return</span> a_list</span><br></pre></td></tr></table></figure><p>执行两次 <code>print bad_append(&#39;one&#39;)</code> 的结果是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad_append</span>(<span class="params">new_item, a_list=<span class="literal">None</span></span>):</span><br><span class="line">    a_list.append(new_item)</span><br><span class="line">    <span class="keyword">return</span> a_list</span><br></pre></td></tr></table></figure><p>执行两次 <code>print bad_append(&#39;one&#39;)</code> 的结果是什么？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://foofish.net/python-function-args.html">Python 函数中，参数是传值，还是传引用？</a></li><li><a href="https://realpython.com/python-pass-by-reference/">Pass by Reference in Python: Background and Best Practices</a></li><li><a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions">8.7. Function definitions</a></li><li><a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">How do I pass a variable by reference?</a></li></ul>]]></content>
    
    
    <summary type="html">Python 的传参机制是按对象引用传递（call by object reference），结合了按值和按引用的特性，行为取决于对象的可变性。在 Python 中，所有变量都是对象的引用，传递参数时，函数接收的是指向同一对象的引用，而非副本。不可变对象（如整数、字符串）无法修改，函数内重新赋值会创建新对象，不影响原始变量，行为类似按值传递。可变对象（如列表、字典）允许修改内容，函数内的更改会反映到原始对象，类似按引用传递。然而，重新赋值参数仅影响函数局部命名空间，不改变调用者的绑定。这种机制源于 Python 的对象模型，变量是对象的标签，传递时共享对象引用。开发者需注意可变对象的默认参数陷阱，如使用列表作为默认参数可能导致意外共享。理解 Python 传参机制有助于避免误用，提高代码可预测性。通过合理管理对象引用和可变性，开发者可以在函数设计中实现高效、清晰的逻辑。</summary>
    
    
    
    
    <category term="Python" scheme="https://wu3227834.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>容器 overlay 文件系统简述</title>
    <link href="https://wu3227834.github.io/2024/08/28/2024-08-28-rong-qi-overlay-wen-jian-xi-tong-jian-shu/"/>
    <id>https://wu3227834.github.io/2024/08/28/2024-08-28-rong-qi-overlay-wen-jian-xi-tong-jian-shu/</id>
    <published>2024-08-28T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.015Z</updated>
    
    <content type="html"><![CDATA[<p>💡 转载自</p><ul><li><a href="https://www.zsythink.net/archives/4345">https://www.zsythink.net/archives/4345</a></li><li><a href="https://blog.csdn.net/qq_24433609/article/details/130430322">https://blog.csdn.net/qq_24433609/article/details/130430322</a></li><li><a href="https://blog.csdn.net/m0_49023005/article/details/121583100">https://blog.csdn.net/m0_49023005/article/details/121583100</a></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>有个问题困惑着我：容器删除 docker rm 后，docker cp 到容器内的文件，在 /var/lib/docker/overlay2 目录中是否还会存在</p><p>答案：容器删除后 docker rm 后，会自动删除 /var/lib/docker/overlay2 中的对应文件</p><p>实验步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run --name test-container -it busybox:latest sh</span><br><span class="line"><span class="comment">## 主机拷贝文件到容器</span></span><br><span class="line">docker <span class="built_in">cp</span> test-file.txt  test-container:/tmp</span><br><span class="line"><span class="comment">## 去  /var/lib/docker/overlay2  查看是否有此文件</span></span><br><span class="line"><span class="built_in">cd</span>  /var/lib/docker/overlay2 </span><br><span class="line">find ./ -name test-file.txt</span><br><span class="line"><span class="comment">## 发现在容器运行时，该文件存在与 diff 和 merged 目录</span></span><br><span class="line"><span class="comment">## 容器内执行 exit 退出容器，容器会处于 exited 状态，或者 docker stop </span></span><br><span class="line"><span class="comment">## 发现在容器停止或 exited 状态，此时该文件会存在于 diff 文件中</span></span><br><span class="line"><span class="comment">## 删除容器后，此文件就不存在了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 因此就好奇这几个目录的意义</span></span><br><span class="line"><span class="comment">## 同时发现 /var/lib/docker/overlay2  中的 hash id 与容器 id 并不对应，因此考虑就和 overlay 文件系统有关了</span></span><br></pre></td></tr></table></figure><p>简单解释，例如下边容器的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## docker inspect 0fcfdcf1b5ff |jq &#x27;.[].GraphDriver&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/3cc96d59abc8c7653b124c39277c4da2830640a1a7b0939175ab3b41b1983303-init/diff:/var/lib/docker/overlay2/27ac3a1da2eea77dd8ecfcbb10dda293196408630099796c77bbf71840163759/diff:/var/lib/docker/overlay2/0ca615083cdc29e27697c00bd1ab6ce548760a3101f83bb6f697cb6c63ffcc55/diff:/var/lib/docker/overlay2/d11260c6a8a656e6c689417a2eabf2a097e65935da20b979b3f143ff5b0e7d92/diff:/var/lib/docker/overlay2/ff38b128d890e22b98851afcd608d4e70980d5e2a67a074e65fc68d40fb11f9b/diff:/var/lib/docker/overlay2/c1764658c479cfb45edac77699a4da0d2e481e6999db23854a40d54369fb132c/diff:/var/lib/docker/overlay2/b853ec37273e73902d6e9d3aa9fcc5aa4215b2ef8d56e7076d5673c699c34820/diff:/var/lib/docker/overlay2/e8d350b0980d01b145a7ce8dcf68f66d66c89d1f8b043a73e1d073896c20cdac/diff:/var/lib/docker/overlay2/2f69b30f1e7f26b4dfcaf483306b66bff6d2a9f301f49f02c0847bddc413caaa/diff:/var/lib/docker/overlay2/fbc7a7f9c03dbcd7fd507b802186a563c10d70718c019138d0f04389b9acf2bb/diff:/var/lib/docker/overlay2/1902c5596c2e232ecd2f74c1485e9742b8aa36cffb17abca756efb5020fba82c/diff:/var/lib/docker/overlay2/fdacc494a2fc86b92a1b6fdcec7074f985e0ff07b94be74baeb86399dd7187e1/diff:/var/lib/docker/overlay2/ad913d5690c729d32aef928345f8f84dc5fe9df3fb8d6b1eaf38ecb541408a82/diff:/var/lib/docker/overlay2/3f9061393985ee37edb071aac649af44bc7d19fa71861517d83000f69ba0a889/diff:/var/lib/docker/overlay2/0160cfc728093c0d737eeee1ce87ee7dbb36c27f41fa8301e6a966dee3205fe7/diff:/var/lib/docker/overlay2/d56448445573eb1d2236fd855c13a322b817ceb8482e9a64a8afa1423fbe859d/diff:/var/lib/docker/overlay2/2c8c22223361f41b06da49379023c8be1812dad70acbd0fff4b98508d813a343/diff:/var/lib/docker/overlay2/eb90ded5e398c49c6127187b68d7cf6a878f686cb4475bfd427ada9521905191/diff:/var/lib/docker/overlay2/aa4b8e69ae8ba46ddf2cbaa1db9bb63dc630471f829360f540a774533249c060/diff:/var/lib/docker/overlay2/acfea1fe0ce15416c5efac6bab4b52a27aec7205f7fa899e568e1d9dda9fc03c/diff:/var/lib/docker/overlay2/f843b96cc41cb5948dd88233fa961ad2433889bb2765c8737cd0408e999bacf9/diff:/var/lib/docker/overlay2/45f0eafde0438ec844886856ed68e07b2eb65fe8133353aa4240489d074e6e74/diff:/var/lib/docker/overlay2/3bbb18f0ad656534f45b20e6c8a3a869f3a4f177c2859e39121244737b5bd4cb/diff:/var/lib/docker/overlay2/7de504f0fd3c6aa359ec06ded02d3153405f1c4f7fac29d1b88e351d166364bc/diff:/var/lib/docker/overlay2/bb25f883772fc8502362a124574b3a741090502eaed6268e869843087f98cbe4/diff:/var/lib/docker/overlay2/b93a3576a6fa85ad54890c6163ad26b5c6fda0f403a8e8768a6c052cfad39c93/diff:/var/lib/docker/overlay2/023afc8e2f044ac2d55a804d577b4b5a9f93ff67c5e041f02dc45636ae66d949/diff:/var/lib/docker/overlay2/15573352d289785a83a1ecaa3b65168e68185125e395478e66ca4d71dc5c8e34/diff:/var/lib/docker/overlay2/5d149bcd3163486f89923e9dbc7d067909fd4c2328b3693ee9b4cd2bacb7b5d3/diff:/var/lib/docker/overlay2/9a6e123d5b2659c82fa6955cfd3e689ec0b43cedf8cce3586d11f5b9de31377d/diff:/var/lib/docker/overlay2/ab95d820e29c009efc444c6a3caff6b0cdb7c56bdd18c3fefeac35fdc2048074/diff:/var/lib/docker/overlay2/1ae1804931b744310f3410ce5dedcc3910839fb9e5b55f0483a6bd4abef51521/diff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/3cc96d59abc8c7653b124c39277c4da2830640a1a7b0939175ab3b41b1983303/merged&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/3cc96d59abc8c7653b124c39277c4da2830640a1a7b0939175ab3b41b1983303/diff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/3cc96d59abc8c7653b124c39277c4da2830640a1a7b0939175ab3b41b1983303/work&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Docker  中，一个很重要的概念就是 GraphDriver，它主要用于管理和维护镜像，包括把镜像从仓库下载下来，到运行时把镜像挂载起来可以被容器访问等，都是 GraphDriver 去完成的。</p><ul><li>“Name”: “overlay2”：docker存储驱动是overlay2</li><li>LowerDir：包含容器内所有层的文件系统，最后一层除外<ul><li>基础镜像，可以看到有很多 init，这是对应 From 的基础镜像（所有只读层）</li></ul></li><li>UpperDir：容器最上层的文件系统。这也是反映任何运行时修改的地方<ul><li>容器读写层</li></ul></li><li>MergedDir：文件系统所有层的组合视图<ul><li>联合挂载层 ：将 基础层和容器读写层  挂载在一起 ，展示一个统一的视图</li></ul></li><li>WorkDir：用于管理文件系统的内部工作目录</li></ul><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Untitled.png" alt="GraphDriver 示意图"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>通过上述实验，我们已经对 overlay2 有了一定认识了，现在，我们来看看 overlay2 是怎样和 docker 中的镜像层以及容器层结合在一起的。</p><p>当我们通过 docker pull 命令拉去第一个镜像时，可以看到镜像每一层被拉取的过程，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## docker pull 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1</span><br><span class="line">20240712_68ba1e1: Pulling from hippo/runtime/x86/faiss_benchmark</span><br><span class="line">648c0ccfae96: Pull complete</span><br><span class="line">d77e7370c4fa: Pull complete</span><br><span class="line">00701f0aa522: Pull complete</span><br><span class="line">d4516580db57: Pull complete</span><br><span class="line">fca65a19a3bf: Pull complete</span><br><span class="line">Digest: sha256:e9b215174cd7a01eafd1913d2bd1c59aafd797649de906dea53eda3582dfdc6b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1</span><br></pre></td></tr></table></figure><p>如上所见，此处拉取的 <code>faiss_benchmark:20240712_68ba1e1</code> 镜像一共有 5 层，每一层拉取完毕后，都会显示 Pull complete（Already exists 则表示本地目录已经有该层的文件）；每一层都有一个 ID 号，比如上列中的 648c0ccfae96 就是层的哈希值前 12 位。</p><p>下载镜像后，我们可以通过 docker inspect 命令查看镜像的详细信息，在镜像的详细信息中找到 RootFS 段，可以查看当前镜像包含的层，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## docker inspect 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1 | jq <span class="string">&#x27;.[].RootFS&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Layers&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;sha256:4f118a86fef9debde65113068bd2b85f9c5fd65250ac6af2e8281a502cc0a724&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sha256:004114a8d0e34895acdd9c1c370b1184b239d538e3951887d04d1bda771bd441&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sha256:0d5cae34765c1f89a17e5e8e7e6f6f9ddc541151e3efab2487b013faeecac3a6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sha256:fbc981c1f97f7139dd25bc0924272ae4f8f9e07d8c57a1ca4b0c9344266a93ff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sha256:457b93dcc46ca598ce9378e015aae678218bb9a699c4e373250e4021b60c0566&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，faiss_benchmark 镜像的 RootFS 段中一共有 5 层，这 5 个层就是刚才 docker pull 拉取下来的层，RootFS 中的每个层也是用一个哈希值表示，RootFS 中的层的哈希值的前 12 位和刚才 docker pull 命令中的 ID 根本对应不上，这是因为 dcoker pull 中显示的 ID 是层在压缩状态下计算出的哈希值，当层被下载到本地，会自动解压，而 RootFS 中的层哈希值不是在压缩状态下计算的，显然它们两个的值不会一样。如果想要确定它们之间的对应关系，可以通过 <code>diffid-by-digest或者v2metadata-by-diffid/sha256/</code>目录中的文件来查看它们之间的对应关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 distribution]## <span class="built_in">pwd</span></span><br><span class="line">/var/lib/docker/image/overlay2/distribution</span><br><span class="line">[root@pudding-160 distribution]## tree -L 2</span><br><span class="line">.</span><br><span class="line">├── diffid-by-digest</span><br><span class="line">│   └── sha256</span><br><span class="line">└── v2metadata-by-diffid</span><br><span class="line">    └── sha256</span><br><span class="line"></span><br><span class="line">4 directories, 0 files</span><br></pre></td></tr></table></figure><ul><li><code>diffid-by-digest/sha256</code>：<ul><li>这个目录存储了按镜像层的 Digest (SHA256) 计算的映射到 DiffID 的信息。</li><li>Digest 是一个唯一标识符，用于识别镜像层的内容。</li><li>DiffID 是镜像层的一个变化 ID，表示这一层和它下面一层之间的差异。</li><li>这个映射文件可以帮助 Docker 快速查找特定层的变化信息。</li></ul></li><li><code>v2metadata-by-diffid/sha256</code>：<ul><li>这个目录存储了按 DiffID (SHA256) 计算的映射到 v2 元数据的文件。</li><li>这些元数据包括关于镜像层的各种信息，如创建时间、大小、标签等。</li><li>这个目录有助于 Docker 管理和检索与特定层相关的元数据。</li></ul></li></ul><p>例如 289ce7e41289 的对应关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 sha256]## find . -name <span class="string">&quot;648c0ccfae96*&quot;</span></span><br><span class="line">./648c0ccfae963a8b0d71c267d8cb5bb4fc6f26f5e9bd05ab7a6f82db8e95332e</span><br><span class="line">[root@pudding-160 sha256]## <span class="built_in">cat</span> ./648c0ccfae963a8b0d71c267d8cb5bb4fc6f26f5e9bd05ab7a6f82db8e95332e</span><br><span class="line">sha256:4f118a86fef9debde65113068bd2b85f9c5fd65250ac6af2e8281a502cc0a724</span><br><span class="line"></span><br><span class="line">这是我们可以看到 docker pull 中的 648c0ccfae96 和 docker insepct 中的 648c0ccfae96 联系了起来</span><br></pre></td></tr></table></figure><p>在 RootFS 所显示的层中，第一层是最底层，最后一行是最上层，RootFS 显示的层顺序和在镜像中的实际顺序是相反的，在上例中 4f118a86fef9d 是镜像最底层，457b93dcc46 是镜像的最上层。</p><p>既然这些层已经下载到本地，那么这些层对应的文件到底存放到那里呢？我们可以通过如下命令，可以查看这些层的实际存放位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 sha256]## docker inspect 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1 -f <span class="string">&#x27;&#123;&#123;.GraphDriver.Data&#125;&#125;&#x27;</span> | awk -v RS=<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print&#125;&#x27;</span> | <span class="built_in">nl</span> | <span class="built_in">sort</span> -nr | <span class="built_in">cut</span> -f2 | awk -v RS=<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print&#125;&#x27;</span> | grep diff</span><br><span class="line">/var/lib/docker/overlay2/43722a4a12628179c70d588fcc7f64b86aa92cbd30c8599035d0433059423dcf/diff</span><br><span class="line">/var/lib/docker/overlay2/0fed41f6f307ef92b1b1d475108575f0130d224eb008dfa3ff4383c8fa506de6/diff</span><br><span class="line">/var/lib/docker/overlay2/cd5c2d405030b7ed966d1b78c3b038c1c6b313b8be7d0033835bf9ae20c34c37/diff</span><br><span class="line">/var/lib/docker/overlay2/784dc7dce7d8625dc10a4fa065f2a1f27ff65e19def543c9f491f32575ec09dd/diff</span><br><span class="line">/var/lib/docker/overlay2/0fee07bf5795a78e666b18059a4f64eb84d184d07eb6a5d1118ed487338e9edf/diff</span><br></pre></td></tr></table></figure><p>如上所示，这些层实际存放在 <code>/var/lib/docker/overlay2/层哈希值/diff</code>目录中，很明显，上述命令查询出的路径中的层哈希值和之前<code>docker pull</code>或者<code>RootFS</code>中显示的哈希值都不一样，上述路径中的哈希值是根据一定的规律，层层递进计算出来的，如果对这些哈希值之间的关系和计算方法感兴趣，可以去搜索“docker layerID diffID chainID cacheID”这些关键字，这并不是此处要关注的重点，所以不用纠结这些细节，我们只要知道，这些查出来路径就是镜像层实际的存放路径即可。</p><p>由于上述命令已经完成了排序，所以我们看到的层的顺序就是对应层在镜像中的位置，也就是说，上例中查询出来的 43722a4a12628 是最上层，对应 RootFS 中的 457b93dcc46 ，上例中的 0fee07bf5795a7 是最下层，对应 RootFS 中的 4f118a86fef9d ，总之，镜像的层对应的文件实际存放在 diff 目录中。</p><p>其实聊了半天，无非都是在说镜像的层而已，现在咱们基于镜像，创建一个容器，看看容器层是怎么和镜像层结合的。</p><p>此处基于 faiss_benchmark 镜像创建一个 faiss-demo1 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name faiss-demo1 -dit 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1 bash</span><br></pre></td></tr></table></figure><p>使用 docker inspect 命令查看容器的详细信息，在详细信息的 GraphDriver 段可以看到容器的层信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## docker inspect faiss-demo1 | jq <span class="string">&#x27;.[].GraphDriver&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4-init/diff:/var/lib/docker/overlay2/0fee07bf5795a78e666b18059a4f64eb84d184d07eb6a5d1118ed487338e9edf/diff:/var/lib/docker/overlay2/43722a4a12628179c70d588fcc7f64b86aa92cbd30c8599035d0433059423dcf/diff:/var/lib/docker/overlay2/0fed41f6f307ef92b1b1d475108575f0130d224eb008dfa3ff4383c8fa506de6/diff:/var/lib/docker/overlay2/cd5c2d405030b7ed966d1b78c3b038c1c6b313b8be7d0033835bf9ae20c34c37/diff:/var/lib/docker/overlay2/784dc7dce7d8625dc10a4fa065f2a1f27ff65e19def543c9f491f32575ec09dd/diff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/merged&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/diff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/work&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察上列的返回信息，你会发现，faiss-demo1 容器其实就是使用了 overlay2 文件系统，将 faiss_benchmark 镜像各个层的 diff 目录作为 LowerDir 只读层（在这个基础上添加了一层 init 只读层，之后再聊它），将容器的 diff 目录（c156d03c1532 文件夹中的 diff 目录）作为 UpperDir 可读写层，叠加后呈现在了 MergedDir 层（MergedDir 是 c156d03c1532 文件夹中的 merged 目录），而我们在容器中看到的、操作的文件，其实就是 MergedDir 中的内容。</p><p>我们从宿主机的挂载信息中，也可以侧面验证这一点，在容器启动的情况下，执行如下命令，查看对应的 overlay2挂载点信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## mount | grep overlay | grep c156d03c1532</span><br><span class="line">overlay on /var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/merged <span class="built_in">type</span> overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/62APW7R2QAZIKL2JBXGDL2SZFX:/var/lib/docker/overlay2/l/VHFAUXFFYMW7NZ5S3SKLFYMS6R:/var/lib/docker/overlay2/l/FUWWJ73CD3TWQY4ESCXJSQD3Y7:/var/lib/docker/overlay2/l/V2E4YYCC3PEBB4VYHJ3P2E7JMA:/var/lib/docker/overlay2/l/5FRUEQSAL6URPMBZ4V5VHEOJDR:/var/lib/docker/overlay2/l/54MNMNIOUGOPX7SLOTKFTZHE5R,upperdir=/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/diff,workdir=/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/work)</span><br><span class="line"></span><br><span class="line"><span class="comment">#上述挂载点中的有很多/var/lib/docker/overlay2/l/下的路径，查看这些路径，会发现这些路径都是软链接，软连接指向的路径就是那些diff目录</span></span><br><span class="line">[root@pudding-160 ~]## ll /var/lib/docker/overlay2/l/62APW7R2QAZIKL2JBXGDL2SZFX</span><br><span class="line">lrwxrwxrwx 1 root root 77 Jul 29 15:47 /var/lib/docker/overlay2/l/62APW7R2QAZIKL2JBXGDL2SZFX -&gt; ../c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4-init/diff</span><br><span class="line">[root@pudding-160 ~]#</span><br><span class="line">[root@pudding-160 ~]## ll /var/lib/docker/overlay2/l/VHFAUXFFYMW7NZ5S3SKLFYMS6R</span><br><span class="line">lrwxrwxrwx 1 root root 72 Jul 29 15:38 /var/lib/docker/overlay2/l/VHFAUXFFYMW7NZ5S3SKLFYMS6R -&gt; ../0fee07bf5795a78e666b18059a4f64eb84d184d07eb6a5d1118ed487338e9edf/diff</span><br></pre></td></tr></table></figure><p>看到这里，我们应该能够完全理解镜像层、容器层、overlay2 文件系统时怎么融合在一起的了。首先，镜像下载到本地后，各个镜像层的文件存放在对应的 diff 目录中，当我们基于镜像创建容器时，docekr 引擎会为容器创建对应的各个目录，比如 diff、work、merged 目录，然后把镜像层的 diff 目录作为 overlay 中的 lowerDir，将容器的 diff 目录作为 overlay 中 upperDir，将折叠后的结果挂载到了 merge 目录中，最后，docekr 通过 <code>mount namespace</code> 技术，将 merged 目录隔离挂载到容器中。</p><p>现在，再看下图是不是一目了然了</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Untitled1.png" alt="镜像层、容器层之间的关系"></p><p>你可以做一些实验，比如，在容器中创建一些文件，修改一些文件，看看容器的 diff 目录中的变化情况，因为容器的 diff 目录就是读写层，当在容器中进行写操作时，最直接的变化会体现到容器的 diff 目录中，但是，你可能会遇到一些“意外情况”，比如，你在容器中修改了/etc/hosts 文件，发现容器的 diff 目录中并没有对应的 /etc/hosts 文件出现，这是因为有一个特殊的层存在，这个层就是我们刚才看到的”-init层”。当我们创建一个容器时，docker 会为容器进行一些初始化工作，其中就包括生成 hosts 信息、生成 hostname 等，你会发现，即使你在容器中修改了 /etc/host 文件，重启容器后，hosts 文件也会变成原来的样子（通过其他方法可以永久修改），因为 /etc/hosts、/etc/hostname、/etc/resolv.conf 文件中的信息都是 docker 生成的，docker 认为这些信息应该是针对容器当前的状态而存在的，以 hosts 文件为例来说，如果容器没有固定的 IP 地址，那么重启容器后，容器的 IP 可能会发生变化，所以每次重启容器时 docker 都会重新生成 hosts 内容，避免之前生成的 hosts 与当前状态所需要的 hosts 不符，当我们在容器中修改  /etc/hosts 文件时，会发现宿主机中的<code>/var/lib/docker/containers/容器ID/</code>目录下的 hosts 文件内容也发生了同样的变化，其实，docker 就是将宿主机中的<code>/var/lib/docker/containers/容器ID/hosts</code>文件挂载到了容器中的，既然这些状态应该属于容器，那么当我们基于容器创建镜像时，就不应该把容器中的这些信息带入到新创建的镜像中，当我们使用<code>docker commit</code>命令基于容器创建镜像时，会把容器的可读写层变成新创建出的镜像的最上层，所以，如果容器的可读写层中包含 hosts 文件，新镜像中就会带入容器的 hosts 信息，而容器因为 init 层和挂载操作的存在，避免了这些信息进入到容器的可读写层，所以可以保障我们基于容器创建镜像时，得到的镜像是“纯净”的。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h3><p>在讲 overlay2 之前，我们需要先简单了解一下什么是 rootfs：</p><p>rootfs 也叫 <strong>根文件系统</strong>，是 Linux 使用的最基本的文件系统，是内核启动时挂载的第一个文件系统，提供了根目录 <code>/</code> ，根文件系统的各个目录，例如 /bin、/etc、/mnt 等，再将其他分区挂载到 /mnt，/mnt 目录下就有了这个分区的各个目录和文件。</p><p>docker 容器中使用的同样也是 rootfs 这种文件系统，当我们通过 <code>dockr exec</code> 命令进入到容器内部时也可以看到在根目录下有 /bin、/etc、/tmp 等目录，但是在 docker 容器中与 Linux 不同的是，在挂载 rootfs 后，docker deamon 会利用<strong>联合挂载技术</strong>在已有的 rootfs 上再挂载一个读写层，容器在运行过程中文件系统发生的变化只会在读写层进行修改，并通过 whiteout 文件隐藏只读层中的旧版本文件。</p><blockquote><p>whiteout 文件：<br>whiteout 概念存在于联合文件系统（UnionFS）中，代表某一类占位符形态的特殊文件，当用户文件夹的共通部分联合到一个目录时（例如 bin）目录，用户可以删除归属于自己的某些系统文件副本，但归属于系统级的原件仍存留于同一个联合目录，此时系统将产生一份 whiteout 文件，表示该文件在当前用户目录中已删除，但系统目录中仍然保留。</p></blockquote><h3 id="联合挂载文件"><a href="#联合挂载文件" class="headerlink" title="联合挂载文件"></a>联合挂载文件</h3><p>所谓联合挂载文件（Union Mount），就是将原有的文件系统中的不同目录进行<strong>合并（merge）</strong>，最后向我们呈现出一个合并后文件系统。在 overlay2 文件结构中，联合挂载技术通过联合三个不同的目录来实现：lower 目录、upper 目录和 work 目录，这三个目录联合挂载后得到 merged 目录：</p><ul><li>lower 目录：<strong>只读层</strong>，可以有多个，处于最底层目录</li><li>upper 目录：<strong>读写层</strong>，只有一个</li><li>work 目录：工作基础目录，挂载后内容被清空，且在使用过程中其内容不可见</li><li>merged 目录：联合挂载后得到的<strong>视图</strong>，其中本身并没有实体文件，实际文件都在 upper 目录和 lower 目录中。在 merged 目录中对文件进行编辑，实际会修改 upper 目录中文件；而在 upper 目录与 lower 目录中修改文件，都会影响我们在 merged 目录看到的结果。</li></ul><h2 id="overlayFS"><a href="#overlayFS" class="headerlink" title="overlayFS"></a><strong>overlayFS</strong></h2><p>在介绍 docker 中使用的 overlay2 文件结构前，我们先通过对 overlay 文件系统进行简单的操作演示以便更深入理解不同层不同目录之间的关系</p><p>先创建几个文件夹和文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">mkdir</span> A B C worker</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From A&quot;</span> &gt;&gt; A/b.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From A&quot;</span> &gt;&gt; A/c.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From B&quot;</span> &gt;&gt; B/a.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From B&quot;</span> &gt;&gt; B/d.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From C&quot;</span> &gt;&gt; C/b.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From C&quot;</span> &gt;&gt; C/e.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ tree</span><br></pre></td></tr></table></figure><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image.png" alt="目录 tree"></p><p>使用 mount 命令挂载成 overlayFS 文件系统，格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t overlay overlay -o lowerdir=lower1:lower2:lower3,upperdir=upper,workdir=work merged_dir</span><br></pre></td></tr></table></figure><p>在这个例子中，我们用 A 和 B 两个文件夹作为 lower 目录，用 C 作为 upper 目录，worker 作为 work 目录，挂载到 /home/pudding/merged 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> merged</span><br><span class="line"><span class="built_in">sudo</span> mount -t overlay overlay -o lowerdir=A:B,upperdir=C,workdir=worker /home/pudding/merged</span><br></pre></td></tr></table></figure><p>挂载后我们可以查看一下 merged 目录下的文件</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image1.png" alt="merged tree"></p><p>可以看到我们原本的 A B C 三个目录下的文件已经合并，相同的文件名的文件将会选择性的显示，在 merged 中显示里 merged 层更近的文件，upper 层比 lower 层更近，同样 lower 层中，排序靠前的比排序靠后的更近（取决于mount 脚本中 lowerdir=A:B ），在这个例子中就是 A 比 B 更靠近 merged 层</p><p>根据这个规律，我们可以先分析下 merge 层中的文件来源，a.txt 在 A、B 中都有，但是 A 比 B 更靠近 merged 层，所以 merged 层的 a.txt 应该来自 A 目录，b.txt 在 A 和 C 中都有，但是 C 是 upper 层，所以 b.txt 应该来自 C 目录，我们可以核实一下</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image2.png" alt="cat files"></p><p>接下来我们可以看下 upper 层、lower 曾和 merged 层之间的关系，上文已经提到了 upper 层是<strong>读写层</strong>而 lower 层是<strong>只读层</strong>，merged 层是联合挂载后的视图，那如果我们在 merged 层中对文件进行操作会生什么</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image3.png" alt="change merged file"></p><p>我们修改 merge 层的 a.txt 文件，可以看到 merged 层的 a.txt 内容虽然改变，但是 A 目录（只读层）下的 a.txt 内容并没有发生变化，而在 C 目录（读写层）下多了一个 a.txt 文件，内容就是我们修改过的 a.txt 的内容，这就是只读层和读写层的关系，<strong>在 merged 目录对文件进行修改并不会影响到只读层的源文件，只会对读写层进行编辑</strong>。</p><p>如果我们在 merged 层删除文件会发生什么</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image4.png" alt="delete file"></p><p>可以看到在 merged 目录中已经没有 c.txt 文件了，但是 c 目录下却多了一个 c.txt，这个文件就是我们在一开始提到的 <strong>whiteout 文件</strong>，它是主/次设备号都为 0 的字符设备，overlay 文件结构通过使用这种特殊文件来实现文件删除功能，在 merged 目录下使用 ls 命令查看文件时，overlay 会自动过滤掉 upper 目录下的 whiteout 文件以及在 lower 目录下的同名文件，以此实现文件删除效果</p><p>还有一个值得提到的点：overlay 在文件进行操作时用到了<strong>写时复制（Copy on Write）技术</strong>，在没有对文件进行修改时，merged 目录直接使用 lower 目录下的文件，只有当我们在 merged 目录对文件进行修改时，才会把修改的文件复制到 upper 目录</p><h2 id="Docker-overlay2"><a href="#Docker-overlay2" class="headerlink" title="Docker overlay2"></a><strong>Docker overlay2</strong></h2><p>有了对 overlayFS 的基本了解，我们接下来就可以着手分析 Docker 的 overlay2 文件结构了，实际上 Docker 支持的存储驱动有很多种：overlay、overlay2、aufs、vfs 等，在 Ubuntu 较新版本中的 Docker 中普遍采用了 overlay2 这种文件结构，其具有更优越的驱动性能，而 overlay 和 overlay2 的本质区别就是二者在镜像层之间的共享数据方法不同：</p><ul><li>overlay 通过 硬链接 的方式共享数据，只支持，增加磁盘 inode 负担</li><li>overlay2 通过 将多层的 lower 文件联合在一起</li></ul><p>简而言之，overlay2 就是 overlay 的改进版本，我们可以通过 docker info 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> docker info | grep -i <span class="string">&quot;storage driver&quot;</span></span><br><span class="line"> Storage Driver: overlay2</span><br></pre></td></tr></table></figure><p>在 Docker 中，我们日常操作主要涉及两个方面：镜像层与容器层，镜像层就是我们通过 <strong>docker pull</strong> 等命令下载到本机中的镜像，而容器层则是我们通过 <strong>docker exec</strong> 等命令进入的交互式终端，如果你使用过 Docker，你会发现我们只用一个镜像，通过 <strong>docker run</strong> 可以产生很多个容器，这就可以类比 upper 与 lower 两层，镜像作为 lower 层，只读提供文件系统基础，而容器作为 upper 层，我们可以在其中进行任意文件操作，只用同一个镜像就可以申引出不同的容器，这也是一种节约空间资源的方式吧（我的推测</p><p>接下来我们稍微详细地探讨下镜像层与容器层，还有他们的元数据</p><h3 id="镜像层"><a href="#镜像层" class="headerlink" title="镜像层"></a>镜像层</h3><p>我们可以通过 <code>docker inspect [IMAGE ID]</code> 来查看镜像配置</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image5.png" alt="image GraphDriver"></p><p>其中的 GraphDriver 字段中关于 overlay2 文件结构的目录信息</p><p>每一层的对应都在配置信息中体现的非常清楚，但是有一点问题，我们在实际查看文件夹的时候，可以发现镜像层其实并没有 /merged 目录，<strong>我的理解</strong> /merged 目录只在运行容器时存在；这个目录是 Docker 为容器提供的一个视图，它将 lowerdir 和 upperdir 层合并为一个统一的文件系统供容器访问；虽然 merged 目录不存在于镜像层，但 Docker 在 GraphDriver 字段中提供了这些信息，以确保我们能够理解整个 overlay2 文件系统的结构。（不一定对</p><p>可以看到镜像的目录是在 <code>/var/lib/docker/overlay2</code> 下，我们打开一个镜像层看一看其中都有哪些文件</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image6.png" alt="image overlay2"></p><p>其中我们关注一下 diff 目录、link 和 lower 文件</p><h4 id="diff-目录"><a href="#diff-目录" class="headerlink" title="diff 目录"></a>diff 目录</h4><p><strong>在这个目录中存放的是当前镜像层的文件，</strong>刚刚在介绍 overlay2 与 overlay 区别的时候提到了 overlay2 是将多个 lower 层联合到一起，在上面的图中也可以看到，多个 lower 层之间用<code>:</code>分割，在这些层中每一层都有一部分文件，把他们联合到一起就得到了完整的 rootfs</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image7.png" alt="image diff"></p><h4 id="link-文件"><a href="#link-文件" class="headerlink" title="link 文件"></a>link 文件</h4><p>link 文件中的内容是<strong>当前层的软链接名称</strong></p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image8.png" alt="image link"></p><p>这些链接都在 <code>/var/lib/docker/overlay2/l</code> 目录下</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image9.png" alt="image link"></p><p>使用软链接的目的是<strong>为了避免受到 mount 命令参数的长度限制</strong></p><blockquote><p><code>getconf ARG_MAX</code><br>该值决定了一个进程的命令行参数和环境变量的总长度<br>通常在 Linux 系统上为 2MB（2097152 字节）</p></blockquote><h4 id="lower-文件"><a href="#lower-文件" class="headerlink" title="lower 文件"></a>lower 文件</h4><p>lower 文件中的内容是<strong>在此层之下的所有层的软连接名称</strong>，最底层不存在该文件，我们知道 upper 层在 lower 层之上，而 lower 层中越靠后的则越在底层</p><p>我们查看 upper 层对应目录下 lower 文件，可以看到其中有 4 个软链接</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image10.png" alt="image lower"></p><p>恰好 lower 目录中有 4 个镜像层</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image11.png" alt="image GraphDriver lower"></p><p>在 lower 层中，处于最底层的则是应该在 <code>:</code> 最后的目录，即，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/overlay2/784dc7dce7d8625dc10a4fa065f2a1f27ff65e19def543c9f491f32575ec09dd</span><br></pre></td></tr></table></figure><p>查看这一目录下的文件，可以发现它并没有 lower 文件</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image12.png" alt="image lowest"></p><p>这一层对应的软链接即 link 文件内容为 <code>54MNMNIOUGOPX7SLOTKFTZHE5R</code>，我们查看其上一层的 lower 文件内容</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image13.png" alt="image one floor up"></p><p>可以发现确实对应了最底层目录的软链接</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>Docker 的元数据存储目录为 <code>/var/lib/docker/image/overlay2</code> </p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image14.png" alt="image overlay2"></p><p>我们主要看 imagedb 和 layerdb 这两个文件夹</p><h4 id="imagedb"><a href="#imagedb" class="headerlink" title="imagedb"></a>imagedb</h4><p>这个文件夹中存储了镜像相关的元数据，具体位置是在 <code>/imagedb/content/sha256</code>  目录下，这个目录下的文件以 <strong>IMAGE ID</strong> 来命令</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image15.png" alt="image imagedb"></p><p>这个文件的内容就是我们通过 <code>docker inspect [IMAGE ID]</code> 命令查看到的信息，其中我们关注 <code>RootFS</code> 字段</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Untitled2.png" alt="image RootFS"></p><p>可以看出这个字段中有很多 sha256 值，这些哈希值称为 <strong>diff_id</strong>，其从上至下的顺序就表示镜像层最底层到最顶层，也就是说每个 diff_id 对应了一个镜像层，实际上，对应每一个镜像层的还有另外两个 id：<strong>cache_id</strong> 和 <strong>chain_id</strong></p><ul><li><strong>cache_id</strong> 就是在 <code>docker/overlay2</code> 目录下看到的文件夹名称，也是我们通过 <code>docker inspect [IMAGE ID]</code> 命令查看 GraphDriver 字段对应不同的 Dir，其本质是宿主机随机生成的 uuid  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image16.png" alt="image cache_id"></li><li>chain_id 是通过 diff_id 计算出来的，是 Docker 内容寻址机制采用的索引 ID<ul><li>chain_id 在目录 <code>/var/lib/docker/image/overlay2/layerdb/sha256</code> 查看</li><li>如果当前镜像层为最底层，则其 chain_id 与 diff_id 相同</li><li>如果当前镜像层不是最底层，则其 chain_id 计算方式为：<code>sha256(上层chain_id + &quot; &quot; + 本层diff_id)</code></li></ul></li></ul><p>这三个 id 之间存在一一对应的关系，我们可以通过 diff_id 计算得到 chain_id，又可以通过 chain_id 找到对应的 cache_id，下面我们举个栗子说明一下：</p><p>我们刚刚提到了 diff_id 从上至下是最底层到最顶层</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image17.png" alt="image RootFS"></p><p>查看 chain_id</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image18.png" alt="image chain_id"></p><p>可以看到其中确实有一个 chain_id 与 最底层的 diff_id 相同，有了最底层的 chain_id 我们就可以计算出下一层的 chain_id，至于具体如何计算，以及如何通过 chain_id 找到对应的 cache_id，我们需要先了解 layerdb 目录下的内容</p><h4 id="layerdb"><a href="#layerdb" class="headerlink" title="layerdb"></a>layerdb</h4><p>我们现在已知 Docker 的镜像层作为只读层，容器曾作为读写层，而 Docekr 实际上定义了 roLayer 接口与 mountLayer 接口，分别用来描述（只读）镜像层与（读写）容器层，这两个接口的元数据就在目录 <code>/var/lib/docker/image/overlay2/layerdb</code> 下</p><ul><li><strong>roLayer</strong>  rolayer 接口用来描述镜像层，元数据的具体目录在 <code>layerdb/sha256/</code> 下，在此目录下每个文件夹都以每个镜像层的 chain_id 命名  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image19.png" alt="image roLayer">  在文件夹中主要有这 5 个文件，我们简单介绍一下：<ul><li>cache-id：当前 chain_id 对应的 cache_id，用来索引镜像层</li><li>diff：当前 chain_id 对应的 diff_id</li><li>parent：当前 chain_id 对应的镜像层的下一层（父层）镜像 chain_id，最底层不存在该文件</li><li>size：当前 chain_id 对应的镜像层物理大小，单位是字节</li><li>tar-split.json.gz：当前 chain_id 对应镜像层压缩包的 split 文件，可以用来还原镜像层的 tar 包，通过 <code>docker save</code> 命令导出镜像时会用到</li></ul>  我们在上一节中已经判断出了最底层对应的 chain_id，不妨查看一下对应目录下的文件  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image20.png" alt="image lowest chain_id">  可以看到该目录下确实没有 parent 文件，那么我们再查看其下一层，通过 diff_id 的顺序我们可以得知其下一层的 diff_id 为 <code>0d5cae34765c1f89a17e5e8e7e6f6f9ddc541151e3efab2487b013faeecac3a6</code> （上文提到的 inspect 的 RootFS 里 Layers 的 sha256 信息），通过计算 sha256，我们可以得出下一层的 chain_id  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image21.png" alt="image one floor up chain_id">  计算得到最底层的下一层镜像 chain_id 为 <code>696245322de78f67f7f15ab9ade64bf0c35cf1f280a66d763230d9e99a3a6d39</code>  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image22.png" alt="image diff">  确实存在该目录，可以看到：<ul><li>diff 文件内容是 <code>004114a8d0e34895acdd9c1c370b1184b239d538e3951887d04d1bda771bd441</code></li><li>parent 文件内容是 <code>4f118a86fef9debde65113068bd2b85f9c5fd65250ac6af2e8281a502cc0a724</code></li></ul>  可以看到与我们计算用到的两个值也完全相同</li><li><strong>mountLayer</strong>  mountLayer 接口用来描述容器层，元数据的具体目录在 <code>layerdb/mounts/</code> ，在此目录下的文件夹以每个容器的容器 ID（CONTAINER ID）命名  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image23.png" alt="image contain">  在这个文件夹下只有 3 个文件，内容如下：  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image24.png" alt="image mountLayer">  简单介绍一下这3个文件：<ul><li>init-id：对应容器 init 层目录名，源文件在 <code>/var/lib/docker/overlay2</code> 目录下</li><li>mount-id：容器层存储在 <code>/var/lib/docker/overlay2</code> 目录下的名称</li><li>parent：容器的镜像层<strong>最顶层</strong>镜像的 chain_id</li></ul>  我们可以查看 parent 文件中 chain_id 对应目录下的 diff 文件  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image25.png" alt="image diff">  根据 diff_id 从上至下的顺序，我们可以确定这个 diff_id 的确是镜像层的最顶层  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image26.png" alt="image rootfs">  在这里我们引入了一个叫做 <strong>init 层</strong> 的概念，实际上，一个完善的容器分为 3 层：镜像层、init 层和容器层，镜像层提供完整的文件系统基础（rootfs），容器层提供给用户进行交互操作与读写权限，而 init 层则是对应每个容器自己的一些系统配置文件，我们可以看一下 ini 层的内容  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image27.png" alt="image init">  可以看到在 diff 目录中有一些 /etc/hosts、/etc/resolv.conf 等配置文件，需要这一层的原因是当容器启动的时候，会有一些每个容器特定的配置文件（例如 hostname），但由于镜像层是只读层无法进行修改，所以就在镜像层之上单独挂载一层 init 层，用户通过修改每个容器对应的 init 层中的一些配置文件从而达到修改镜像配置文件的目的，而在 init 层中的配置文件也仅对当前容器生效，通过 docker commit 命令创建镜像时也不会提交 init 层。</li></ul><h3 id="容器层"><a href="#容器层" class="headerlink" title="容器层"></a>容器层</h3><p>最后我们来看一下容器层的构造，刚刚我们在 <strong>mountLayer</strong> 一节的讲述中提到了 <strong>mount-id</strong> 这个文件，而这个文件的内容就是容器目录的名称，我们可以通过 <code>docker inspect [CONTAINER ID]</code> 命令也可以判断</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image28.png" alt="image mount-id"></p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image29.png" alt="image graphdriver"></p><p>可以看到其实容器层的目录与镜像层、init层都在同一目录下，其实也就说明了他们在文件结构上都是相同的</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image30.png" alt="image overlay2"></p><p>同样都是这几个文件，但不同的是，我们可以看到在容器层确实有了 merge 这个目录，与我们在文章一开始实现的 overlayFS 是相同的</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image31.png" alt="image merged"></p><p>在 merge 目录下展现了完整的 rootfs 文件系统，这就是 overlay2 通过联合挂载技术，将镜像层、init 层与容器层挂载到一起呈现的结果，这也是我们通过 <code>docker exec</code> 命令进入容器的交互式终端看到的结果，也就是所谓的<strong>视图</strong></p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image32.png" alt="image contain"></p><h4 id="link-amp-lower-文件"><a href="#link-amp-lower-文件" class="headerlink" title="link &amp; lower 文件"></a><strong>link &amp; lower 文件</strong></h4><p>我们在镜像层的时候已经讲过这两个文件了，在容器层中这两个文件与镜像层作用是相同的，不过我们可以看一下 lower 文件的内容</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image33.png" alt="image lower"></p><p>前面讲过，lower 文件的内容是在此层之下的所有层的软链接名称，我们已知此镜像的镜像层共 4 层（lower 层 3 个，upper 层 1 个），但是我们从上图可以看到在容器层之下有 5 个其他层，那多出来的一个就是我们在上一节中提到的 init 层，init 层也有其对应的软链接（看上一节中的图），所以在 <code>docker/overlay2/l</code> 目录下实际上有 6 个软连接（4个镜像层，1个 init 层，1 个容器层）</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image34.png" alt="image link"></p><p>而通过 <code>docker inspect [CONTAINER ID]</code> 命令我们也可以判断出容器层是最顶层，其次是 init 层，最下面是镜像层，也对应了 lower 文件中软链接的顺序</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image35.png" alt="image graphdriver"></p><h4 id="diff-目录-1"><a href="#diff-目录-1" class="headerlink" title="diff 目录"></a><strong>diff 目录</strong></h4><p>这个目录实际上就是 overlayFS 文件结构中的 upper 层（上图中也能看到），所以它的用途就是保存用户在容器中（merged 层）对文件进行的编辑</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image36.png" alt="image diff"></p><p>我们在容器内的 /root/A 目录下创建了一个 a.txt 文件，可以看到在 diff 目录下也体现了出来，我们再尝试在容器中删除原本镜像自带的文件看一看效果</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image37.png" alt="image contain"></p><p>我们在容器中删除 /etc 目录下的 shadow 文件，可以看到在 diff 目录下的 /etc 中多了一个 shadow 文件，而这个文件实际上就是我们在文章一开始讲到的 whiteout 文件，用来隐藏我们已经删掉的 shadow 文件，而实际上镜像层的 shadow 文件并没有被删除</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image38.png" alt="image diff"></p><p>至此，我们对于 Docker 使用的 overlay2 文件结构分析结束。</p>]]></content>
    
    
    <summary type="html">Docker 的 overlay2 存储驱动基于 OverlayFS 文件系统，高效管理容器和镜像层。通过 docker run 创建容器时，Docker 将多个只读镜像层（LowerDir）与可读写的容器层（UpperDir）及初始化层（init）结合，形成 MergedDir 中的统一文件系统视图。通过 docker cp 复制到容器的文件存储在 /var/lib/docker/overlay2 的 UpperDir 中。使用 docker rm 删除容器后，UpperDir 及其相关文件会被移除，确保 overlay2 目录中无残留数据。LowerDir 保存不可变的镜像层，UpperDir 捕获运行时修改，采用写时复制技术提升效率。init 层处理容器特定配置，如 /etc/hosts，这些配置不会在通过 docker commit 创建新镜像时保留。元数据存储在 /var/lib/docker/image/overlay2 中，通过 diff_id、chain_id 和 cache_id 映射层关系。/var/lib/docker/overlay2/l 中的软链接避免命令行长度限制，提升性能。这种结构确保隔离、资源高效利用和干净删除，使 overlay2 成为 Docker 存储的可靠选择。</summary>
    
    
    
    
    <category term="Docker" scheme="https://wu3227834.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>github 国内代理访问下载</title>
    <link href="https://wu3227834.github.io/2024/08/20/2024-08-20-github-guo-nei-dai-li-fang-wen-xia-zai/"/>
    <id>https://wu3227834.github.io/2024/08/20/2024-08-20-github-guo-nei-dai-li-fang-wen-xia-zai/</id>
    <published>2024-08-20T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="演示代理"><a href="#演示代理" class="headerlink" title="演示代理"></a><strong>演示代理</strong></h2><ol><li>前缀</li></ol><blockquote><p><a href="https://github.jobcher.com/gh/">https://github.jobcher.com/gh/</a></p></blockquote><ol><li>下载仓库</li></ol><blockquote><p>git clone <a href="https://github.jobcher.com/gh/">https://github.jobcher.com/gh/</a>&lt;你要下载的GitHub地址&gt;</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.jobcher.com/gh/https://github.com/wu3227834/ann-filtering-benchmark-datasets.git</span><br></pre></td></tr></table></figure><h2 id="另外一种方法"><a href="#另外一种方法" class="headerlink" title="另外一种方法"></a><strong>另外一种方法</strong></h2><p>在你有科学上网的前提下使用代理方式来连接github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line"><span class="comment">#取消设置</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p><a href="http://127.0.0.1:1080/">http://127.0.0.1:1080</a> 是你的代理服务地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;演示代理&quot;&gt;&lt;a href=&quot;#演示代理&quot; class=&quot;headerlink&quot; title=&quot;演示代理&quot;&gt;&lt;/a&gt;&lt;strong&gt;演示代理&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;前缀&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="Git" scheme="https://wu3227834.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>python 并发函数</title>
    <link href="https://wu3227834.github.io/2024/08/20/2024-08-20-python-bing-fa-han-shu/"/>
    <id>https://wu3227834.github.io/2024/08/20/2024-08-20-python-bing-fa-han-shu/</id>
    <published>2024-08-20T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作需要向几十万表写入亿级别数据，想使用 pyhon 的并发执行。才开始使用 ThreadPoolExecutor 发现奇慢无比，大佬说这其实是串行，并发得用  multiprocessing，立帖研究。</p><p>本文以 python3.10 为例，学习一下 python 的并发执行。</p><h2 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h2><p>python 并发执行分三个方面：多线程（threading）、多进程（multiprocessing）、多协程（asynico）</p><p>适当的工具选择主要取决于要执行的任务（CPU 密集型或 IO 密集型）：</p><ul><li>CPU 密集型（CPU-bound）：也叫做计算密集型，是指 I/O 在很短时间内就可以完成，CPU  需要大量的计算和处理，特点是 CPU 占用率相当高；例如：<strong>压缩/解压缩、加密解密、正则表达式搜索、计算</strong>；</li><li>IO 密集型（I/O bound）：是指系统运作大部分的状况是 CPU 在等 I/O（硬盘，内存）的读写操作，CPU 占用率较低，例如：<strong>文件处理，网络爬虫，读写数据库；</strong></li></ul><p>在对比这三种方式之前，让我们先了解两个概念：<strong>并行和并发</strong></p><h3 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h3><p>在 Python 中，”并发”和”并行”是两个相关但不同的概念。</p><blockquote><p>并发 （Concurrency）是指程序的设计方式，允许多个任务在重叠的时间段内执行。虽然在同一时刻只能执行一个任务，但任务之间可以通过切换上下文来实现交替执行。这种交替执行的方式可以提高程序的响应性和效率，尤其是在处理 I/O 密集型任务时。在并发编程中，任务之间通常是独立的，它们可以通过多线程、多进程、协程或异步编程等方式来实现。</p><p>并行（Parallelism）是指多个任务同时执行的能力。在并行编程中，多个任务真正地同时执行，通常需要多个物理或逻辑处理单元（例如多核 CPU）。并行执行任务可以显著提高计算密集型任务的性能，但对于I/O密集型任务则没有明显的优势。</p></blockquote><p>简单来说，<strong>并发是指多个任务在重叠的时间段内交替执行，通过切换上下文实现任务之间的交替执行，以提高程序的响应性和效率；而并行是指多个任务真正地同时执行，通常需要多个物理或逻辑处理单元，用于同时处理不同任务，以提高计算密集型任务的性能。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发执行任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Task <span class="subst">&#123;name&#125;</span> started&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Task <span class="subst">&#123;name&#125;</span> completed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行执行任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parallel_task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Task <span class="subst">&#123;name&#125;</span> started&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Task <span class="subst">&#123;name&#125;</span> completed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发示例</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    tasks = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">    executor.<span class="built_in">map</span>(task, tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行示例</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    tasks = [<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>]</span><br><span class="line">    executor.<span class="built_in">map</span>(parallel_task, tasks)</span><br></pre></td></tr></table></figure><p>在上面的示例中，’task’ 函数模拟了一个耗时 2 秒的任务，并使用线程池实现了并发执行。’parallel_task’ 函数也是一个耗时 2 秒的任务，但使用了进程池实现了并行执行。我们可以运行这段代码，观察任务启动时 python 进程的数目、执行的顺序和时间，以更好地理解并发和并行的区别。</p><p>然后，我们来聊 多进程、多线程、多协程的不同、关系以及怎么选择。</p><h3 id="进程、线程、协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a>进程、线程、协程的对比</h3><ul><li>多进程：<ul><li>优点：可以实现并行，且只有多进程可以实现并行</li><li>缺点：占用资源多，可启动数目最少</li></ul></li><li>多线程：<ul><li>占用资源少，轻量级</li><li>python 的线程是无法并行的（占用多个 cpu），只能进行并发</li><li>切换线程也是有开销的。</li><li>适合 IO 密集型运算、同时运行任务不多（线程可启动数量也是有限制的）</li></ul></li><li>多协程：<ul><li>优点：内存开销最小，可启动数量最多</li><li>缺点：支持的库比较少，代码复杂，例如爬虫不支持，所以想用多协程爬取的话，可以用 aiohttp，不能用 requests</li><li>适用于：IO 密集型、超多任务运行</li></ul></li></ul><h3 id="进程、线程、协程的关系"><a href="#进程、线程、协程的关系" class="headerlink" title="进程、线程、协程的关系"></a>进程、线程、协程的关系</h3><ul><li>一个进程中可以启动很多线程</li><li>一个线程中可以启动很多协程</li></ul><h3 id="python-慢的原因"><a href="#python-慢的原因" class="headerlink" title="python 慢的原因"></a><strong>python 慢的原因</strong></h3><p>两个原因：</p><ul><li>是解释型语言，边解释边执行</li><li>GIL，无法利用多核 CPU</li></ul><p>GIL 是什么，为什么有 GIL？</p><p>全局解释器锁（Global interpreter lock），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。</p><p>python 设计初期为了解决线程并发的问题引入了 GIL，但是现在很难去除，本质是一种锁，它的好处在于简化了 python 对共享资源的管理，但是导致 python 无法实现真正的多线程执行。</p><p>怎样规避 GIL 带来的限制：</p><ul><li>IO 期间线程会释放 GIL，实现 CPU 和 IO 的并发，因此 GIL 的存在对于 IO 密集型计算是有好的，但是对 CPU 密集型则会拖累速度</li><li>利用 multiprocessing，可以利用多核 CPU 的优势</li></ul><h3 id="怎样选择"><a href="#怎样选择" class="headerlink" title="怎样选择"></a><strong>怎样选择</strong></h3><ul><li>IO 密集型运算优先选择多进程</li><li>若满足三点：需要超多任务量、有现成协程库支持 、代码复杂度可以接受，则选择协程，否则选择线程</li></ul><h2 id="threading-—-基于线程的并行"><a href="#threading-—-基于线程的并行" class="headerlink" title="threading — 基于线程的并行"></a><strong>threading — 基于线程的并行</strong></h2><p><a href="https://docs.python.org/zh-cn/3.10/library/threading.html">3.10.13 Documentation » Python 标准库 » 并发执行 » threading — 基于线程的并行</a></p><h2 id="multiprocessing-—-基于进程的并行"><a href="#multiprocessing-—-基于进程的并行" class="headerlink" title="multiprocessing — 基于进程的并行"></a>multiprocessing — 基于进程的并行</h2><p><a href="https://docs.python.org/zh-cn/3.10/library/multiprocessing.html">3.10.13 Documentation » Python 标准库 » 并发执行 » multiprocessing — 基于进程的并行</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.python.org/zh-cn/3.10/library/concurrency.html">3.10.13 Documentation » Python 标准库 » 并发执行</a></li><li><a href="https://blog.csdn.net/weixin_52906070/article/details/132317118">python并发编程这一篇就够了</a></li><li><a href="https://xz.aliyun.com/t/12766?time__1311=GqGxu7G=oYqWqGN4eeqBKIh4Rh=9kFda4D">python并发从0到1</a></li><li><a href="https://www.itheima.com/news/20230710/103420.html">Python中的并发和并行是什么意思?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工作需要向几十万表写入亿级别数据，想使用 pyhon 的并发执行。才开始使用 ThreadPoolExecutor 发现奇慢无比，大佬说这其</summary>
      
    
    
    
    
    <category term="Python" scheme="https://wu3227834.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java命令学习系列—Jmap</title>
    <link href="https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jmap/"/>
    <id>https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jmap/</id>
    <published>2024-06-30T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.014Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jmap 是 JDK 自带的工具软件，主要用于打印指定 Java 进程（或核心文件、远程调试服务器）的共享对象内存映射或堆内存细节。可以使用 jmap 生成 Heap Dump。</p></blockquote><h2 id="什么是堆-dump"><a href="#什么是堆-dump" class="headerlink" title="什么是堆 dump"></a>什么是堆 dump</h2><p>堆 dump 是反应 Java 堆使用情况的内存镜像，其中主要包括<strong>系统信息、虚拟机信息、完整的线程 dump、所有类和对象的状态</strong>等。一般，在内存不足、GC 异常等情况下，我们怀疑有内存泄漏。这个时候我们就可以制作堆 Dump 来查看具体情况，分析原因。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>《Java虚拟机的内存组成以及堆内存介绍》《Java GC工作原理》常见内存错误：</p><blockquote><p>outOfMemoryError：年老代内存不足</p><p>outOfMemoryError:PermGen Space：永久代内存不足</p><p>outOfMemoryError:GC overhead limit exceed：垃圾回收时间占用系统运行时间的 98% 或以上</p></blockquote><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><h3 id="用法摘要"><a href="#用法摘要" class="headerlink" title="用法摘要"></a>用法摘要</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; <span class="keyword">if</span> the <span class="string">&quot;live&quot;</span></span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -permstat            to print permanent generation statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; <span class="keyword">if</span> not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram <span class="keyword">when</span> &lt;pid&gt; does not</span><br><span class="line">                         respond. The <span class="string">&quot;live&quot;</span> suboption is not supported</span><br><span class="line">                         in <span class="built_in">this</span> mode.</span><br><span class="line">    -h | -help           to print <span class="built_in">this</span> help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>option</strong>：选项参数是互斥的(不可同时使用)。想要使用选项参数，直接跟在命令名称后即可。</p><p><strong>pid</strong>：需要打印配置信息的进程 ID。该进程必须是一个 Java 进程。想要获取运行的 Java 进程列表，你可以使用 jps。</p><p><strong>executable</strong>：产生核心 dump 的 Java 可执行文件。</p><p><strong>core</strong>：需要打印配置信息的核心文件。</p><p><strong>remote-hostname-or-IP</strong>：远程调试服务器的（请查看jsadebugd）主机名或 IP 地址。</p><p><strong>server-id</strong>：可选的唯一 id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器。</p><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>**&lt;no option&gt;**：如果使用不带选项参数的 jmap 打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称。这与 Solaris 的 pmap 工具比较相似。</p><ul><li>**dump:[live,]format=b,file=<filename>**：以 hprof 二进制格式转储 Java 堆到指定 filename 的文件中。live 子选项是可选的。如果指定了 live 子选项，堆中只有活动的对象会被转储。想要浏览 heap dump，你可以使用 jhat（Java 堆分析工具）读取生成的文件。</li><li><strong>finalizerinfo</strong>：打印等待终结的对象信息。</li><li><strong>heap</strong>：打印一个堆的摘要信息，包括使用的 GC 算法、堆配置信息和 generation wise heap usage。</li><li>**histo[:live]*<em>：打印堆的柱状图。其中包括每个 Java 类、对象数量、内存大小（单位：字节）、完全限定的类名。打印的虚拟机内部的类名称将会带有一个’</em>’前缀。如果指定了live子选项，则只计算活动的对象。</li><li><strong>permstat</strong>：打印 Java 堆内存的永久保存区域的类加载器的智能统计信息。对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。</li><li><strong>F</strong>：强制模式。如果指定的 pid 没有响应，请使用 jmap -dump 或 jmap -histo 选项。此模式下，不支持 live 子选项。</li><li><strong>h</strong>：打印帮助信息。</li><li><strong>help</strong>：打印帮助信息。</li><li>**J<flag> **：指定传递给运行jmap的JVM的参数。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>查看 java 堆（heap）使用情况</strong>，执行命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 31846</span><br><span class="line"></span><br><span class="line">Attaching to process ID 31846, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s) //GC 方式</span><br><span class="line"></span><br><span class="line">Heap Configuration: //堆内存初始化配置</span><br><span class="line">   MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">   MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">   MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">   NewSize          = 1310720 (1.25MB) //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">   MaxNewSize       = 17592186044415 MB //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">   OldSize          = 5439488 (5.1875MB) //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">   NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">   SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">   PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">   MaxPermSize      = 85983232 (82.0MB) //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">   G1HeapRegionSize = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage: //堆内存使用情况</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space: //Eden区内存分布</span><br><span class="line">   capacity = 33030144 (31.5MB) //Eden区总容量</span><br><span class="line">   used     = 1524040 (1.4534378051757812MB) //Eden区已使用</span><br><span class="line">   free     = 31506104 (30.04656219482422MB) //Eden区剩余容量</span><br><span class="line">   4.614088270399305% used //Eden区使用比率</span><br><span class="line">From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:  //另一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation //当前的Old区内存分布</span><br><span class="line">   capacity = 86507520 (82.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 86507520 (82.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">   free     = 19523568 (18.619125366210938MB)</span><br><span class="line">   11.337498256138392% used</span><br><span class="line"></span><br><span class="line">670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure><p><strong>查看堆内存（histogram）中的对象数量及大小</strong>。执行命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 3331</span><br><span class="line"></span><br><span class="line">num     <span class="comment">#instances         #bytes  class name</span></span><br><span class="line">编号     个数                字节     类名</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:             7        1322080  [I</span><br><span class="line">   2:          5603         722368  &lt;methodKlass&gt;</span><br><span class="line">   3:          5603         641944  &lt;constMethodKlass&gt;</span><br><span class="line">   4:         34022         544352  java.lang.Integer</span><br><span class="line">   5:           371         437208  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:           336         270624  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   7:           371         253816  &lt;instanceKlassKlass&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>jmap -histo:live 这个命令执行，JVM会先触发gc，然后再统计信息。</strong></p></blockquote><p><strong>将内存使用的详细情况输出到文件</strong>，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapDump 6900</span><br></pre></td></tr></table></figure><p>然后用 <code>jhat</code> 命令可以参看 <code>jhat -port 5000 heapDump</code> 在浏览器中访问：<code>http://localhost:5000/</code> 查看详细信息</p><blockquote><p>这个命令执行，JVM 会将整个 heap 的信息 dump 写入到一个文件，heap 如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证 dump 的信息是可靠的，所以会暂停应用。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>如果程序内存不足或者频繁GC，很有可能存在内存泄露情况，这时候就要借助 Java 堆 Dump 查看对象的情况。</li><li>要制作堆 Dump 可以直接使用 jvm 自带的 jmap 命令</li><li>可以先使用 <code>jmap -heap</code> 命令查看堆的使用情况，看一下各个堆空间的占用情况。</li><li>使用 <code>jmap -histo:[live]</code> 查看堆内存中的对象的情况。如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露，就要结合代码，把不用的对象释放掉。</li><li>也可以使用 <code>jmap -dump:format=b,file=&lt;fileName&gt;</code>命令将堆信息保存到一个文件中，再借助jhat命令查看详细内容</li><li>在内存出现泄露、溢出或者其它前提条件下，建议多 dump 几次内存，把内存文件进行编号归档，便于后续内存整理分析。</li></ol><p><strong>Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can’t attach to the process</strong></p><p>在ubuntu中第一次使用 jmap 会报错：<code>Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can&#39;t attach to the process</code>，这是oracla文档中提到的一个bug：<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7050524,%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7050524,解决方式如下：</a></p><ol><li>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope 该方法在下次重启前有效。</li><li>永久有效方法 sudo vi /etc/sysctl.d/10-ptrace.conf 编辑下面这行 <code>kernel.yama.ptrace_scope = 1</code> 修改为 <code>kernel.yama.ptrace_scope = 0</code> 重启系统，使修改生效。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jmap 是 JDK 自带的工具软件，主要用于打印指定 Java 进程（或核心文件、远程调试服务器）的共享对象内存映射或堆内存细节。可以使用 jmap 生成 Heap Dump。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是堆-dum</summary>
      
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java命令学习系列—Jps</title>
    <link href="https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jps/"/>
    <id>https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jps/</id>
    <published>2024-06-30T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.014Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jps 位于 jdk 的 bin 目录下，其作用是显示当前系统的 java 进程情况，及其 id 号。 jps 相当于 Solaris 进程工具 ps。不像 ”pgrep java” 或 ”ps -ef grep java” ，jps 并不使用应用程序名来查找 JVM 实例。因此，它查找所有的 Java 应用程序，包括即使没有使用 java 执行体的那种（例如，定制的启动 器）。另外，jps 仅查找当前用户的 Java 进程，而不是当前系统中的所有进程。</p></blockquote><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>我们知道，很多 JAVA 命令都在 jdk 的 JAVA_HOME/bin/ 目录下面，jps 也不例外，它就在 bin 目录下，它是 java 自带的一个命令。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>jps（Java Virtual Machine Process Status Tool）是 JDK 1.5 提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前 java 进程的一些简单情况。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>jdk 中的 jps 命令可以显示当前运行的 java 进程以及相关参数，它的实现机制如下：</p><p>java 程序在启动以后，会在 <code>java.io.tmpdir</code> 指定的目录下，就是临时文件夹里，生成一个类似于</p><p><code>hsperfdata_User</code> 的文件夹，这个文件夹里（在 Linux 中为 /tmp/hsperfdata_{userName}/），有几个文件，名字就是 java 进程的 pid，因此列出当前运行的 java 进程，只是把这个目录里的文件名列一下而已。 至于系统的参数什么，就可以解析这几个文件获得。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 hsperfdata_root]## ll</span><br><span class="line">total 96</span><br><span class="line">-rw------- 1 root root 32768 Jun 25 21:28 372997</span><br><span class="line">-rw------- 1 root root 32768 Jun 25 21:27 49553</span><br><span class="line">-rw------- 1 root root 32768 Jun 25 21:27 5032</span><br><span class="line">[root@pudding-160 hsperfdata_root]## <span class="built_in">pwd</span></span><br><span class="line">/tmp/hsperfdata_root</span><br><span class="line">[root@pudding-160 hsperfdata_root]## jps</span><br><span class="line">372997 ManagerMaster</span><br><span class="line">49553 RunJar</span><br><span class="line">5032 ManagerAgent</span><br><span class="line">433884 Jps</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>想要学习一个命令，先来看看帮助，使用 <code>jps -help</code> 查看帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## jps -<span class="built_in">help</span></span><br><span class="line">usage: jps [-<span class="built_in">help</span>]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;<span class="built_in">hostid</span>&gt;]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;<span class="built_in">hostid</span>&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>接下来，为了详细介绍这些参数，我们编写几个类，在 main 方法里写一个 while(true) 的循环，查看 java 进程情况。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.JavaCommand;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pudding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>-q 只显示 pid，不显示 class 名称、jar 文件名和传递给 main 方法的参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:/mnt/wsl/demo$ jps -q</span><br><span class="line">4167</span><br><span class="line">4312</span><br></pre></td></tr></table></figure><p><strong>-m 输出传递给 main 方法的参数，在嵌入式 jvm 上可能是null，</strong>在这里，在启动 main 方法的时候，我给 String[] args 传递一个参数：pudding，执行<code>jsp -m</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:/mnt/wsl/demo$ jps -m</span><br><span class="line">7760 Jps -m</span><br><span class="line">7674 JpsDemo pudding</span><br></pre></td></tr></table></figure><p><strong>-l 输出应用程序 main class 的完整 package 名或者应用程序的 jar 文件完整路径名：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:/mnt/wsl/demo$ jps -l</span><br><span class="line">4517 sun.tools.jps.Jps</span><br><span class="line">4167 com.JavaCommand.JpsDemo</span><br></pre></td></tr></table></figure><p><strong>-v 输出传递给 JVM 的参数；</strong>在这里，在启动 main 方法的时候，我给 jvm 传递一个参数：-Dfile.encoding=UTF-8，执行<code>jps -v</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:/mnt/wsl/demo$ jps -v</span><br><span class="line">9317 JpsDemo -Dfile.encoding=UTF-8</span><br><span class="line">9391 Jps -Dapplication.home=/usr/lib/jvm/java-8-openjdk-amd64 -Xms8m</span><br></pre></td></tr></table></figure><p>PS：jps 命令有个地方很不好，似乎只能显示当前用户的 java 进程，要显示其他用户的还是只能用 unix/linux 的 ps 命令。</p><blockquote><p>jps 是我最常用的 java 命令。使用 jps 可以查看当前有哪些 Java 进程处于运行状态。如果我运行了一个 web 应用（使用 tomcat、jboss、jetty 等启动）的时候，我就可以使用 jps 查看启动情况。有的时候我想知道这个应用的日志会输出到哪里，或者启动的时候使用了哪些 javaagent，那么我可以使用 jps -v 查看进程的 jvm 参数情况。</p></blockquote><h2 id="jps-失效处理"><a href="#jps-失效处理" class="headerlink" title="jps 失效处理"></a>jps 失效处理</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>用 <code>ps -ef|grep java</code> 能看到启动的 java 进程，但是用 jps 查看却不存在该进程的 id。待会儿解释过之后就能知道在该情况下，jconsole、jvisualvm 可能无法监控该进程，其他 java 自带工具也可能无法使用。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>jps、jconsole、jvisualvm 等工具的数据来源就是这个文件（/tmp/hsperfdata_${userName}/pid)。所以当该文件不存在或是无法读取时就会出现 jps 无法查看该进程号，jconsole 无法监控等问题</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li><strong>磁盘读写、目录权限问题</strong>：若该用户没有权限写/tmp目录或是磁盘已满，则无法创建 /tmp/hsperfdata_${userName}/pid 文件。或该文件已经生成，但用户没有读权限</li><li><strong>临时文件丢失，被删除或是定期清理</strong>：对于 linux 机器，一般都会存在定时任务对临时文件夹进行清理，导致 /tmp 目录被清空。这也是我第一次碰到该现象的原因。常用的可能定时删除临时目录的工具为 crontab、redhat 的 tmpwatch、ubuntu 的 tmpreaper 等等<blockquote><p>这个导致的现象可能会是这样，用 jconsole 监控进程，发现在某一时段后进程仍然存在，但是却没有监控信息了。</p></blockquote></li><li><strong>java 进程信息文件存储地址被设置，不在 /tmp 目录下</strong>：上面我们在介绍时说默认会在 /tmp/hsperfdata_${userName} 目录保存进程信息，但由于以上 1、2 所述原因，可能导致该文件无法生成或是丢失，所以 java 启动时提供了参数（-Djava.io.tmpdir），可以对这个文件的位置进行设置，而 jps、jconsole 都只会从 /tmp 目录读取，而无法从设置后的目录读物信息，这是我第二次碰到该现象的原因</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jps 位于 jdk 的 bin 目录下，其作用是显示当前系统的 java 进程情况，及其 id 号。 jps 相当于 Solaris 进程工具 ps。不像 ”pgrep java” 或 ”ps -ef grep java” ，jps 并不使用应用</summary>
      
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java命令学习系列—Jstack</title>
    <link href="https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jstack/"/>
    <id>https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jstack/</id>
    <published>2024-06-30T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.014Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jstack 是 java 虚拟机自带的一种堆栈跟踪工具</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>jstack 用于生成 java 虚拟机当前时刻的线程快照。线程快照是当前 java 虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是<strong>定位线程出现长时间停顿的原因</strong>，如<strong>线程间死锁、死循环、请求外部资源导致的长时间</strong>等待等。 线程出现停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果 java 程序崩溃生成 core 文件，jstack 工具可以用来获得 core 文件的 java stac k和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外，jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息, 如果现在运行的 java 程序呈现 hung 的状态，jstack 是非常有用的。</p><blockquote><p>So，<strong>jstack命令主要用来查看Java线程的调用堆栈的，可以用来分析线程问题（如死锁）。</strong></p></blockquote><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a><strong>线程状态</strong></h2><p>想要通过 jstack 命令来分析线程的情况的话，首先要知道线程都有哪些状态，下面这些状态是我们使用 jstack 命令查看线程堆栈信息时可能会看到的<strong>线程的几种状态</strong>：</p><ol><li>NEW，未启动的。不会出现在 Dump 中。</li><li>RUNNABLE，在虚拟机内执行的。</li><li>BLOCKED，受阻塞并等待监视器锁。</li><li>WATING，无限期等待另一个线程执行特定操作。</li><li>TIMED_WATING，有时限的等待另一个线程的特定操作。</li><li>TERMINATED，已退出的。</li></ol><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>在多线程的 JAVA 程序中，实现线程之间的同步，就要说说 Monitor。Monitor 是 Java 中用来实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 class 的锁。每一个对象都有，也仅有一个 monitor。下图，描述了线程和 Monitor 之间的关系，以及线程的状态转换图：</p><p><img src="/img/2024-06-30-Jstack/Untitled.png" alt="monitor"></p><p><strong>进入区（Entrt Set）</strong>：表示线程通过 synchronized 要求获取对象的锁。如果对象未被锁住，则进入拥有者；否则则在进入区等待。一旦对象锁被其他线程释放,立即参与竞争。</p><p><strong>拥有者（The Owner）</strong>：表示某一线程成功竞争到对象锁。</p><p><strong>等待区（Wait Set）</strong>：表示线程通过对象的 wait 方法，释放对象的锁，并在等待区等待被唤醒。</p><p>从图中可以看出，一个 Monitor 在某个时刻，只能被一个线程拥有，该线程就是 <code>“Active Thread”</code>，而其它线程都是 <code>“Waiting Thread”</code>，分别在两个队列 <code>“Entry Set”</code> 和 <code>“Wait Set”</code> 里面等候。在 <code>“Entry Set”</code> 中等待的线程状态是 <code>“Waiting for monitor entry”</code>，而在 <code>“Wait Set”</code> 中等待的线程状态是 <code>“in Object.wait()”</code>。 先看  <code>“Entry Set”</code> 里面的线程。我们称被 synchronized 保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 <code>“Entry Set”</code> 队列。对应的 code 就像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用修饰"><a href="#调用修饰" class="headerlink" title="调用修饰"></a>调用修饰</h2><p>表示线程在方法调用时，额外的重要的操作。线程 Dump 分析的重要信息。修饰上方的方法调用。</p><blockquote><p>locked &lt;地址&gt; 目标：使用 synchronized 申请对象锁成功，监视器的拥有者。<br>waiting to lock &lt;地址&gt; 目标：使用 synchronized 申请对象锁未成功，在迚入区等待。<br>waiting on &lt;地址&gt; 目标：使用 synchronized 申请对象锁成功后，释放锁幵在等待区等待。<br>parking to wait for &lt;地址&gt; 目标</p></blockquote><h3 id="locked"><a href="#locked" class="headerlink" title="locked"></a><strong>locked</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at oracle.jdbc.driver.PhysicalConnection.prepareStatement</span><br><span class="line">- locked &lt;<span class="number">0x00002aab63bf7f58</span>&gt; (a oracle.jdbc.driver.T4CConnection)</span><br><span class="line">at oracle.jdbc.driver.PhysicalConnection.prepareStatement</span><br><span class="line">- locked &lt;<span class="number">0x00002aab63bf7f58</span>&gt; (a oracle.jdbc.driver.T4CConnection)</span><br><span class="line">at com.jiuqi.dna.core.internal.db.datasource.PooledConnection.prepareStatement</span><br></pre></td></tr></table></figure><p>通过 synchronized 关键字，成功获取到了对象的锁,成为监视器的拥有者，在临界区内操作。对象锁是可以线程重入的。</p><h3 id="waiting-to-lock"><a href="#waiting-to-lock" class="headerlink" title="waiting to lock"></a><strong>waiting to lock</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at com.jiuqi.dna.core.impl.CacheHolder.isVisibleIn(CacheHolder.java:<span class="number">165</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0x0000000097ba9aa8</span>&gt; (a CacheHolder)</span><br><span class="line">at com.jiuqi.dna.core.impl.CacheGroup$Index.findHolder</span><br><span class="line">at com.jiuqi.dna.core.impl.ContextImpl.find</span><br><span class="line">at com.jiuqi.dna.bap.basedata.common.util.BaseDataCenter.findInfo</span><br></pre></td></tr></table></figure><p>通过 synchronized 关键字，没有获取到了对象的锁，线程在监视器的进入区等待。在调用栈顶出现，线程状态为 Blocked。</p><h3 id="waiting-on"><a href="#waiting-on" class="headerlink" title="waiting on"></a><strong>waiting on</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;<span class="number">0x00000000da2defb0</span>&gt; (a WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingManager.getWorkToDo</span><br><span class="line">- locked &lt;<span class="number">0x00000000da2defb0</span>&gt; (a WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingThread.run</span><br></pre></td></tr></table></figure><p>通过 synchronized 关键字，成功获取到了对象的锁后，调用了 wait 方法，进入对象的等待区等待。在调用栈顶出现，线程状态为 WAITING 或 TIMED_WATING 。</p><h3 id="parking-to-wait-for"><a href="#parking-to-wait-for" class="headerlink" title="parking to wait for"></a><strong>parking to wait for</strong></h3><p>park 是基本的线程阻塞原语，不通过监视器在对象上阻塞。随 concurrent 包会出现的新的机制，synchronized 体系不同。</p><h2 id="线程动作"><a href="#线程动作" class="headerlink" title="线程动作"></a>线程动作</h2><p>线程状态产生的原因：</p><blockquote><p>runnable：状态一般为RUNNABLE。</p><p>in Object.wait()：等待区等待，状态为 WAITING 或 TIMED_WAITING。</p><p>waiting for monitor entry：进入区等待，状态为 BLOCKED。</p><p>waiting on condition：等待区等待、被 park。</p><p>sleeping：休眠的线程，调用了 Thread.sleep()。</p></blockquote><p><strong>Wait on condition</strong> 该状态出现在线程等待某个条件的发生。具体是什么原因，可以结合 stacktrace 来分析。</p><ul><li>最常见的情况就是线程处于 sleep 状态，等待被唤醒。</li><li>常见的情况还有等待网络 IO：在 java 引入 nio 之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在  NewIO 里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。<ul><li>一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；</li><li>另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。</li></ul></li></ul><p>所以要结合系统的一些性能观察工具来综合分析，比如 netstat 统计单位时间的发送包的数目，如果很明显超过了所在网络带宽的限制；观察 cpu 的利用率，如果系统态的 CPU 时间，相对于用户态的 CPU 时间比例较高；如果程序运行在 Solaris 10 平台上，可以用 dtrace 工具看系统调用的情况，如果观察到  read/write 的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。</p><h2 id="线程-Dump-的分析"><a href="#线程-Dump-的分析" class="headerlink" title="线程 Dump 的分析"></a>线程 Dump 的分析</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>结合代码阅读的推理。需要线程 Dump 和源码的相互推到和印证。</p><p>造成 Bug 的根源往往会在调用栈上直接体现，一定要格外注意线程当前调用之前的所有调用。</p><h3 id="入手点"><a href="#入手点" class="headerlink" title="入手点"></a>入手点</h3><p><strong>进入区等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;d&amp;a-3588&quot;</span> daemon waiting <span class="keyword">for</span> monitor entry [<span class="number">0x000000006e5d5000</span>]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()</span><br><span class="line">- waiting to lock &lt;<span class="number">0x0000000602f38e90</span>&gt; (a java.lang.Object)</span><br><span class="line">at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()</span><br></pre></td></tr></table></figure><p>线程状态 BLOCKED，线程动作 wait on monitor entry，调用修饰 waiting to lock 总是一起出现。表示在代码级别已经存在冲突的调用。必然有问题的代码，需要尽可能减少其发生。</p><p><strong>同步块阻塞</strong></p><p>一个线程锁住某对象,大量其他线程在该对象上等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;blocker&quot;</span> runnable</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$<span class="number">1.</span>run(Blocker.java:<span class="number">23</span>)</span><br><span class="line">- locked &lt;<span class="number">0x00000000eb8eff68</span>&gt; (a java.lang.Object)</span><br><span class="line"><span class="string">&quot;blockee-11&quot;</span> waiting <span class="keyword">for</span> monitor entry</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$<span class="number">2.</span>run(Blocker.java:<span class="number">41</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0x00000000eb8eff68</span>&gt; (a java.lang.Object)</span><br><span class="line"><span class="string">&quot;blockee-86&quot;</span> waiting <span class="keyword">for</span> monitor entry</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$<span class="number">2.</span>run(Blocker.java:<span class="number">41</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0x00000000eb8eff68</span>&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure><p><strong>持续运行的IO</strong> </p><p>IO操作是会以 RUNNABLE 状态达成阻塞。例如：数据库死锁、网络读写。 格外注意对 IO 线程的真实状态的分析。一般来说，被捕捉到 RUNNABLE 的 IO 调用，都是有问题的。</p><p>以下堆栈显示： 线程状态为 RUNNABLE。 调用栈在 SocketInputStream 或 SocketImpl 上，socketRead0 等方法。 调用栈包含了 jdbc 相关的包。很可能发生了数据库死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;d&amp;a-614&quot;</span> daemon prio=<span class="number">6</span> tid=<span class="number">0x0000000022f1f000</span> nid=<span class="number">0x37c8</span> runnable</span><br><span class="line">[<span class="number">0x0000000027cbd000</span>]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">at java.net.SocketInputStream.read(Unknown Source)</span><br><span class="line">at oracle.net.ns.Packet.receive(Packet.java:<span class="number">240</span>)</span><br><span class="line">at oracle.net.ns.DataPacket.receive(DataPacket.java:<span class="number">92</span>)</span><br><span class="line">at oracle.net.ns.NetInputStream.getNextPacket(NetInputStream.java:<span class="number">172</span>)</span><br><span class="line">at oracle.net.ns.NetInputStream.read(NetInputStream.java:<span class="number">117</span>)</span><br><span class="line">at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:<span class="number">1034</span>)</span><br><span class="line">at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:<span class="number">588</span>)</span><br></pre></td></tr></table></figure><p><strong>分线程调度的休眠</strong></p><p>正常的线程池等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;d&amp;a-131&quot;</span> in Object.wait()</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingManager.getWorkToDo(WorkingManager.java:<span class="number">322</span>)</span><br><span class="line">- locked &lt;<span class="number">0x0000000313f656f8</span>&gt; (a com.jiuqi.dna.core.impl.WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingThread.run(WorkingThread.java:<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>可疑的线程等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;d&amp;a-121&quot;</span> in Object.wait()</span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:<span class="number">485</span>)</span><br><span class="line">at com.jiuqi.dna.core.impl.AcquirableAccessor.exclusive()</span><br><span class="line">- locked &lt;<span class="number">0x00000003011678d8</span>&gt; (a com.jiuqi.dna.core.impl.CacheGroup)</span><br><span class="line">at com.jiuqi.dna.core.impl.Transaction.lock()</span><br></pre></td></tr></table></figure><h3 id="入手点总结"><a href="#入手点总结" class="headerlink" title="入手点总结"></a><strong>入手点总结</strong></h3><p><strong>wait on monitor entry</strong>： 被阻塞的，肯定有问题</p><p><strong>runnable</strong>： 注意 IO 线程</p><p>**in Object.wait()**： 注意非线程池等待</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>想要学习一个命令，先来看看帮助，使用 <code>jstack -help</code> 查看帮助：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pudding<span class="meta">@DESKTOP</span>-1QCHCU4:~$ jstack -help</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use <span class="keyword">when</span> jstack &lt;pid&gt; does not <span class="title function_">respond</span> <span class="params">(process is hung)</span></span><br><span class="line">    -m  to print both java and <span class="keyword">native</span> <span class="title function_">frames</span> <span class="params">(mixed mode)</span></span><br><span class="line">    -l  <span class="type">long</span> listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print <span class="built_in">this</span> help message</span><br></pre></td></tr></table></figure><ul><li>-F：当 ’jstack [-l] pid’ 没有相应的时候强制打印栈信息</li><li>-l：长列表。打印关于锁的附加信息，例如属于 java.util.concurrent 的 ownable synchronizers 列表</li><li>-m：打印 java 和 native c/c++ 框架的所有栈信息</li><li>-h：-help 打印帮助信息</li><li>pid：需要被打印配置信息的 java 进程 id，可以用 jps 查询</li></ul><p>首先，我们分析这么一段程序的线程情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pudding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JStackDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//Do Nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是有 jps 查看进程号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pudding<span class="meta">@DESKTOP</span>-1QCHCU4:/mnt/wsl$ jps</span><br><span class="line"><span class="number">929</span> org.eclipse.equinox.launcher_1<span class="number">.6</span><span class="number">.800</span>.v20240513-<span class="number">1750.</span>jar</span><br><span class="line"><span class="number">1477</span> sun.tools.jcmd.JCmd</span><br><span class="line"><span class="number">1499</span> Jps</span><br><span class="line"><span class="number">1372</span> JStackDemo1</span><br></pre></td></tr></table></figure><p>然后使用 jstack 查看堆栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pudding<span class="meta">@DESKTOP</span>-1QCHCU4:/mnt/wsl$ jstack <span class="number">1372</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">06</span>-<span class="number">26</span> <span class="number">21</span>:<span class="number">41</span>:<span class="number">40</span></span><br><span class="line">Full thread dump OpenJDK <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(<span class="number">25.412</span>-b08 mixed mode)</span>:</span><br><span class="line">...此处省略若干内容...</span><br><span class="line"><span class="string">&quot;main&quot;</span> #<span class="number">1</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007fc86c00a800</span> nid=<span class="number">0x55d</span> runnable [<span class="number">0x00007fc873672000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at JStackDemo1.main(JStackDemo1.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>我们可以从这段堆栈信息中看出什么来呢？我们可以看到，当前一共有一条用户级别线程，线程处于 runnable 状态，执行到 <a href="/img/2024-06-30-Jstack/http://JStackDemo1.java">JStackDemo1.java</a> 的第七行。 看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pudding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JStackDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程堆栈信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Reference Handler&quot;</span> daemon prio=<span class="number">10</span> tid=<span class="number">0x00007fbbcc06e000</span> nid=<span class="number">0x286c</span> in Object.wait() [<span class="number">0x00007fbbc8dfc000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;<span class="number">0x0000000783e066e0</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">    at java.lang.Object.wait(Object.java:<span class="number">503</span>)</span><br><span class="line">    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">133</span>)</span><br><span class="line">    - locked &lt;<span class="number">0x0000000783e066e0</span>&gt; (a java.lang.ref.Reference$Lock)</span><br></pre></td></tr></table></figure><p>我们能看到：</p><blockquote><p>线程的状态： WAITING 线程的调用栈<br>线程的当前锁住的资源： &lt;0x0000000783e066e0&gt;<br>线程当前等待的资源：&lt;0x0000000783e066e0&gt;</p></blockquote><p>为什么同时锁住的等待同一个资源：</p><blockquote><p>线程的执行中，先获得了这个对象的 Monitor（对应于 locked &lt;0x0000000783e066e0&gt;）。当执行到 obj.wait()，线程即放弃了 Monitor 的所有权，进入 “wait set” 队列（对应于 waiting on &lt;0x0000000783e066e0&gt; ）。</p></blockquote><h3 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a><strong>死锁分析</strong></h3><p>学会了怎么使用 jstack 命令之后，我们就可以看看，如何使用 jstack 分析死锁了，这也是我们一定要掌握的内容。 <strong>啥叫死锁？</strong> 所谓<a href="/img/2024-06-30-Jstack/http://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81">死锁</a>： 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 </p><p>说白了，我现在想吃鸡蛋灌饼，桌子上放着鸡蛋和饼，但是我和我的朋友同时分别拿起了鸡蛋和病，我手里拿着鸡蛋，但是我需要他手里的饼。他手里拿着饼，但是他想要我手里的鸡蛋。就这样，如果不能同时拿到鸡蛋和饼，那我们就不能继续做后面的工作（做鸡蛋灌饼）。所以，这就造成了死锁。 <strong>看一段死锁的程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pudding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLockclass</span>(<span class="literal">true</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLockclass</span>(<span class="literal">false</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLockclass</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> falg;</span><br><span class="line">    DeadLockclass(<span class="type">boolean</span> falg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.falg = falg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果falg的值为true则调用t1线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (falg) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Suo.o1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;o1 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">synchronized</span> (Suo.o2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;o2 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果falg的值为false则调用t2线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Suo.o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;o2 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">synchronized</span> (Suo.o1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;o1 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Suo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我启动该程序时，我们看一下控制台：</p><p><img src="/img/2024-06-30-Jstack/Untitled1.png" alt="控制台"></p><p>我们发现，程序只输出了两行内容，然后程序就不再打印其它的东西了，但是程序并没有停止。这样就产生了死锁。 当线程 1 使用 <code>synchronized</code> 锁住了 o1 的同时，线程 2 也是用 <code>synchronized</code> 锁住了 o2。当两个线程都执行完第一个打印任务的时候，线程 1 想锁住 o2，线程 2 想锁住 o1。但是，线程 1 当前锁着 o1，线程 2 锁着 o2。所以两个想成都无法继续执行下去，就造成了死锁。<br>然后，我们使用 <strong>jstack 来看一下线程堆栈信息</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f6274003ac8</span> (object <span class="number">0x000000077e004ec0</span>, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f62740050c8</span> (object <span class="number">0x000000077e004ed0</span>, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">        at DeadLockclass.run(JStackDemo.java:<span class="number">40</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x000000077e004ec0</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x000000077e004ed0</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">        at DeadLockclass.run(JStackDemo.java:<span class="number">27</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x000000077e004ed0</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x000000077e004ec0</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure><p>哈哈，堆栈写的很明显，它告诉我们 <code>Found one Java-level deadlock</code>，然后指出造成死锁的两个线程的内容。然后，又通过 <code>Java stack information for the threads listed above</code>来显示更详细的死锁的信息。 他说</p><blockquote><p>Thread-1 在想要执行第 40 行的时候，当前锁住了资源 <code>&lt;0x00000007d6aa2ca8&gt;</code>，但是他在等待资源 <code>&lt;0x00000007d6aa2c98&gt;</code> ；<br>Thread-0 在想要执行第 27 行的时候，当前锁住了资源 <code>&lt;0x00000007d6aa2c98&gt;</code>，但是他在等待资源<code>&lt;0x00000007d6aa2ca8&gt;</code> ；<br>由于这两个线程都持有资源，并且都需要对方的资源，所以造成了死锁。 原因我们找到了，就可以具体问题具体分析，解决这个死锁了。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><p><strong>虚拟机执行 Full GC 时，会阻塞所有的用户线程。因此，即时获取到同步锁的线程也有可能被阻塞。</strong> 在查看线程 Dump 时，首先查看内存使用情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jstack 是 java 虚拟机自带的一种堆栈跟踪工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h2&gt;&lt;p&gt;jstack </summary>
      
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java命令学习系列—Jstat</title>
    <link href="https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jstat/"/>
    <id>https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jstat/</id>
    <published>2024-06-30T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.014Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jstat (JVM Statistics Monitoring Tool) 用于监控虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机进程中类加载、内存、垃圾收集、JIT 编译等运行数据，再没有 GUI 图形的服务器上，它是运行期间定位虚拟机性能问题首选工具。</p></blockquote><p>jstat 位于 java 的 bin 目录下，主要利用 JVM 内建的指令对 Java 应用程序的资源和性能进行实施的命令行的监控，包括了对 Heap size 和垃圾回收状况的监控。可见，Jstat 是轻量级的、专门针对 JVM 的工具，非常适用。</p><h2 id="jstat-命令格式"><a href="#jstat-命令格式" class="headerlink" title="jstat 命令格式"></a>jstat 命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure><h3 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a><strong>参数解释：</strong></h3><ul><li>Option — 选项，我们一般使用 -gcutil 查看 gc 情况</li><li>vmid — VM的进程号，即当前运行的java进程号</li><li>interval– 间隔时间，单位为秒或者毫秒</li><li>count — 打印次数，如果缺省则打印无数次</li><li>参数 interval 和 count 代表查询间隔和次数，如果省略这两个参数，说明只查询一次。假设需要每 250 毫秒查询一次进程 5828 垃圾收集状况，一共查询 5 次，那命令行如下：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 5828 250 5</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于命令格式中的 VMID 与 LVMID 需要特别说明下：</span><br><span class="line">如果是本地虚拟机进程，VMID(Virtual Machine IDentifier,虚机标识符) 和 LVMID(Local Virtual Machine IDentifier，虚机标识符) 是一致的；</span><br><span class="line">如果是远程虚拟机进程，那 VMID 的格式应当是：[protocol:][//] lvmid [@hostname[:port]/servername]</span><br></pre></td></tr></table></figure><h3 id="option"><a href="#option" class="headerlink" title="option"></a><strong>option</strong></h3><p>选项 option 代表这用户希望查询的虚拟机信息，主要分为 3 类：类装载、垃圾收集和运行期编译状况，具体选项及作用如下：</p><ul><li><code>class</code> 监视类装载、卸载数量、总空间及类装载所耗费的时间</li><li><code>gc</code> 监视 Java 堆状况，包括 Eden 区、2 个Survivor区、老年代、永久代等的容量</li><li><code>gccapacity</code> 监视内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大和最小空间</li><li><code>gcutil</code> 监视内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</li><li><code>gccause</code> 与 -gcutil 功能一样，但是会额外输出导致上一次 GC 产生的原因</li><li><code>gcnew</code> 监视新生代 GC 的状况</li><li><code>gcnewcapacity</code>监视内容与 -gcnew 基本相同，输出主要关注使用到的最大和最小空间</li><li><code>gcold</code> 监视老年代 GC 的状况</li><li><code>gcoldcapacity</code> 监视内容与 -gcold 基本相同，输出主要关注使用到的最大和最小空间</li><li><code>gcpermcapacity</code> 输出永久代使用到的最大和最小空间</li><li><code>compiler</code> 输出 JIT 编译器编译过的方法、耗时等信息</li><li><code>printcompilation</code> 输出已经被 JIT 编译的方法</li></ul><h2 id="常见术语"><a href="#常见术语" class="headerlink" title="常见术语"></a><strong>常见术语</strong></h2><p><strong>1、<code>jstat –class&lt;pid&gt; :</code> 显示加载 class 的数量，及所占空间等信息。</strong></p><blockquote><p><code>Loaded</code> 装载的类的数量<br><code>Bytes</code> 装载类所占用的字节数 <br><code>Unloaded</code> 卸载类的数量 <br><code>Bytes</code> 卸载类的字节数 <br><code>Time</code> 装载和卸载类所花费的时间</p></blockquote><p><strong>2、<code>jstat -compiler &lt;pid&gt;</code>显示 VM 实时编译的数量等信息。</strong></p><blockquote><p><code>Compiled</code> 编译任务执行数量 <br><code>Failed</code> 编译任务执行失败数量 <br><code>Invalid</code> 编译任务执行失效数量 <br><code>Time</code> 编译任务消耗时间 <br><code>FailedType</code> 最后一个编译失败任务的类型 <br><code>FailedMethod</code> 最后一个编译失败任务所在的类及方法</p></blockquote><p><strong>3、<code>jstat -gc &lt;pid&gt;</code>: 可以显示 gc 的信息，查看 gc 的次数，及时间。</strong></p><blockquote><p><code>S0C</code> 年轻代中第一个 survivor（幸存区）的容量 （字节）<br><code>S1C</code> 年轻代中第二个 survivor（幸存区）的容量 （字节）<br><code>S0U</code> 年轻代中第一个 survivor（幸存区）目前已使用空间（字节）<br><code>S1U</code> 年轻代中第二个 survivor（幸存区）目前已使用空间（字节）<br><code>EC</code> 年轻代中 Eden（伊甸园）的容量（字节）<br><code>EU</code> 年轻代中 Eden（伊甸园）目前已使用空间（字节）<br><code>OC</code> Old 代的容量（字节）<br><code>OU</code> Old 代目前已使用空间（字节）<br><code>PC</code> Perm（持久代）的容量（字节） <br><code>PU</code> Perm（持久代）目前已使用空间（字节）<br><code>YGC</code> 从应用程序启动到采样时年轻代中 gc 次数<br><code>YGCT</code> 从应用程序启动到采样时年轻代中 gc 所用时间（s）<br><code>FGC</code> 从应用程序启动到采样时 old 代（全 gc）gc 次数<br><code>FGCT</code> 从应用程序启动到采样时 old 代（全 gc）gc 所用时间（s）<br><code>GCT</code> 从应用程序启动到采样时 gc 用的总时间（s）</p></blockquote><p><strong>4、<code>jstat -gccapacity &lt;pid&gt;:</code>可以显示，VM内存中三代（young,old,perm）对象的使用和占用大小</strong></p><blockquote><p><code>NGCMN</code> 年轻代（young）中初始化（最小）的大小（字节） <br><code>NGCMX</code> 年轻代（young）的最大容量（字节）<br><code>NGC</code> 年轻代（young）中当前的容量（字节）<br><code>S0C</code> 年轻代中第一个 survivor（幸存区）的容量（字节） <br><code>S1C</code> 年轻代中第二个 survivor（幸存区）的容量（字节） <br><code>EC</code> 年轻代中 Eden（伊甸园）的容量（字节） <br><code>OGCMN</code> old 代中初始化（最小）的大小（字节）<br><code>OGCMX</code> old 代的最大容量（字节）<br><code>OGC</code> old代当前新生成的容量（字节）<br><code>OC</code> Old代的容量 （字节） <br><code>PGCMN</code> perm 代中初始化（最小）的大小 （字节） <br><code>PGCMX</code> perm 代的最大容量（字节）<br><code>PGC</code> perm 代当前新生成的容量（字节） <br><code>PC</code> Perm（持久代）的容量（字节） <br><code>YGC</code> 从应用程序启动到采样时年轻代中 gc 次数 <br><code>FGC</code> 从应用程序启动到采样时 old 代（全gc）gc 次数</p></blockquote><p><strong>5、<code>jstat -gcutil &lt;pid&gt;</code>:统计gc信息</strong></p><blockquote><p><code>S0</code> 年轻代中第一个 survivor（幸存区）已使用的占当前容量百分比<br><code>S1</code> 年轻代中第二个 survivor（幸存区）已使用的占当前容量百分比<br><code>E</code> 年轻代中 Eden（伊甸园）已使用的占当前容量百分比<br><code>O</code> old 代已使用的占当前容量百分比 <br><code>P</code> perm 代已使用的占当前容量百分比 <br><code>YGC</code> 从应用程序启动到采样时年轻代中 gc 次数 <br><code>YGCT</code> 从应用程序启动到采样时年轻代中 gc 所用时间（s）<br><code>FGC</code> 从应用程序启动到采样时 old 代（全 gc）gc 次数 <br><code>FGCT</code> 从应用程序启动到采样时 old 代（全 gc）gc 所用时间（s） <br><code>GCT</code> 从应用程序启动到采样时 gc 用的总时间（s）</p></blockquote><p><strong>6、<code>jstat -gcnew &lt;pid&gt;</code>:年轻代对象的信息。</strong></p><blockquote><p><code>S0C</code> 年轻代中第一个survivor（幸存区）的容量（字节）<br><code>S1C</code> 年轻代中第二个survivor（幸存区）的容量（字节）<br><code>S0U</code> 年轻代中第一个survivor（幸存区）目前已使用空间（字节）<br><code>S1U</code> 年轻代中第二个survivor（幸存区）目前已使用空间（字节）<br><code>TT</code> 持有次数限制<br><code>MTT</code> 最大持有次数限制<br><code>EC</code> 年轻代中 Eden（伊甸园）的容量（字节）<br><code>EU</code> 年轻代中 Eden（伊甸园）目前已使用空间（字节）<br><code>YGC</code> 从应用程序启动到采样时年轻代中 gc 次数<br><code>YGCT</code> 从应用程序启动到采样时年轻代中 gc 所用时间（s）</p></blockquote><p><strong>7、<code>jstat -gcnewcapacity&lt;pid&gt;</code>: 年轻代对象的信息及其占用量。</strong></p><blockquote><p><code>NGCMN</code> 年轻代（young）中初始化（最小）的大小（字节）<br><code>NGCMX</code> 年轻代（young）的最大容量（字节）<br><code>NGC</code> 年轻代（young）中当前的容量（字节）<br><code>S0CMX</code> 年轻代中第一个 survivor（幸存区）的最大容量（字节）<br><code>S0C</code> 年轻代中第一个 survivor（幸存区）的容量（字节）<br><code>S1CMX</code> 年轻代中第二个 survivor（幸存区）的最大容量（字节）<br><code>S1C</code> 年轻代中第二个 survivor（幸存区）的容量（字节）<br><code>ECMX</code> 年轻代中 Eden（伊甸园）的最大容量（字节）<br><code>EC</code> 年轻代中 Eden（伊甸园）的容量（字节）<br><code>YGC</code> 从应用程序启动到采样时年轻代中 gc 次数<br><code>FGC</code> 从应用程序启动到采样时 old 代（全 gc）gc 次数</p></blockquote><p><strong>8、<code>jstat -gcold &lt;pid&gt;：</code>old代对象的信息。</strong></p><blockquote><p><code>PC</code> Perm（持久代）的容量 （字节） <br><code>PU</code> Perm（持久代）目前已使用空间 （字节） <br><code>OC</code> Old代的容量 （字节） OU Old 代目前已使用空间 （字节） <br><code>YGC</code> 从应用程序启动到采样时年轻代中 gc 次数 <br><code>FGC</code> 从应用程序启动到采样时 old 代（全gc）gc 次数 <br><code>FGCT</code> 从应用程序启动到采样时 old 代（全gc）gc 所用时间（s） <br><code>GCT</code> 从应用程序启动到采样时 gc 用的总时间（s）</p></blockquote><p><strong>9、<code>stat -gcoldcapacity &lt;pid&gt;</code>: old代对象的信息及其占用量。</strong></p><blockquote><p><code>OGCMN</code> old 代中初始化（最小）的大小 （字节）<br><code>OGCMX</code> old 代的最大容量（字节）<br><code>OGC</code> old 代当前新生成的容量 （字节）<br><code>OC</code> Old 代的容量 （字节）<br><code>YGC</code> 从应用程序启动到采样时年轻代中 gc 次数<br><code>FGC</code> 从应用程序启动到采样时 old 代（全gc）gc 次数<br><code>FGCT</code> 从应用程序启动到采样时 old 代（全gc）gc 所用时间（s）<br><code>GCT</code> 从应用程序启动到采样时 gc 用的总时间（s）</p></blockquote><p><strong>10、<code>jstat -gcpermcapacity&lt;pid&gt;</code>: perm对象的信息及其占用量。</strong></p><blockquote><p><code>PGCMN</code> perm代中初始化（最小）的大小 （字节）<br><code>PGCMX</code> perm代的最大容量 （字节）<br><code>PGC</code> perm代当前新生成的容量 （字节）<br><code>PC</code> Perm（持久代）的容量 （字节）<br><code>YGC</code> 从应用程序启动到采样时年轻代中 gc 次数<br><code>FGC</code> 从应用程序启动到采样时 old 代（全gc）gc 次数<br><code>FGCT</code> 从应用程序启动到采样时 old 代（全gc）gc 所用时间（s）<br><code>GCT</code> 从应用程序启动到采样时 gc 用的总时间（s）</p></blockquote><p><strong>11、<code>jstat -printcompilation &lt;pid&gt;</code>：当前VM执行的信息。</strong></p><blockquote><p><code>Compiled</code> 编译任务的数目<br><code>Size</code> 方法生成的字节码的大小<br><code>Type</code> 编译类型<br><code>Method</code> 类名和方法名用来标识编译的方法。<br>类名使用/做为一个命名空间分隔符。方法名是给定类中的方法。上述格式是由-XX:+PrintComplation选项进行设置的</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jstat (JVM Statistics Monitoring Tool) 用于监控虚拟机各种运行状态信息的命令行工具。它可以显示本地或远程虚拟机进程中类加载、内存、垃圾收集、JIT 编译等运行数据，再没有 GUI 图形的服务器上，它是运行期间定</summary>
      
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java开发必须掌握的线上问题排查命令</title>
    <link href="https://wu3227834.github.io/2024/06/30/2024-06-30-java-kai-fa-bi-xu-zhang-wo-de-xian-shang-wen-ti-pai-cha-ming-ling/"/>
    <id>https://wu3227834.github.io/2024/06/30/2024-06-30-java-kai-fa-bi-xu-zhang-wo-de-xian-shang-wen-ti-pai-cha-ming-ling/</id>
    <published>2024-06-30T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.014Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个合格的开发人员，不仅要能写得一手代码，还要有一项很重要的技能就是排查问题。这里提到的排查问题不仅仅是在 coding 的过程中 debug 等，还包括的就是线上问题的排查。由于在生成环境中，一般没办法 debug（其实有些问题，debug 也白扯…），所以我们需要借助一些常见命令来查看运行时的具体情况，这些运行时信息包括但不限于运行日志、异常堆栈、堆使用情况、GC情况、JVM参数情况、线程情况等。</p><p>给一个系统定位问题的时候，知识、经验是关键，数据是依据，工具是运用知识处理数据的手段。为了便于我们排查和解决问题，Sun 公司为我们提供了一些常用命令。这些命令一般都是 jdk/lib/tools.jar 中类库的一层薄包装。随着 JVM 的安装一起被安装到机器中，在 bin 目录中。下面就来认识一下这些命令以及具体使用方式。</p><h2 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h2><p><strong>功能：</strong>显示当前所有 java 进程 pid 的命令。</p><p><strong>常见指令：</strong></p><p><code>jps</code>：显示当前用户的所有java进程的PID</p><p><code>jps -v 3331</code>：显示虚拟机参数</p><p><code>jps -m 3331</code>：显示传递给 main() 函数的参数</p><p><code>jps -l 3331</code>：显示主类的全路径</p><h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p><strong>功能：</strong>实时查看和调整虚拟机参数，可以显示未被显示指定的参数的默认值（jps  -v 则不能）</p><blockquote><p>jdk8 中已经不支持该命令</p></blockquote><p><strong>常用指令：</strong></p><p><code>jinfo -flag CMSIniniatingOccupancyFration 1444</code>：查询 CMSIniniatingOccupancyFration 参数值</p><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p><strong>功能：</strong>显示进程中的类加载、内存、垃圾收集、JIT 编译等运行数据。</p><p><strong>常用指令：</strong></p><p><code>jstat -gc 3331 250 20</code> ：查询进程2764的垃圾收集情况，每250毫秒查询一次，一共查询20次。</p><p><code>jstat -gccause</code>：额外输出上次GC原因</p><p><code>jstat -calss</code>：件事类装载、类卸载、总空间以及所消耗的时间</p><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p><strong>功能：</strong>生成堆准储快照（heapdump）</p><p><strong>常用指令：</strong></p><p><code>jmap -heap 3331</code>：查看java 堆（heap）使用情况</p><p><code>jmap -histo 3331</code>：查看堆内存（histogram）中的对象数量及大小</p><p><code>jmap -histo:live 3331</code>：JVM 会先触发 gc，然后再统计信息</p><p><code>jmap -dump:format=b,file=heapDump 3331</code>：将内存使用的详细情况输出到文件，之后一般使用其他工具进行分析。</p><h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a><strong>jhat</strong></h2><p><strong>功能：</strong>一般与 jmap 搭配使用，用来分析 jmap 生成的堆转储文件。</p><blockquote><p>由于有很多可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）可以替代，所以很少用。不过在没有可视化工具的机器上也是可用的。</p></blockquote><p><strong>常用指令：</strong></p><p><code>jmap -dump:format=b,file=heapDump 3331</code> + <code>jhat heapDump</code>：解析 Java 堆转储文件，并启动一个 web server</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a><strong>jstack</strong></h2><p><strong>功能：</strong>生成当前时刻的线程快照。</p><p><strong>常用指令：</strong></p><p><code>jstack 3331</code>：查看线程情况</p><p><code>jstack -F 3331</code>：正常输出不被响应时，使用该指令</p><p><code>jstack -l 3331</code>：除堆栈外，显示关于锁的附件信息</p><h1 id="常见问题定位过程"><a href="#常见问题定位过程" class="headerlink" title="常见问题定位过程"></a>常见问题定位过程</h1><h2 id="频繁-GC-问题或内存溢出问题"><a href="#频繁-GC-问题或内存溢出问题" class="headerlink" title="频繁 GC 问题或内存溢出问题"></a>频繁 GC 问题或内存溢出问题</h2><ol><li>使用 <code>jps</code> 查看线程 ID</li><li>使用 <code>jstat -gc xxx 250 20</code> 查看 gc 情况，一般比较关注 PERM 区的情况，查看 GC 的增长情况。</li><li>使用 <code>jstat -gccause</code> 额外输出上次 GC 原因</li><li>使用 <code>jmap -dump:format=b,file=heapDump xxx</code>  生成堆转储文件</li><li>使用 jhat 或者可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）分析堆情况。</li><li>结合代码解决内存溢出或泄露问题。</li></ol><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a><strong>死锁问题</strong></h2><ol><li>使用<code>jps</code>查看线程 ID，转换为 16 进制 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf %x 线程号</span><br></pre></td></tr></table></figure></li><li>使用<code>jstack xxx</code>：查看线程情况</li></ol><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h1><p>经常使用适当的虚拟机监控和分析工具可以加快我们分析数据、定位解决问题的速度，但也要知道，工具永远都是知识技能的一层包装，没有什么工具是包治百病的。</p><p><a href="https://wu3227834.github.io/2024/06/29/2026-06-30-java-ming-ling-xue-xi-xi-lie-yi-jps/"><strong>Java命令学习系列（一）— Jps</strong></a></p><p><a href="https://wu3227834.github.io/2024/06/29/2026-06-30-java-ming-ling-xue-xi-xi-lie-er-jstack/"><strong>Java命令学习系列（二）— Jstack</strong></a></p><p><a href="https://wu3227834.github.io/2024/06/29/2026-06-30-java-ming-ling-xue-xi-xi-lie-san-jmap/"><strong>Java命令学习系列（三）— Jmap</strong></a></p><p><a href="https://wu3227834.github.io/2024/06/29/2026-06-30-java-ming-ling-xue-xi-xi-lie-si-jstat/"><strong>Java命令学习系列（四）— Jstat</strong></a></p><p><a href="https://www.notion.so/Java-Jhat-e4da5c23fe34484093bcd8607fd14d07?pvs=21"><strong>Java命令学习系列（五）— Jhat</strong></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为一个合格的开发人员，不仅要能写得一手代码，还要有一项很重要的技能就是排查问题。这里提到的排查问题不仅仅是在 coding 的过程中 debug 等，还包括的就是线上问题的排查。由于在生成环境中，一般没办法 debug（其实有些问题，debug 也白扯…），所以我们需要借</summary>
      
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>性能测试——火焰图进阶</title>
    <link href="https://wu3227834.github.io/2024/04/22/2024-04-22-flamegraph/"/>
    <id>https://wu3227834.github.io/2024/04/22/2024-04-22-flamegraph/</id>
    <published>2024-04-22T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.014Z</updated>
    
    <content type="html"><![CDATA[<p>当程序出现性能瓶颈时，我们通常通过表象（比如请求某个接口时 CPU 使用率飙涨）然后结合代码去推测可能出问题的地方，却不知道问题到底是什么引起的。如果有个一可视化的工具直观地展现程序的性能瓶颈就好了，幸好 <a href="/img/2024-04-22-FlameGraph/http://www.brendangregg.com/">Brendan D. Gregg</a> 发明了火焰图。</p><p><a href="/img/2024-04-22-FlameGraph/http://www.brendangregg.com/flamegraphs.html">火焰图</a>（Flame Graph）看起来就像一团跳动的火焰，因此得名。火焰图可以将 CPU 的使用情况可视化，使我们直观地了解到程序的性能瓶颈，通常要结合操作系统的性能分析工具（profiling tracer）使用，常见的操作系统的性能分析工具如下：</p><ul><li>Linux：perf, eBPF, SystemTap, and ktap。</li><li>Solaris, illumos, FreeBSD：DTrace。</li><li>Mac OS X：DTrace and Instruments。</li><li>Windows：Xperf.exe。</li></ul><h2 id="1-1-1-perf"><a href="#1-1-1-perf" class="headerlink" title="1.1.1 perf"></a>1.1.1 perf</h2><p><a href="/img/2024-04-22-FlameGraph/http://www.brendangregg.com/linuxperf.html">perf_events</a>（简称 perf）是 Linux Kernal 自带的系统性能分析工具，能够进行函数级与指令级的热点查找。它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，常用于查找性能瓶颈及定位热点代码。</p><p>测试机器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux nswbmw-VirtualBox 4.10.0-28-generic <span class="comment">#32~16.04.2-Ubuntu SMP Thu Jul 20 10:19:48 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：非 Linux 用户需要用虚拟机安装 Ubuntu 16.04 和 <a href="mailto:&#x6e;&#111;&#100;&#x65;&#64;&#56;&#46;&#57;&#x2e;&#52;">&#x6e;&#111;&#100;&#x65;&#64;&#56;&#46;&#57;&#x2e;&#52;</a> 后进行后面的操作。</p><p>安装 perf：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> apt install linux-tools-common</span><br><span class="line">$ perf <span class="comment"># 根据提示安装对应的内核版本的 tools, 如下</span></span><br><span class="line">$ <span class="built_in">sudo</span> apt install linux-tools-4.10.0-28-generic linux-cloud-tools-4.10.0-28-generic</span><br></pre></td></tr></table></figure><p>创建测试目录 ~/test 和测试代码：</p><p><strong>app.js</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&#x27;crypto&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Paloma</span> = <span class="built_in">require</span>(<span class="string">&#x27;paloma&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Paloma</span>()</span><br><span class="line"><span class="keyword">const</span> users = &#123;&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">route</span>(&#123; <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;/newUser&#x27;</span>, <span class="title function_">controller</span> (ctx) &#123;</span><br><span class="line">  <span class="keyword">const</span> username = ctx.<span class="property">query</span>.<span class="property">username</span> || <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> password = ctx.<span class="property">query</span>.<span class="property">password</span> || <span class="string">&#x27;test&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> salt = crypto.<span class="title function_">randomBytes</span>(<span class="number">128</span>).<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> hash = crypto.<span class="title function_">pbkdf2Sync</span>(password, salt, <span class="number">10000</span>, <span class="number">64</span>, <span class="string">&#x27;sha512&#x27;</span>).<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  users[username] = &#123; salt, hash &#125;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="property">status</span> = <span class="number">204</span></span><br><span class="line">&#125;&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">route</span>(&#123; <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;/auth&#x27;</span>, <span class="title function_">controller</span> (ctx) &#123;</span><br><span class="line">  <span class="keyword">const</span> username = ctx.<span class="property">query</span>.<span class="property">username</span> || <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> password = ctx.<span class="property">query</span>.<span class="property">password</span> || <span class="string">&#x27;test&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!users[username]) &#123;</span><br><span class="line">    ctx.<span class="keyword">throw</span>(<span class="number">400</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> hash = crypto.<span class="title function_">pbkdf2Sync</span>(password, users[username].<span class="property">salt</span>, <span class="number">10000</span>, <span class="number">64</span>, <span class="string">&#x27;sha512&#x27;</span>).<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (users[username].<span class="property">hash</span> === hash) &#123;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">204</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.<span class="keyword">throw</span>(<span class="number">403</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;)</span><br><span class="line"> </span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><p>添加 –perf_basic_prof（或者 –perf-basic-prof）参数运行此程序，会对应生成一个 /tmp/perf-&lt;PID&gt;.map 的文件。命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ node --perf_basic_prof app.js &amp;</span><br><span class="line">[1] 3590</span><br><span class="line">$ <span class="built_in">tail</span> /tmp/perf-3590.map</span><br><span class="line">51b87a7b93e 18 Function:~emitListeningNT net.js:1375</span><br><span class="line">51b87a7b93e 18 LazyCompile:~emitListeningNT net.js:1375</span><br><span class="line">51b87a7bad6 39 Function:~emitAfterScript async_hooks.js:443</span><br><span class="line">51b87a7bad6 39 LazyCompile:~emitAfterScript async_hooks.js:443</span><br><span class="line">51b87a7bcbe 77 Function:~tickDone internal/process/next_tick.js:88</span><br><span class="line">51b87a7bcbe 77 LazyCompile:~tickDone internal/process/next_tick.js:88</span><br><span class="line">51b87a7bf36 12 Function:~clear internal/process/next_tick.js:42</span><br><span class="line">51b87a7bf36 12 LazyCompile:~clear internal/process/next_tick.js:42</span><br><span class="line">51b87a7c126 b8 Function:~emitPendingUnhandledRejections internal/process/promises.js:86</span><br><span class="line">51b87a7c126 b8 LazyCompile:~emitPendingUnhandledRejections internal/process/promises.js:86</span><br></pre></td></tr></table></figure><p><strong>map 文件内容三列依次为</strong>：16进制的符号地址（symbol addresses）、大小（sizes）和符号名（symbol names）。perf 会尝试查找 /tmp/perf-&lt;PID&gt;.map 文件，用来做符号转换，即把 16 进制的符号地址转换成人能读懂的符号名。</p><p><strong>注意</strong>：使用 –perf_basic_prof_only_functions 参数也可以，但经尝试后发现生成的火焰图信息不全（不全的地方显示 [perf-&lt;PID&gt;.map]），所以这里使用 –perf_basic_prof。但是，使用 –perf_basic_prof  有个缺点，就是会导致 map 文件一直增大，这是由于符号（symbols）地址不断变换导致的，用 –perf_basic_prof_only_functions 可以缓解这个问题。关于如何取舍，还请读者自行尝试。</p><p>接下来 clone 用来生成火焰图的工具：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> http://github.com/brendangregg/FlameGraph ~/FlameGraph</span><br></pre></td></tr></table></figure><p>我们先用 ab 压测：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="string">&quot;http://localhost:3000/newUser?username=admin&amp;password=123456&quot;</span></span><br><span class="line">$ ab -k -c 10 -n 2000 <span class="string">&quot;http://localhost:3000/auth?username=admin&amp;password=123456&quot;</span></span><br></pre></td></tr></table></figure><p>新开另一个终端，在 ab 开始压测后立即运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> perf record -F 99 -p 3590 -g -- <span class="built_in">sleep</span> 30</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chown</span> root /tmp/perf-3590.map</span><br><span class="line">$ <span class="built_in">sudo</span> perf script &gt; perf.stacks</span><br><span class="line">$ ~/FlameGraph/stackcollapse-perf.pl --kernel &lt; ~/perf.stacks | ~/FlameGraph/flamegraph.pl --color=js --<span class="built_in">hash</span>&gt; ~/flamegraph.svg</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：第 1 次生成的 svg 可能不太准确，最好重复几次以上步骤，使用第 2 次及以后生成的 flamegraph.svg。</p><p>有几点需要解释一下：</p><ul><li><p>perf record</p><ul><li>-F 指定了采样频率 99Hz（即每秒 99 次，如果 99 次都返回同一个函数名，那就说明 CPU 在这一秒钟都在执行同一个函数，可能存在性能问题）。</li><li>-p 指定进程的 pid。</li><li>-g 启用 call-graph 记录。</li><li>– sleep 30 指定记录 30s。</li></ul></li><li><p>sudo chown root /tmp/perf-3009.map，将 map 文件更改为 root 权限，否则会报如下错误：</p><blockquote><p>File /tmp/perf-PID.map not owned by current user or root, ignoring it (use -f to override).<br>Failed to open /tmp/perf-PID.map, continuing without symbols</p></blockquote></li><li><p>perf record 会将记录的信息保存到当前执行目录的 perf.data 文件中，然后使用 perf script 读取 perf.data 的 trace 信息写入 perf.stacks。</p></li><li><p>–color=js 指定生成针对 JavaScript 配色的 svg，即：</p><ul><li>green：JavaScript。</li><li>blue：Builtin。</li><li>yellow：C++。</li><li>red：System（native user-level, and kernel）。</li></ul></li></ul><p>ab 压测用了 30s 左右，用浏览器打开 flamegraph.svg，截取关键的部分如下图所示：</p><p><img src="/img/2024-04-22-FlameGraph/1.1.1.png" alt="flamegraph1.svg"></p><h2 id="1-1-2-理解火焰图"><a href="#1-1-2-理解火焰图" class="headerlink" title="1.1.2 理解火焰图"></a>1.1.2 理解火焰图</h2><p>火焰图含义：</p><ul><li>每一个小块代表了一个函数在栈中的位置（即一个栈帧）。</li><li>Y 轴代表栈的深度（栈上的帧数），顶端的小块显示了占据 CPU 的函数。每个小块的下面是它的祖先（即父函数）。</li><li>X 轴代表总的样例群体。它不像绝大多数图表那样从左到右表示时间的流逝，其左右顺序没有特殊含义，仅仅按照字母表的顺序排列。</li><li>小块的宽度代表 CPU 的使用时间，或者说相对于父函数而言使用 CPU 的比例（基于所有样例），越宽则代表占用 CPU 的时间越长，或者使用 CPU 很频繁。</li><li>如果采取多线程并发运行取样，则取样数量会超过运行时间。</li></ul><p><strong>从上图可以看出</strong>：最上面的绿色小块（即 JavaScript 代码）指向 test/app.js 第 18 行，即 <code>GET /auth</code> 这个路由。再往上看，黄色的小块（即 C++ 代码） node::crypto::PBKDF2 占用了大量的 CPU 时间。</p><p><strong>解决方法</strong>：将同步改为异步，即将 crypto.pbkdf2Sync 改为 crypto.pbkdf2。修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">route</span>(&#123; <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>, <span class="attr">path</span>: <span class="string">&#x27;/auth&#x27;</span>, <span class="keyword">async</span> <span class="title function_">controller</span> (ctx) &#123;</span><br><span class="line">  <span class="keyword">const</span> username = ctx.<span class="property">query</span>.<span class="property">username</span> || <span class="string">&#x27;test&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> password = ctx.<span class="property">query</span>.<span class="property">password</span> || <span class="string">&#x27;test&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!users[username]) &#123;</span><br><span class="line">    ctx.<span class="keyword">throw</span>(<span class="number">400</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> hash = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    crypto.<span class="title function_">pbkdf2</span>(password, users[username].<span class="property">salt</span>, <span class="number">10000</span>, <span class="number">64</span>, <span class="string">&#x27;sha512&#x27;</span>, <span class="function">(<span class="params">err, derivedKey</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">resolve</span>(derivedKey.<span class="title function_">toString</span>(<span class="string">&#x27;hex&#x27;</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (users[username].<span class="property">hash</span> === hash) &#123;</span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">204</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx.<span class="keyword">throw</span>(<span class="number">403</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;)</span><br></pre></td></tr></table></figure><p>用 ab 重新压测，结果用了 16s。重新生成的火焰图如下：</p><p><img src="/img/2024-04-22-FlameGraph/1.1.2.png" alt="flamegraph2.svg"></p><p><strong>可以看出</strong>：只有在左侧极窄的绿色小块可以看到 JavaScript 代码，红色的部分我们不关心也无法优化。那么，为什么异步比同步的 QPS 要高呢？原因是 Node.js 底层的 libuv 用了多个线程进行计算，这里就不再深入介绍了。</p><p>svg 火焰图的其他小技巧如下：</p><ol><li>单击任意一个小块即可展开，即被单击的小块宽度变宽，它的子函数也按比例变宽，方便查看。</li><li>可单击 svg 右上角的 search 按钮进行搜索，被搜索的关键词会高亮显示，在有目的地查找某个函数时比较有用。</li></ol><h2 id="1-1-3-红蓝差分火焰图"><a href="#1-1-3-红蓝差分火焰图" class="headerlink" title="1.1.3 红蓝差分火焰图"></a>1.1.3 红蓝差分火焰图</h2><p>虽然我们有了火焰图，但要处理性能回退问题，还需要在修改代码前后的火焰图之间，不断切换和对比，来找出问题所在，很不方便。于是 <a href="/img/2024-04-22-FlameGraph/http://www.brendangregg.com/index.html">Brendan D. Gregg</a> 又发明了红蓝差分火焰图（Red/Blue Differential Flame Graphs）。</p><p><strong>如下所示</strong>：红色表示增长，蓝色表示衰减。</p><p><img src="/img/2024-04-22-FlameGraph/1.1.3.png" alt="flamegraph3.svg"></p><p>红蓝差分火焰图的工作原理如下：</p><ol><li>抓取修改前的栈 profile1 文件。</li><li>抓取修改后的栈 profile2 文件。</li><li>使用 profile2 来生成火焰图，这样栈帧的宽度就是以 profile2 文件为基准的。</li><li>使用 profile2 - profile1 的差异来对火焰图重新上色。上色的原则是：如果栈帧在 profile2 中出现出现的次数更多，则标为红色，否则标为蓝色。色彩是根据修改前后的差异来填充的。</li></ol><p>这样，通过红蓝差分火焰图，我们就可以清楚地看到系统性能的差异之处。</p><p>生成红蓝差分火焰图的流程如下：</p><ol><li><p>修改代码前运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> perf record -F 99 -p &lt;PID&gt; -g -- <span class="built_in">sleep</span> 30</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chown</span> root /tmp/perf-&lt;PID&gt;.map</span><br><span class="line">$ <span class="built_in">sudo</span> perf script &gt; perf_before.stacks</span><br></pre></td></tr></table></figure></li><li><p>修改代码后运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">sudo</span> perf record -F 99 -p &lt;PID&gt; -g -- <span class="built_in">sleep</span> 30</span><br><span class="line">$ <span class="built_in">sudo</span> <span class="built_in">chown</span> root /tmp/perf-&lt;PID&gt;.map</span><br><span class="line">$ <span class="built_in">sudo</span> perf script &gt; perf_after.stacks</span><br></pre></td></tr></table></figure></li><li><p>将 profile 文件进行折叠（fold），然后生成差分火焰图：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ~/FlameGraph/stackcollapse-perf.pl ~/perf_before.stacks &gt; perf_before.folded</span><br><span class="line">$ ~/FlameGraph/stackcollapse-perf.pl ~/perf_after.stacks &gt; perf_after.folded</span><br><span class="line">$ ./FlameGraph/difffolded.pl perf_before.folded perf_after.folded | ./FlameGraph/flamegraph.pl &gt; flamegraph_diff.svg</span><br></pre></td></tr></table></figure></li></ol><p><strong>如上缺点是</strong>：如果一个代码执行路径完全消失了，那么在火焰图中就找不到地方来标注蓝色，我们只能看到当前的 CPU 使用情况，却不知道为什么会变成这样。</p><p>一种解决办法是：生成一个相反的差分火焰图，即基于 profile1 生成 profile1 - profile2 的差分火焰图。对应命令如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./FlameGraph/difffolded.pl perf_after.folded perf_before.folded | ./FlameGraph/flamegraph.pl --negate &gt; flamegraph_diff2.svg</span><br></pre></td></tr></table></figure><p>其中，–negate 用于颠倒红/蓝配色。最终我们得到：</p><ul><li>flamegraph_diff.svg：宽度是以修改前的 profile 文件为基准，颜色表明将要发生的情况。</li><li>flamegraph_diff2.svg：宽度是以修改后的 profile 文件为基准，颜色表明已经发生的情况。</li></ul><p>总之，红蓝差分火焰图可能只在代码变化不大的情况下使用时效果明显，在代码变化较大的情况下使用时效果可能就不明显了。</p><h2 id="1-1-4-参考链接"><a href="#1-1-4-参考链接" class="headerlink" title="1.1.4 参考链接"></a>1.1.4 参考链接</h2><ul><li><a href="https://lidaohang.gitbooks.io/quick_location/content/huo-yan-tu/cpuji-bie-huo-yan-tu/hong-lan-cha-fen-huo-yan-tu.html">https://lidaohang.gitbooks.io/quick_location/content/huo-yan-tu/cpuji-bie-huo-yan-tu/hong-lan-cha-fen-huo-yan-tu.html</a></li><li><a href="https://yunong.io/2015/11/23/generating-node-js-flame-graphs/">https://yunong.io/2015/11/23/generating-node-js-flame-graphs/</a></li><li><a href="http://www.brendangregg.com/perf.html">http://www.brendangregg.com/perf.html</a></li><li><a href="http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html">http://www.brendangregg.com/blog/2014-09-17/node-flame-graphs-on-linux.html</a></li><li><a href="https://linux.cn/article-4670-1.html">https://linux.cn/article-4670-1.html</a></li><li><a href="http://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html">http://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/09/flame-graph.html">http://www.ruanyifeng.com/blog/2017/09/flame-graph.html</a></li></ul>]]></content>
    
    
    <summary type="html">火焰图（Flame Graph）是一种可视化工具，用于直观分析程序性能瓶颈，广泛应用于性能测试。结合 Linux 的 perf、eBPF 等工具，火焰图通过采样展示 CPU 使用情况，Y 轴表示调用栈深度，X 轴表示采样频率，块宽度反映函数占用 CPU 时间。使用 perf 记录 Node.js 程序性能数据，配合 FlameGraph 工具生成 SVG 格式火焰图，可快速定位热点代码，如同步函数 crypto.pbkdf2Sync 导致的高 CPU 占用。优化后（如改为异步），火焰图显示性能提升。红蓝差分火焰图进一步对比代码修改前后的性能差异，红色表示 CPU 使用增长，蓝色表示减少，便于分析性能回退。然而，当代码变化较大时，差分效果可能不明显。火焰图通过直观展示调用栈和资源占用，是性能测试中不可或缺的工具。</summary>
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Perf" scheme="https://wu3227834.github.io/tags/Perf/"/>
    
    <category term="火焰图" scheme="https://wu3227834.github.io/tags/%E7%81%AB%E7%84%B0%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>Linux 性能调优基础：top</title>
    <link href="https://wu3227834.github.io/2024/04/07/2024-04-07-linux-tracing-basis/"/>
    <id>https://wu3227834.github.io/2024/04/07/2024-04-07-linux-tracing-basis/</id>
    <published>2024-04-07T00:00:00.000Z</published>
    <updated>2025-08-05T12:14:15.013Z</updated>
    
    <content type="html"><![CDATA[<p>top 命令是 linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用使用情况，类似于 windos 的任务窗口。</p><h2 id="top-理论"><a href="#top-理论" class="headerlink" title="top 理论"></a>top 理论</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">top - 16:55:39 up 220 days,  1:16,  4 <span class="built_in">users</span>,  load average: 299.05, 217.84, 106.90</span></span><br><span class="line">Tasks: 3355 total,  12 running, 3339 sleeping,   3 stopped,   1 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s): 40.7 us, 38.9 sy,  0.0 ni,  0.1 <span class="built_in">id</span>,  0.0 wa, 20.1 hi,  0.2 si,  0.0 st</span></span><br><span class="line">MiB Mem : 257336.1 total,  17260.1 free,  77063.5 used, 163012.4 buff/cache</span><br><span class="line">MiB Swap:  32768.0 total,  19075.1 free,  13692.9 used.  42491.5 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br></pre></td></tr></table></figure><p>统计信息区前五行是系统整体的统计信息。第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>16:55:39</td><td>当前时间</td></tr><tr><td>up 220 days</td><td>系统运行时间</td></tr><tr><td>4 users</td><td>当前登录用户数</td></tr><tr><td>load average: 299.05, 217.84, 106.90</td><td>系统负载，即任务队列平均长度。分别为 1、5、15 min 前到现在平均值</td></tr></tbody></table><p>第二、三行为进程和 CPU 的信息。当有多个 CPU 时，这些内容可能会超过两行。内容如下：</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>Tasks: 3355 total</td><td>进程总数[键入 H 可查看线程数]</td></tr><tr><td>12 running, 3339 sleeping, 3 stopped</td><td>正在运行的进程、睡眠进程、停止的进程</td></tr><tr><td>1 zombie</td><td>僵尸进程数</td></tr><tr><td>%Cpu(s): 40.7 us, 38.9 sy</td><td>用户空间占用 CPU 百分比、内核空间占用 CPU 百分比</td></tr><tr><td>0.0 ni, 0.1 id</td><td>用户进程空间内改变进程优先级占用 CPU、空闲 CPU 百分比</td></tr><tr><td>0.0 wa, 20.1 hi, 0.2 si, 0.0 st</td><td>等待 IO 的 CPU 时间百分比，最后三个是中断请求相关</td></tr></tbody></table><p>倒数第二、三行为内存相关信息：</p><table><thead><tr><th>内容</th><th>解释</th></tr></thead><tbody><tr><td>MiB Mem</td><td>表示系统内存的使用情况</td></tr><tr><td>MiB Swap</td><td>表示交换空间（虚拟内存）的使用情况</td></tr><tr><td>xxx total, xxx free, xxx used</td><td>分别是内存总量、空闲内存总量、使用内存总量</td></tr><tr><td>xxx buff/cache</td><td>被用作缓冲或缓存的内存量</td></tr><tr><td>xxx avail Mem</td><td>可用的交换空间</td></tr></tbody></table><ul><li>buffe <a href="http://wiki.answers.com/Q/Difference_between_buffer_and_cache">Difference between buffer and cache</a></li></ul><blockquote><p>由硬件设备或程序共享的数据区域称为缓冲区。它们以不同的速度运行，或者有不同的优先顺序。缓冲区允许每个设备或进程在没有其他设备或进程阻碍的情况下运行。为了使缓冲区有效，缓冲区设计器需要考虑缓冲区的大小。与缓存一样，缓冲区是一个“中点保存位置”，但它的存在并不是为了加快活动的速度，而是为了支持单独活动的协调。</p></blockquote><blockquote><p>这个术语不仅用于编程，也用于硬件。在编程中，缓冲有时需要从数据的最终预期位置筛选数据，以便在移动到常规文件或数据库之前对数据进行编辑或处理。</p></blockquote><ul><li>cached</li></ul><blockquote><p>高速缓冲存储器是随机存取存储器（RAM）的一种。计算机微处理器对高速缓冲存储器的访问速度比普通 RAM 的访问速度更快。就像微处理器处理数据一样，它首先在高速缓冲存储器中查找，如果在那里，它会从之前读取的数据中找到数据，它不需要从更大的内存中进行更耗时的数据读取。</p></blockquote><blockquote><p>有时，高速缓冲存储器是按照与微处理器的接近程度和便利程度来描述的。L1 高速缓存与微处理器位于同一芯片上。</p></blockquote><blockquote><p>除了高速缓存之外，RAM 本身也是一种用于硬盘存储的高速缓存，因为当你打开计算机并加载正在加载的操作系统时，所有 RAM 的内容都会先到达硬盘，稍后当你启动新应用程序并访问新数据。RAM 还包含一个称为磁盘缓存的特殊区域，该区域由最近从硬盘读取的数据组成。</p></blockquote><p>最后 1 行则是进程相关的资源占用信息:</p><ul><li>PID：进程ID。系统中每个进程都有一个唯一的ID号，称为进程ID。</li><li>USER：进程的拥有者。显示启动这个进程的用户名称。</li><li>PR：进程的优先级。内核根据这个值来决定进程的执行优先级。</li><li>NI：进程的nice值。这是一个用户控制的为进程设置的优先级的值。数值可从-20（最高优先级）到19（最低优先级）。</li><li>VIRT：虚拟内存使用量。进程使用的所有虚拟内存的和，包括进程使用的库，以及映射的文件和交换空间的大小。</li><li>RES：常驻内存大小。这是进程当前使用的、未被调出的物理内存量，单位通常是KB。</li><li>SHR：共享内存大小。这是多个进程可能共享的内存部分，通常包括库等。</li><li>S：进程的状态。通常的状态有：<ul><li>S（睡眠中）：等待事件完成（如输入/输出完成）。</li><li>R（运行中）：正在运行或在运行队列中等待。</li><li>T（停止）：进程已停止执行。</li><li>Z（僵尸）：进程已终止，但其父进程尚未收到其终止状态。</li></ul></li><li>%CPU：CPU使用率。展示进程使用的CPU时间百分比，这个值是在最后一次更新的时候样本里CPU使用情况的近似值，可能超过100%在多核CPU的系统。</li><li>%MEM：内存使用率。该进程使用的物理内存和总物理内存的百分比。</li><li>TIME+：进程使用的CPU时间总计，格式通常为分钟:秒。</li><li>COMMAND：启动进程的命令名称。</li></ul><h2 id="top-技巧"><a href="#top-技巧" class="headerlink" title="top 技巧"></a>top 技巧</h2><p>终端执行 top 命令之后【也可后接一些选项，比如 top -p 1 只监控 init 进程，top -u root 只显示 root 运行进程等等】，可以敲击如下按键，实现不同功能：</p><ul><li>h：获取 top 的命令帮助</li><li>1（数字1）：列出所有的单个 CPU 负载情况</li><li>z：top 显示颜色<ul><li>x：类似高亮显示，在 z 模式下使用</li></ul></li><li>P[大写]：按 CPU 占用高低顺序列出程序</li><li>M[大写]：按内存占用高低顺序列出程序</li><li>c：显示进程命令的全路径与参数</li><li>H：显示线程，默认只显示进程</li><li>top 默认按 cpu 占用排序，按F（大写）即可选择相应排序</li><li>d：top 默认刷新时间是 3s ，使用d键可自定义刷新时间</li><li>top 选择列排序[高到低]的方法[在z颜色和x高亮模式下显示效果明显]：<ul><li>shift+&lt;：左选</li><li>shift+&gt;：右选</li></ul></li><li>f：可以指定 top 显示的内容，如 ppid、swap 等都可以选择显示<ul><li>显示 Swap 利用率：按 f 键，然后按 p 键，回车即可看到 Swap 状态</li></ul></li><li>k：输入 k 之后可以 kill 掉指定的进程</li><li>A：分类显示各种系统资源高的进程。可用于快速识别系统上的性能要求极高的任务，推荐使用</li><li>W[大写]:将当前设置写入 ~/.toprc 文件中。这是写 top 配置文件的推荐方法</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/linuxwiki/SourceWiki/blob/master/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/top.md">SourceWiki-性能调优-top.md</a></li><li><a href="http://linux.vbird.org/">鸟哥Linux私房菜</a> </li><li><a href="http://www.cyberciti.biz/tips/top-linux-monitoring-tools.html">top - Process Activity Command</a></li><li><a href="http://how-to.linuxcareer.com/learning-linux-commands-top">Learning Linux Commands: top</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;top 命令是 linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用使用情况，类似于 windos 的任务窗口。&lt;/p&gt;
&lt;h2 id=&quot;top-理论&quot;&gt;&lt;a href=&quot;#top-理论&quot; class=&quot;headerlink&quot; title=&quot;top 理论&quot;</summary>
      
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
