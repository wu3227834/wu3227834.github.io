<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pudding 日常</title>
  <icon>https://www.gravatar.com/avatar/00dc32454135c01a0b80be2cbf59b5ab</icon>
  <subtitle>a week is 2% of the year</subtitle>
  <link href="https://wu3227834.github.io/atom.xml" rel="self"/>
  
  <link href="https://wu3227834.github.io/"/>
  <updated>2025-09-07T13:28:04.084Z</updated>
  <id>https://wu3227834.github.io/</id>
  
  <author>
    <name>Pudding</name>
    <email>wu3227834@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>摄影简单构图思路</title>
    <link href="https://wu3227834.github.io/2025/08/31/2025-08-31-she-ying-jian-dan-gou-tu-si-lu/"/>
    <id>https://wu3227834.github.io/2025/08/31/2025-08-31-she-ying-jian-dan-gou-tu-si-lu/</id>
    <published>2025-08-31T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.084Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单构图（一）-左右分法"><a href="#简单构图（一）-左右分法" class="headerlink" title="简单构图（一）- 左右分法"></a>简单构图（一）- 左右分法</h2><p>大家可能听说过拍风景的三分法，又或者传统的黄金分割…… 可能对不少人来说，在观景窗去判断一些比较复杂的构图法则是一件苦差。</p><p>所以这里说的简单构图，就是简单得…… 只看一次，就学会了，下次就懂得怎么去拍。</p><p>我们的简单教学不是要大家学完就拍得很 dramatic 很特別，但是学会了以后，至少拍得还过得去。</p><p>这次先说的是<strong>左右分</strong>。</p><h3 id="横幅的做法"><a href="#横幅的做法" class="headerlink" title="横幅的做法"></a>横幅的做法</h3><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image.jpg" alt="橫幅图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image2.jpg" alt="橫幅图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image3.jpg" alt="橫幅图3"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image4.jpg" alt="橫幅图4"></p><p>你可以看到，主体通常会占了其中一边大部分的位置，主体是上下居中的，它的周围仍然会占用适量的空间，然而画面其他位置的地方都会尽量的简化，那么主体就会被凸显出来，令观众的眼睛停留在主图面上。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/left.jpg" alt="左边构图"></p><center> 左边构图 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/right.jpg" alt="右边构图"></p><center> 右边构图 </center><h3 id="直幅的做法"><a href="#直幅的做法" class="headerlink" title="直幅的做法"></a>直幅的做法</h3><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image5.jpg" alt="直幅图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image6.jpg" alt="直幅图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image7.jpg" alt="直幅图3"></p><p>直幅的做法大致和横幅差不多，可是在处理主体上则有少许不同。横幅的做法会是，把主体上下置中，完好的安放在构图的左/右方。然而因为直幅的阔度很窄，你很难去把主体完完整整的放进图片里。否则很有可能主体会有很大概率失去它在图片中的主要性，得不偿失，所以，我们可以把主题的边缘部分跳出框架，把它们从构图中拿走。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/top_left.jpg" alt="top_left"></p><center> 左边构图 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/top_right.jpg" alt="top_right"></p><center> 右边构图 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image8.jpg" alt="直幅图4"></p><p>有些时候，想夸大图片的效果，突出主体的重要性（如上图），那你可以把主题占照片的比例增加，也就是把跳出框架的部分增加。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/top_left_big.jpg" alt="top_left_big"></p><center> 把主体在图片中的占有率增加 </center><h2 id="简单构图（二）-二三分法"><a href="#简单构图（二）-二三分法" class="headerlink" title="简单构图（二）- 二三分法"></a>简单构图（二）- 二三分法</h2><p>很多朋友都知道风景构图的其中一种技巧三分法，其实很多时候我们不止可以三分，还可以简单的二分，又或者更细微的八九分。</p><p>当然，在这里不会由二到九的详细介绍，其实他们都大同小异，只要明白一两个例子，就可以完整的套用在另一个方法里。</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>二分，显而易见就是把图面一开二，也就是人们常说的<strong>天一半地一半</strong>，通常这构图的方式是用在风景照里，同样的，也可以用再前后景明显的图画里。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/hori.jpg" alt="hori"></p><center> 横幅 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/vert.jpg" alt="vert"></p><center> 直幅 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image9.jpg" alt="二分构图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image10.jpg" alt="二分构图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image11.jpg" alt="二分构图3"></p><h3 id="二分法变种"><a href="#二分法变种" class="headerlink" title="二分法变种"></a>二分法变种</h3><p>所谓的二分法变种，就是把二分法的比例稍作改动，意思就是可能天的一半多一点，地的那一半少一点空间，或者相反。作用是可以把焦点侧重于其中一部分，把最好的那个目光投射到观众的眼睛里。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image12.jpg" alt="二分变种构图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image13.jpg" alt="二分变种构图2"></p><h3 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h3><p>三分法的应用，通常的情况会是用于一些有前、中、后景的环境里。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/hori3.jpg" alt="hori3"></p><center> 横幅 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/vert3.jpg" alt="vert3"></p><center> 直幅 </center><p>三分构图方式能够带出照片的前中后三金发的关联性，可增加照片的立体观感，若在不影响照片阅读性的情况下，可适当的加减景深令照片更富有层次感。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image14.jpg" alt="三分构图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image15.jpg" alt="三分构图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image16.jpg" alt="三分构图3"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image17.jpg" alt="三分构图4"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image18.jpg" alt="三分构图5"></p><h2 id="简单构图（三）-简易黄金比"><a href="#简单构图（三）-简易黄金比" class="headerlink" title="简单构图（三）- 简易黄金比"></a>简单构图（三）- 简易黄金比</h2><p>黄金比例是一个广泛使用的教学用词。自古希腊时代开始，一直被人类认为是美的代表…… 而在艺术上也是。</p><h3 id="黄金比的起源"><a href="#黄金比的起源" class="headerlink" title="黄金比的起源"></a>黄金比的起源</h3><p>很多人常说“没有数学就没有艺术”，其中所指便是黄金比例的发现。黄金比约为 1:1.618。早在古希腊时期，建筑师已将其应用于神殿设计，如帕特农神庙。到了文艺复兴时期，达·芬奇更发现这一比例与人体结构存在密切联系。随着人类理解的深化，黄金比逐渐被广泛运用于建筑、艺术乃至自然美学之中。</p><p>好，大概的资料到此为止，入正题了。</p><h3 id="黄金构图法则"><a href="#黄金构图法则" class="headerlink" title="黄金构图法则"></a>黄金构图法则</h3><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image19.jpg" alt="黄金构图1"></p><p>一般来说，当运用在摄影中时的黄金比，其实说直白一点，就是三分法和左右分法的混合体。</p><p>为什么呢？让我们一起来看看吧</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image20.jpg" alt="黄金构图2"></p><p>我们先从制作一个黄金分法开始</p><p>首先，我们把普通的一张 3:2 的图片，用对角线一分为二。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/step1.jpg" alt="黄金分法1"></p><p>接着，从每个角落的三角形里，拉一条与刚才对角线垂直的直线。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/step2.jpg" alt="黄金分法2"></p><p>最后，把这四条垂线的交点连起来，就会得到一个九宫格。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/step3.jpg" alt="黄金分法3"></p><p>注意，那其实不是平均分配的哦！不过，当我们在实际应用的时候，谁会记得他们不是平均的。所以一般对焦屏中的九宫格，都是平均的。</p><p>好，所以说九宫格就是黄金比喽？</p><p>嗯，当我们要构图的时候，试一下把焦点，落在那四个交接点上面，我们就称这类为黄金分割法。</p><p>像以下这些就是在不知不觉中，渗入了九宫格式构图的照片。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image21.jpg" alt="黄金构图3"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image22.jpg" alt="黄金构图4"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image23.jpg" alt="黄金构图5"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image24.jpg" alt="黄金构图6"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image25.jpg" alt="黄金构图7"></p><p>那……是否每一张照片使用黄金比例就会很好看呢？</p><p>这当然不一定啦！一张好照片的构成因素其实有很多，所谓的黄金比，其实只是为大家提供一种比较容易把握的构图的方式而已。当你熟悉并习惯运用后，便能在此基础上自由变化，创造出更具个人风格的作品 o(<em>￣▽￣</em>)ブ</p><h2 id="简单构图（四）-物件居中"><a href="#简单构图（四）-物件居中" class="headerlink" title="简单构图（四）- 物件居中"></a>简单构图（四）- 物件居中</h2><p>这篇东西是思前想后所写出来的，因为把构图居中，大概每个人都懂。所以本篇说的重点是之中物体于画面比例的关联性。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image26.jpg" alt="居中构图1"></p><h3 id="简单图画的处理"><a href="#简单图画的处理" class="headerlink" title="简单图画的处理"></a>简单图画的处理</h3><p>如果说图画有透视感的，人的焦点就会自然落在透视点的位置。如果图画是一个相对平面，没有太多线条所影响的话，人所寻找的胶片，通常第一点，都会落左中心点附近的地方。</p><p>所以这里构图方式，很适合一些简朴的画面，如上图一样，只有一个物件，和一个色彩的背景。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image27.jpg" alt="居中构图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image28.jpg" alt="居中构图3"></p><p>但这是必然的吗? 并不是。只是在这情况下，这里构图的办法是比较常用而已，像下图这种比较复杂的其实也是可以的。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image29.jpg" alt="居中构图4"></p><h3 id="置中物件跟背景比例的关系"><a href="#置中物件跟背景比例的关系" class="headerlink" title="置中物件跟背景比例的关系"></a>置中物件跟背景比例的关系</h3><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image30.jpg" alt="居中构图5"></p><p>相信拍了一段时间的朋友，不难会发现一件事：就是主体的大小，跟画面出来的感觉，彼此一样很重要的关联；这就是距离感。</p><p>像上图来说，是相隔一条街的拍摄效果，从画面上那人占的比例来说，好像并不是距离太远而已。这，可能会令人自不然联想起，原来他跟我们其实好近，可能下一步就是要走过来似的；</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image31.jpg" alt="居中构图6"></p><p>相反这一张，白衣的朋友，在画面中占的比例好像很小，乍一看的感觉是满遥远的；所以，就算她想走过来，也需要一段时间吧。这就是距离感上的分别。</p><p>而周边的空间扩大了，主体的比例小了一些；在画面上看起来，主体的影响力也会相对的小一点。这类的作法也常见于营造疏离感觉的照片当中。</p><p>所以，或者有些时候，我们可以把距离感，说成是一种 亲近 与 疏离 的分别。</p><p>这是亲近的：</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image32.jpg" alt="居中构图7"></p><p>这也许是中立的，不远，也不近：</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image33.jpg" alt="居中构图8"></p><p>这是远离的，就像是在一旁静静的看别处的人的动静似的：</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image34.jpg" alt="居中构图9"></p><h3 id="尝试跟其他方法交叉运用"><a href="#尝试跟其他方法交叉运用" class="headerlink" title="尝试跟其他方法交叉运用"></a>尝试跟其他方法交叉运用</h3><p>大斜线的构图方式：</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image35.jpg" alt="居中构图10"></p><p>这张也是，画面焦点中二人的剪影，跟背景喷泉形成了强烈的对比</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image36.jpg" alt="居中构图11"></p><h3 id="Dos-and-Don’ts"><a href="#Dos-and-Don’ts" class="headerlink" title="Dos and Don’ts"></a>Dos and Don’ts</h3><p>简单的说说，一些可以尝试一下的 Dos and Don’ts</p><h4 id="Dos"><a href="#Dos" class="headerlink" title="Dos"></a>Dos</h4><ul><li>可以从九宫格的中心格开始，移前一点，移后一点，进行构图上的试行</li><li>尝试多跟画面呈水平的状态，这会比较易拍出效果</li><li>遇到有透视感觉的画面的时候，不妨试一下置中的构图，可能会有意想不到的效果</li></ul><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image37.jpg" alt="居中构图12"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image38.jpg" alt="居中构图13"></p><h4 id="Don’ts"><a href="#Don’ts" class="headerlink" title="Don’ts"></a>Don’ts</h4><ul><li>置中的主体，不要太小，也不要太大；这会很难拍得好的，虽然这不是 100% 的定律</li></ul><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image39.jpg" alt="居中构图14"></p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><ul><li><a href="https://photalks.com/articles/25/%e7%b0%a1%e5%96%ae%e6%a7%8b%e5%9c%96-%e4%b8%80-%e5%b7%a6%e5%8f%b3%e5%88%86%e6%b3%95/">簡單構圖-一-左右分法</a></li><li><a href="https://photalks.com/articles/44/%e7%b0%a1%e5%96%ae%e6%a7%8b%e5%9c%96-%e4%ba%8c-%e4%ba%8c%e4%b8%89%e5%88%86%e6%b3%95/">簡單構圖-二-二三分法</a></li><li><a href="https://photalks.com/articles/567/%e7%b0%a1%e5%96%ae%e6%a7%8b%e5%9c%96-%e4%b8%89-%e7%b0%a1%e6%98%93%e9%bb%83%e9%87%91%e6%af%94/">簡單構圖-三-簡易黃金比</a></li><li><a href="https://photalks.com/articles/612/%e7%b0%a1%e5%96%ae%e6%a7%8b%e5%9c%96-%e5%9b%9b-%e7%89%a9%e4%bb%b6%e7%bd%ae%e4%b8%ad/">簡單構圖-四-物件置中</a></li></ul>]]></content>
    
    
    <summary type="html">探索摄影简单构图技巧，包括左右分法、二三分法、黄金比及物件居中，助你快速掌握构图要领，拍出吸引人的照片。</summary>
    
    
    
    
    <category term="摄影笔记" scheme="https://wu3227834.github.io/tags/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/"/>
    
    <category term="构图" scheme="https://wu3227834.github.io/tags/%E6%9E%84%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>async-profiler</title>
    <link href="https://wu3227834.github.io/2025/08/13/2025-08-13-async-profiler/"/>
    <id>https://wu3227834.github.io/2025/08/13/2025-08-13-async-profiler/</id>
    <published>2025-08-13T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.084Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章介绍了 jvm 中的安全点机制，以及为什么（大多数）分析器都很难用。这篇文章介绍一下 async-profiler 这个工具。</p><p>这个项目是一个针对 Java 的低开销采样性能分析器，不受 Safepoint 偏差问题的影响。它具有 HotSpot 特定的 API, 用于收集堆栈跟踪和跟踪内存分配。该性能分析器可与 OpenJDK 和其他基于 HotSpot JVM 的 Java 运行时配合使用。<br>项目文档地址：<a href="https://github.com/async-profiler/async-profiler/tree/master/docs">async-profiler/docs/</a></p><h2 id="性能分析模式"><a href="#性能分析模式" class="headerlink" title="性能分析模式"></a>性能分析模式</h2><p>除了 CPU 时间，async-profiler 还提供了各种其他性能分析模式，如 Allocation, Wall Clock, Java Method，甚至是 Multiple Events 性能分析模式。</p><h3 id="CPU-分析"><a href="#CPU-分析" class="headerlink" title="CPU 分析"></a>CPU 分析</h3><p>在这种模式下，性能分析器收集栈跟踪样本，其中包括 <strong>Java 方法、原生调用、JVM 代码和内核函数</strong>。</p><p>通用方法是接收 <code>perf_events</code> 生成的调用栈，并将它们与 AsyncGetCallTrace 生成的调用栈进行匹配，以生成 Java 和本机代码的准确性分析。此外，Async-profiler 提供了一种解决方案，用于在 <code>AsyncGetCallTrace</code> 失败的<a href="https://bugs.openjdk.org/browse/JDK-8178287">某些案例情况</a>恢复栈跟踪。</p><p>与直接在 Java 代理中使用 <code>perf_events</code> 相比，这种方法具有以下优势，后者可以将地址转换为 Java 方法名称：</p><ul><li>不需要 <code>-XX:+PreserveFramePointer</code>, 这会引入性能开销，有时高达 10%</li><li>不需要在 JVM 开始时使用代理将 Java 代码地址转换为方法名称</li><li>显示解释器帧</li><li>不会生成大型中间文件（perf.data），一边在用户空间脚本中进一步处理</li></ul><p>如果希望在 libjvm 中解析帧，则需要使用调试符号。</p><h2 id="ALLOCATION-性能分析"><a href="#ALLOCATION-性能分析" class="headerlink" title="ALLOCATION 性能分析"></a>ALLOCATION 性能分析</h2><p>可以将性能呢分析器配置为收集分配了最大量堆内存的调用站点。</p><p>Async-profiler 不使用字节码探测或昂贵的 DTrace 探针等侵入性技术，这些技术对性能有显著影响。它也不影响 Escape Analysis 或阻止 JIT 优化 (如分配消除)。只测量实际的堆分配。</p><p>性能分析器具有 TLAB(Thread Local Allocation Buffer, 线程本地分配缓存) 驱动的采样功能。它依赖于 HotSpot 特定的回调来接收两种类型的通知：</p><ul><li>当在新创建的 TLAB 中分配对象时</li><li>当在 TLAB 之外的慢速路径上分配对象时</li></ul><p>可以使用 <code>--alloc</code> 选项调整采样间隔。例如 <code>--alloc 500k</code> 将在平均分配空间 500KB 后采样一次。在 JDK 11 之前，小于 TLAB 大小的间隔不会生效。</p><p>在分配分析模式下，每个调用跟踪的顶帧是分配对象的类，计数器是堆压力（分配的 TLAB 或 TLAB 外对象的总大小）。</p><h2 id="Native-memory-leaks"><a href="#Native-memory-leaks" class="headerlink" title="Native memory leaks"></a>Native memory leaks</h2><p>性能分析模式 <code>nativemem</code> 记录 <code>malloc</code>、<code>relloc</code>、<code>calloc</code> 和 <code>free</code> 地址，以便将分配与空闲调用进行匹配。这有助于将性能分析报告仅集中在非空闲分配上，这些分配可能是内存泄漏的来源。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asprof start -e nativemem -f app.jfr &lt;YourApp&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line">asprof start --nativemem N -f app.jfr &lt;YourApp&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or <span class="keyword">if</span> only allocation calls are interesting, <span class="keyword">do</span> not collect free calls:</span></span><br><span class="line">asprof start --nativemem N --nofree -f app.jfr &lt;YourApp&gt;</span><br><span class="line"></span><br><span class="line">asprof stop &lt;YourApp&gt;</span><br></pre></td></tr></table></figure><p>现在我们需要处理 jfr 文件，以查找原生内存泄漏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--total <span class="keyword">for</span> bytes, default counts invocations.</span></span><br><span class="line">jfrconv --total --nativemem --leak app.jfr app-leak.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">No leak analysis, include all native allocations:</span></span><br><span class="line">jfrconv --total --nativemem app.jfr app-malloc.html</span><br></pre></td></tr></table></figure><p>当使用 <code>--leak</code> 选项时，生成的火焰图将显示未匹配免费调用的分配。</p><p><img src="/img/2025-08-13-async-profiler/nativemem_flamegraph.png" alt="火焰图"></p><p>为了避免对分析会话结束时未释放的最新分配产生偏差，泄漏分析器会忽略分析期间最后10%的尾部分配。可以通过–tail选项调整尾部长度，该选项接受比率或百分比（%）作为参数。例如，要忽略10分钟分析中最后2分钟的分配，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jfrconv --nativemem --leak --tail 20% app.jfr app-leak.html</span><br></pre></td></tr></table></figure><p>原生内存分析的开销取决于原生分配的数量，但通常对生产环境来说也足够小。如果需要，可以通过配置分析间隔来降低开销。例如，添加 <code>nativemem=1m</code> 的分析器选项后，分配样本将限制为每分配 1MB 最多一个样本。</p><h2 id="Wall-clock-分析"><a href="#Wall-clock-分析" class="headerlink" title="Wall-clock 分析"></a>Wall-clock 分析</h2><p><code>-e wall</code> 选项告诉 async-profiler 在给定时间段内平等地采样所有线程，而不考虑线程状态：运行、睡眠或阻塞。例如，这在分析应用程序启动时间时可能会很有帮助。</p><p>Wall-clock 分析器在每线程模式（<code>-t</code>）下最有用。</p><p>示例：<code>asprof -e wall -t -i 50ms -f result.html 8983</code></p><h2 id="Lock-分析"><a href="#Lock-分析" class="headerlink" title="Lock 分析"></a>Lock 分析</h2><p><code>-e lock</code> 选项告诉 async-profiler 测量已分析应用程序中的锁争用。锁性能分析可以帮助开发人员了解锁获取模式、锁争用（当线程需要等待获取锁时）、等待锁花费的时间以及哪些代码路径因锁而被阻塞。</p><p>在锁分析模式中，顶部帧是锁/监视器类，计数器是进入该锁/监视器所需要的纳秒数。</p><p>示例：<code>asprof -e lock -t -i 5ms -f result.html 8983</code></p><h2 id="Java-方法分析"><a href="#Java-方法分析" class="headerlink" title="Java 方法分析"></a>Java 方法分析</h2><p><code>-e ClassName.methodName</code> 选项检测给定的 Java 方法，以记录对该方法的所有调用以及栈跟踪。</p><p>示例：<code>-e java.util.Properties.getProperty</code> 将分析调用 getProperty 方法的所有位置。</p><p>仅支持非原生 Java 方法。要分析原生方法，请改用硬件断电时间，例如 <code>-e Java_java_lang_Throwable_fillInStackTrace</code>。<strong>请注意</strong>，如果在运行时附加异步配置文件，非原生 Java 方法的第一次插桩可能会导致所有编译的方法去优化。虽有的插桩只会刷新依赖代码。</p><p>如果将 async-profiler 作为代理附加，则不会发生大规模的 CodeCache 刷新。</p><h2 id="Native-function-分析"><a href="#Native-function-分析" class="headerlink" title="Native function 分析"></a>Native function 分析</h2><p>以下是一些可以分析的 Native function：</p><ul><li><code>G1CollectedHeap::humongous_obj_allocate</code> - 跟踪 G1 GC 的巨大分配</li><li><code>JVM_StartThread</code> - 跟踪新 Java 线程的创建</li><li><code>Java_java_lang_ClassLoader_defineClass1</code> - 跟踪类加载</li></ul><h2 id="Multiple-events"><a href="#Multiple-events" class="headerlink" title="Multiple events"></a>Multiple events</h2><p>可以同时分析 CPU、分配和锁。除了 CPU，还可以选择任何其他执行事件：wall-clock, perf event, tracepoint, Java method 等等</p><p>唯一支持多个事件同时分析的输出格式是 JFR。记录将包含以下事件类型：</p><ul><li><code>jdk.ExecutionSample</code></li><li><code>jdk.ObjectAllocationInNewTLAB</code> (alloc)</li><li><code>jdk.ObjectAllocationOutsideTLAB</code> (alloc)</li><li><code>jdk.JavaMonitorEnter</code> (lock)</li><li><code>jdk.ThreadPark</code> (lock)</li></ul><p>如果分析 cpu + allocations + locks，可以指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof -e cpu,alloc,lock -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>或者使用 <code>--alloc</code> 和 <code>--lock</code> 参数并设置所需的阈值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof -e cpu --alloc 2m --lock 10ms -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>同样，当将分析器作为代理启动时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentpath:/path/to/libasyncProfiler.so=start,event=cpu,alloc=2m,lock=10ms,file=profile.jfr</span><br></pre></td></tr></table></figure><h2 id="使用-–all-进行多事件分析"><a href="#使用-–all-进行多事件分析" class="headerlink" title="使用 –all 进行多事件分析"></a>使用 –all 进行多事件分析</h2><p><code>--all</code> 标志提供了一个同时启动预定义的常见性能分析时间集合方法。默认情况下，<code>--all</code> 会激活 cpu、wall、alloc、lock 和 nativemem。</p><p><strong>注意</strong>：虽然 <code>--all</code> 标志对于开发环境来说可以用于获得广泛的概述，但不建议在生产环境中启动它，尤其是对于持续性能分析。用户需要仔细选择要分析的内容以及使用哪些设置。</p><p><strong>示例</strong>：下面这个命令启用了 <code>--all</code> 中包含的默认事件集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>或者结合 <code>--alloc</code>/<code>--wall</code>/<code>--lock</code>/<code>--nativemem</code> 选项来覆盖单个设置。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all --alloc 2m --lock 10ms -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>同样，当将性能分析器作为代理启动时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentpath:/path/to/libasyncProfiler.so=start,event=all,alloc=2m,lock=10ms,file=profile.jfr</span><br></pre></td></tr></table></figure><p>可以用你选择的任何其他事件类型来覆盖 <code>--all</code> 参数，而不是 <code>cpu</code>。例如，以下命令将分析循环以及 <code>wall</code>, <code>alloc</code>, <code>live</code>, <code>lock</code> 和 <code>nativemem</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all -e cycles -f profile.jfr</span><br></pre></td></tr></table></figure><h2 id="连续性能分析"><a href="#连续性能分析" class="headerlink" title="连续性能分析"></a>连续性能分析</h2><p>持续性能分析是一种可以持续性能分析应用程序并在每个指定时间段转储性能分析结果的方法。这是一种主动且高效地发现性能下降的非常有效的技术。持续性能分析有助于用户了解同一应用程序各版本之间的性能差异。可以将最近的输出与持续性能分析的输出历史记录进行比较，以找出差异并优化性能下降情况下引入的变更。aysnc-profiler 提供了使用循环选项持续性能分析应用程序的能力。确保文件名包含时间戳模式，否则输出将在每次迭代中被覆盖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --loop 1h -f /var/log/profile-%t.jfr 8983</span><br></pre></td></tr></table></figure><h2 id="perf-event-types-supported-on-Linux"><a href="#perf-event-types-supported-on-Linux" class="headerlink" title="perf event types supported on Linux"></a>perf event types supported on Linux</h2><table><thead><tr><th>Usage</th><th>Description</th></tr></thead><tbody><tr><td>Predefined:</td><td></td></tr><tr><td><code>-e cpu-clock</code></td><td>High-resolution per-CPU timer. Similar to <code>-e cpu</code> but forces using perf_events.</td></tr><tr><td><code>-e page-faults</code></td><td>Software page faults</td></tr><tr><td><code>-e context-switches</code></td><td>Context switches</td></tr><tr><td><code>-e cycles</code></td><td>Total CPU cycles</td></tr><tr><td><code>-e instructions</code></td><td>Retired CPU instructions</td></tr><tr><td><code>-e cache-references</code></td><td>Cache accesses (usually Last Level Cache, but may depend on the architecture)</td></tr><tr><td><code>-e cache-misses</code></td><td>Cache accesses requiring fetching data from a higher-level cache or main memory</td></tr><tr><td><code>-e branch-instructions</code></td><td>Retired branch instructions</td></tr><tr><td><code>-e branch-misses</code></td><td>Mispredicted branch instructions</td></tr><tr><td><code>-e bus-cycles</code></td><td>Bus cycles</td></tr><tr><td><code>-e L1-dcache-load-misses</code></td><td>Cache misses on Level 1 Data Cache</td></tr><tr><td><code>-e LLC-load-misses</code></td><td>Cache misses on the Last Level Cache</td></tr><tr><td><code>-e dTLB-load-misses</code></td><td>Data load misses on the Translation Lookaside Buffer</td></tr><tr><td>Breakpoint:</td><td></td></tr><tr><td><code>-e mem:&lt;addr&gt;</code></td><td>Breakpoint on a decimal or hex (0x) address</td></tr><tr><td><code>-e mem:&lt;func&gt;</code></td><td>Breakpoint on a public or a private symbol</td></tr><tr><td><code>-e mem:&lt;func&gt;[+&lt;offset&gt;][/&lt;len&gt;][:rwx&gt;]</code></td><td>Breakpoint on a symbol or an address with offset, length and read/write/exec. Address, offset and length can be hex or dec. The format of <code>mem</code> event is the same as in <a href="https://man7.org/linux/man-pages/man1/perf-record.1.html"><code>perf-record</code></a>.</td></tr><tr><td><code>-e &lt;symbol&gt;</code></td><td>Equivalent to an execution breakpoint on a symbol: <code>mem:&lt;symbol&gt;:x</code>. Example: <code>-e strcmp</code> will trace all calls of native <code>strcmp</code> function.</td></tr><tr><td>Tracepoint:</td><td></td></tr><tr><td><code>-e trace:&lt;id&gt;</code></td><td>Kernel tracepoint with the given numeric id</td></tr><tr><td><code>-e &lt;tracepoint&gt;</code></td><td>Kernel tracepoint with the specified name. Example: <code>-e syscalls:sys_enter_open</code> will trace all <code>open</code> syscalls.</td></tr><tr><td>Probes:</td><td></td></tr><tr><td><code>-e kprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Kernel probe. Example: <code>-e kprobe:do_sys_open</code>.</td></tr><tr><td><code>-e kretprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Kernel return probe. Example: <code>-e kretprobe:do_sys_open</code>.</td></tr><tr><td><code>-e uprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Userspace probe. Example: <code>-e uprobe:/usr/lib64/libc-2.17.so+0x114790</code>.</td></tr><tr><td><code>-e uretprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Userspace return probe</td></tr><tr><td>PMU:</td><td></td></tr><tr><td><code>-e r&lt;NNN&gt;</code></td><td>Architecture-specific PMU event with the given number. Example: <code>-e r4d2</code> selects <code>MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM</code> event, which corresponds to event 0xd2, umask 0x4.</td></tr><tr><td><code>-e &lt;pmu descriptor&gt;</code></td><td>PMU event descriptor. Example: <code>-e cpu/cache-misses/</code>, <code>-e cpu/event=0xd2,umask=4/</code>. The same syntax can be used for uncore and vendor-specific events, e.g. <code>amd_l3/event=0x01,umask=0x80/</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">async-profiler 是一个低开销 Java 性能分析器，规避 Safepoint 偏差，支持 CPU、内存分配、锁争用等多种分析模式，适用于 HotSpot JVM，提供精确的栈跟踪和内存泄漏检测。</summary>
    
    
    
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
    <category term="Profiler" scheme="https://wu3227834.github.io/tags/Profiler/"/>
    
  </entry>
  
  <entry>
    <title>为什么（大多数）取样 javaprofiler 都很难用</title>
    <link href="https://wu3227834.github.io/2025/08/12/2025-08-12-wei-shi-me-da-duo-shu-qu-yang-javaprofiler-du-hen-nan-yong/"/>
    <id>https://wu3227834.github.io/2025/08/12/2025-08-12-wei-shi-me-da-duo-shu-qu-yang-javaprofiler-du-hen-nan-yong/</id>
    <published>2025-08-12T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一篇英文翻译转载文章，主要介绍了 javaprofiler 的工作原理。<br><br>原英文链接：<a href="https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html">https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html</a><br></p></blockquote><p>这篇文章建立在之前的一篇<a href="https://wu3227834.github.io/2025/08/12/2025-08-12-jian-shu-jvm-zhong-de-an-quan-dian-ji-zhi/">关于安全点的文章</a>的基础上。如果你没有读过它，你可能会感到迷茫和困惑。如果你读过这篇文章，仍然感到迷茫和困惑，并且您确定这种感觉与当前的问题有关（而不是生存危机），请继续提问。</p><p>那么，既然我们已经确定了什么是安全点，那么：</p><ol><li>安全点轮询分散在相当多的任意点（取决于执行模式，主要是在未计数的循环后端或方法返回/入口）</li><li>将 JVM 带到全局安全点的成本很高</li></ol><p>我们已经掌握了所有需要的信息，可以得出结论，通过在安全点采样来进行剖析可能有点糟糕。这对于某些人来说并不奇怪，但是这个问题在最常见的分析器中是存在的。根据 RebelLabs 的调查，以下是详细情况：</p><p><img src="/img/2025-08-12-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%8F%96%E6%A0%B7javaprofiler%E9%83%BD%E5%BE%88%E9%9A%BE%E7%94%A8/which-profiler.png" alt="which-profiler"></p><p>VisualVM、NB Profiler（同上）、YourKit 和 JProfiler 都提供了一个 CPU 分析器，可以在安全点进行采样。鉴于这是一个相当常见的问题，让我们深入研究一下。</p><h2 id="采样执行探查器如何工作-理论上"><a href="#采样执行探查器如何工作-理论上" class="headerlink" title="采样执行探查器如何工作 (理论上)"></a>采样执行探查器如何工作 (理论上)</h2><p>抽样分析器应该通过收集应用程序在不同时间点所处位置的样本，来接近应用程序中“花费的时间”的分布。在每个样本中收集的数据可以是：</p><ul><li>current instruction</li><li>current line of code</li><li>current method</li><li>current stack trace</li></ul><p>数据可以为单个线程收集，也可以为每个样本中的所有线程收集。我们需要保存哪些数据才能进行有效的采样？</p><blockquote><p>然而，要使采样结果与完整（未采样）分析结果相媲美，必须满足以下两个条件。<br><strong>首先，我们必须拥有大量样本才能获得具有统计意义的结果。</strong>例如，如果一个分析器在整个程序运行过程中只收集了一个样本，那么该分析器会将程序执行时间的 100% 分配给它进行采样的代码，而将 0% 分配给其他所有代码。[…]<br><strong>其次，分析器应该以相同的概率对程序运行中的所有点进行采样。</strong>如果分析器不这样做，它的分析结果最终会出现偏差。例如，假设我们的分析器只能对包含调用的方法进行采样。即使不包含调用的方法可能占据了程序执行时间的很大一部分，该分析器也不会将执行时间分配给这些方法。<br>——摘自<a href="http://plv.colorado.edu/papers/mytkowicz-pldi10.pdf">《评估 Java 分析器的准确性》</a>，我们稍后会回到这篇文章。</p></blockquote><p>这听起来很简单，对吧？</p><p>一旦我们有了大量的样本，我们就可以构建一个热方法列表，甚至是这些方法中的代码行（如果样本报告了它），我们可以查看分布在调用树上的样本（如果收集了调用跟踪）并且度过一段美好的时光！</p><h2 id="通用商业-Java-采样执行分析器如何工作"><a href="#通用商业-Java-采样执行分析器如何工作" class="headerlink" title="通用商业 Java 采样执行分析器如何工作"></a>通用商业 Java 采样执行分析器如何工作</h2><p>好吧，我可以在这里从不同的解决方案进行逆向工程，或者通读开源代码库，但是我会提供一些没有支持的猜测，如果你知道更多的话，可以自由地告诉我。通用分析器依赖于 JVMTI(JVM Tool Interface) 规范，所有 jvm 都必须满足这一规范：</p><ul><li>JVMTI 仅提供安全点采样堆栈跟踪收集选项（调用线程的 GetStackTrace 不需要安全点，但对分析器来说用处不大；在 Zing 中，对其他线程调用 GetStackTrace 仅会将该线程带到安全点）。因此，希望其工具能在所有 JVM 上运行的厂商只能采用安全点采样方式。</li><li>无论你是在对单个线程进行采样还是对所有线程进行采样（至少在 OpenJDK 上是这样，Zing 略有不同，但作为分析工具供应商，你应假设使用的是 OpenJDK）。我所查看过的所有分析工具都采用对所有线程进行采样的方式。据我所知，它们也不会限制收集的堆栈深度。这相当于以下 JVMTI 调用：JvmtiEnv:：GetAllStackTraces (0，&amp;stack_info，&amp;thread_count)</li><li>因此，这相当于：设置一个定时线程，每隔 ‘sampling_interval’ 时间触发一次，并收集所有的堆栈跟踪信息。</li></ul><p>这有几个坏处，其中一些可以避免的：</p><ol><li>采样分析器需要采样，因此通常会将采样频率设置得相当高（通常为每秒 10 次，或每 100 毫秒一次）。设置 <code>-XX:+PrintGCApplicationStoppedTime</code> 并查看这引入了什么样的暂停时间是有指导意义的。几毫秒的暂停并不罕见，但具体情况具体分析（取决于线程数、堆栈深度、TTSP 等）。每 100 毫秒暂停 5 毫秒意味着分析器会引入 5% 的开销（实际损失可能比这更严重）。通常可以通过设置更长的间隔来控制损失，但这也意味着你需要更长的分析周期才能获得有意义的样本计数。</li><li>从所有线程收集完整的栈跟踪意味着你的安全点操作成本是开发的。你的应用程序拥有的线程越多（想想应用程序服务器、SEDA 架构、大量线程池等），你的栈跟踪越深（想想 Spring 和 Co.），你的应用程序等待单个线程来回采集名称和填写表单的时间就越长。据我所知，当前的分析器对此毫无帮助。如果你正在构建自己的分析器，那么对数量设置限制似乎是明智的，这样你就可以控制开销。JVMTI 功能允许你查看当前线程列表，如果少于 100 个，你可以对所有的线程进行采样，否则可以随机选择 100 个线程的子集进行采样。也许更倾向于采样那些实际在做某事的线程，而不是那些整天被阻塞的线程，这是有道理的。</li><li>仿佛这一切还不够糟糕似的，其实我感觉在安全点进行抽样似乎也有些毫无意义</li></ol><p>第 1 点和第 2 点是关于剖析开销的，这基本上是关于成本的。在我之前关于安全点的文章中，我查看了这些成本，所以没有必要重复这个练习。对于良好的剖析信息，成本可能是可以接受的，但正如我们将看到的，这些信息并不那么重要。</p><p>第 3 点需要解释，所以我们开始寻找其含义。</p><h2 id="安全点采样：理论"><a href="#安全点采样：理论" class="headerlink" title="安全点采样：理论"></a>安全点采样：理论</h2><p>那么，在安全点进行采样意味着什么？这意味着只运行代码中的安全点轮询是可见的。考虑到热代码可能是由 C1/C2 (客户端/服务器编译器) 编译的，我们减少了方法退出和未经计数的循环备份的采样机会。这导致了所谓的安全点排查现象，即采样性能分析器的采样偏向于下一个可用的安全点轮询位置（这违反了上面列出的第二个标准“<strong>性能分析器应该以相对概率对程序运行中的所有点进行采样</strong>”）。</p><p>这乍听起来可能没那么糟糕，所以让我们通过一个简单的例子来看看哪一行收到了责备。</p><p><strong>注意</strong>：在以下所有示例中，我将使用 JMH 作为测试工具，并使用 “CompilerControl” 注释来防止内联。这就使我能够控制编译单元的限制，这可能看起来很残酷、不寻常，或者至少是不公平的。在“野生”环境中，内敛决策受到很多因素的影响，（在我看来）将它们视为任意的（在几个编译器/JVM供应商/命令行参数等的手中）是安全的。内联可能是“所有优化之母”，但它在这方面是一个反复无常且狡猾的长辈。</p><p>让我们看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Param(&quot;1000&quot;)</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">byte</span>[] buffer;</span><br><span class="line"><span class="type">boolean</span> result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setup</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotNoInline</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    b += buffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  result = b == <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// SP poll, method exit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotInline</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    b += buffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  result = b == <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// SP poll, method exit (removed when method is inlined)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个容易思考的例子。我们可以通过改变数组的大小来控制方法中的工作量。我们知道技术循环中没有安全点轮询（通过查看汇编输出验证），因此理论上，上述方法在方法退出时将有一个安全点。问题是，如果我们让上述方法内联，方法的末尾安全点轮询将消失，而下一轮轮询将在测试循环中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotInline_avgt_jmhStub</span><span class="params">(InfraControl control, RawResults result,</span></span><br><span class="line"><span class="params">    SafepointProfiling_jmhType l_safepointprofiling0_0, Blackhole_jmhType l_blackhole1_1)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">operations</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> <span class="variable">realTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  result.startTime = System.nanoTime();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    l_safepointprofiling0_0.meSoHotInline(); <span class="comment">/* LINE 163 */</span></span><br><span class="line">    operations++;</span><br><span class="line">    <span class="comment">// SP poll, uncounted loop</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!control.isDone); <span class="comment">/* LINE 165 */</span></span><br><span class="line">  result.stopTime = System.nanoTime();</span><br><span class="line">  result.realTime = realTime;</span><br><span class="line">  result.measuredOps = operations;</span><br><span class="line">  <span class="comment">// SP poll, method exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果测量方法没有内联，预期它会受到指责似乎是合理的，但如果它确实内联了，我们可以预期测量方法会受到指责。对吧？非常合理，但有点偏差。</p><h2 id="安全点采样：现实"><a href="#安全点采样：现实" class="headerlink" title="安全点采样：现实"></a>安全点采样：现实</h2><p>在这篇 2010 年发表的精彩论文<a href="http://plv.colorado.edu/papers/mytkowicz-pldi10.pdf">《评估 Java 性能分析器的准确性》</a>中，作者们讨论了安全点偏差。他们认识到，不用的 Java 性能分析器会在同一基准中识别不同的热点，并深入研究其原因。他们没有建立一些一直热点的基准，并利用这些基准来理解安全点偏差性能分析器所看到的内容。他们指出：</p><blockquote><p>如果我们知道程序运行的“正确”分析结果，我们就可以根据这个正确的分析结果来评估分析器。不幸的是，大多数情况下并不存在“正确”的分析结果，因此我们无法确切地确定分析器是否产生了正确的结果。</p></blockquote><p>那么，如果我们构建一个已知的工作负载…… 这些分析器会看到什么呢？</p><p>我们将使用 JMH 安全点偏置性能分析器 “-prof stack” 来研究这一点。它很像 JVisualIVM 提供的相同代码的性能分析，而且对于这项研究来说，它看起来更加方便。注意：在接下来的部分中，我是用术语 sub-method 来描述从另一个方法调用的方法。例如，如果方法 A 调用了方法 B，则 B 是 A 的子方法。也许存在更好的术语，但这就是我在这里的意思。</p><p>如果我们运行上面的示例，我们会得到两行不同的热线代码 (使用 <code>-prof stack:detailLine=true</code> 运行): </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Benchmark: safepoint.profiling.SafepointProfiling.meSoHotInline</span><br><span class="line">....[Thread state: RUNNABLE]...</span><br><span class="line"> <span class="number">99.6</span>%  <span class="number">99.8</span>% meSoHotInline_avgt_jmhStub:<span class="number">165</span></span><br><span class="line"></span><br><span class="line"># Benchmark: safepoint.profiling.SafepointProfiling.meSoHotNoInline</span><br><span class="line">....[Thread state: RUNNABLE]...</span><br><span class="line"> <span class="number">99.4</span>%  <span class="number">99.6</span>% meSoHotNoInline_avgt_jmhStub:<span class="number">163</span></span><br></pre></td></tr></table></figure><p>在实际的热点方法中没有这种情况。似乎方法退出安全点并不被认为是其自身方法的指示，而是被认为是调用它的代码行的指示。因此，强制测量中的方法不内联意味着测量循环中的调用代码行，而让它内联则意味着循环的后端受到责备。同样，似乎一个未计数的循环安全点轮询也被认为是其自身方法的指标。</p><p>我们可以推断（但不一定是正确的），当看到这种没有代码行数据的分析结果时，一个热点方法表示：</p><ol><li>某些非内联子方法是热点</li><li>在一个未计数的循环中，某些代码（自用方法？内联子方法？非内联子方法？）是热点</li></ol><p>拥有一行代码数据可以帮助消除上述情况的歧义，但作为一行代码数据并不是很有用。一行热点代码可能表示：</p><ol><li>该行有一个方法调用：从该行调用的方法（或者它的内联子方法）是热点</li><li>该行是一个循环的后端：这个循环中的一些代码（包括内联子方法）是热点</li></ol><p>这看起来有用么？别抱太大希望。</p><p>因为我们通常不知道哪些方法被内联了，这可能会有点令人困惑（如果你想知道，可以使用 <code>-XX:+PrintInlining</code>，但是要注意，内敛决策可能会随着运行而变化）</p><h2 id="注意间距"><a href="#注意间距" class="headerlink" title="注意间距"></a>注意间距</h2><p>如果上述规则成立，你可以通过检查执行树中被指责节点下方的代码来使用安全点偏差性分析。换句话说，这将意味着一个热点方法表名热点 diamagnetic 可能位于该代码或其调用的方法中的某处。了解这一点会很有帮助，这个分析可以作为一些有效挖掘的起点。但遗憾的是，这些规则并不总是成立。它们忽略了一个事实，即热点代码可能位于指定的安全点轮询和之前的轮询之间的热河位置。参考以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blameSetResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      b += buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    setResult(b); <span class="comment">/* LINE 38 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult(b == <span class="number">1</span>); <span class="comment">/* LINE 90 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    result = b;</span><br><span class="line">  &#125;</span><br><span class="line">....[Thread state: RUNNABLE]........................................................................</span><br><span class="line"> <span class="number">98.6</span>%  <span class="number">98.8</span>% safepoint.profiling.SafepointProfiling.setResult:<span class="number">90</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% sun.misc.Unsafe.unpark:-<span class="number">2</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% safepoint.profiling.SafepointProfiling.blameSetResult:<span class="number">38</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% safepoint.profiling.generated.SafepointProfiling_blameSetResult_jmhTest.blameSetResult_avgt_jmhStub:<span class="number">165</span></span><br></pre></td></tr></table></figure><p>显然，在调用 setResult 之前，时间是在循环中度过的，但分析结果会归咎于 setResult。setResult 没有任何问题，除了它调用方法不是内联的，这为我们的分析器提供了归咎的机会。这证明了安全点轮询机会呈现给用户代码的随机性，并表明热代码可能位于当前安全点轮询和上一个安全点轮询之间的任何位置。这意味着，如果不知道上一个安全点轮询的位置，那么在安全点偏向的分析结果中，热方法/代码行可能会产生误导。请考虑以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blameSetResultDeeper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      b += buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    setResult8(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult8</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult7(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult7</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult6(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult6</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult5(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult5</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult4(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult4</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult3(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult3</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult2(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult2</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult(b); <span class="comment">/* Line 86 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult(b == <span class="number">1</span>); <span class="comment">/* LINE 90 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    result = b;</span><br><span class="line">  &#125;</span><br><span class="line">....[Thread state: RUNNABLE]........................................................................</span><br><span class="line"> <span class="number">99.2</span>%  <span class="number">99.4</span>% safepoint.profiling.SafepointProfiling.setResult:<span class="number">90</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% safepoint.profiling.generated.SafepointProfiling_blameSetResultDeeper_jmhTest.blameSetResultDeeper_avgt_jmhStub:<span class="number">163</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% sun.misc.Unsafe.compareAndSwapInt:-<span class="number">2</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% safepoint.profiling.SafepointProfiling.setResult2:<span class="number">86</span></span><br></pre></td></tr></table></figure><p>分析器暗示调用者指向了堆栈下方 9 层的一个廉价方法，但真正的罪魁祸首是最顶层方法的循环。需要注意的是，内联会阻止方法显示，但非内联的框架只会在返回时打破安全点之间的间隙（无论如何，在 OpenJDK 上如此。这取决于供应商和用户的想法。例如，Zing 将方法级别的安全点放在入口处，我不确定 J9 对此持何种立场。这并不是说一种方法比另一种更好，只是说位置是任意的）。这就是为什么非内联且位于堆栈更高位置的 setResult6 没有显示的原因。</p><h2 id="总结：它有什么用"><a href="#总结：它有什么用" class="headerlink" title="总结：它有什么用"></a>总结：它有什么用</h2><p>如上所述，安全点采样分析器可能会对应用程序中的热点代码位置产生严重不准确的判断。这使得对“运行中”线程的衍生观察变得相当可疑，但至少对哪些线程正在运行的观察是正确的。这并不意味着它们完全没有用，有时候我们只需要一个正确的方向提示，就能进行一些好的分析，但这里也存在浪费时间的巨大风险。虽然在解释器中运行的代码样本不会受到安全点偏差的影响，但这并不是很有用，因为热点代码很快就会被编译。如果你的热点代码还在解释器中运行，那么你有比安全点偏差更大的问题需要解决……</p><p>阻塞线程的堆栈跟踪是准确的，因此 “Waiting” 状态分析对于发现阻塞代码的性能瓶颈非常有用。如果阻塞方法是你性能问题的根源，那么这一分析结果会是一个很重要的线索。</p><p>外面还有更好的选择！例如：</p><ul><li>Java Mission Control</li><li>Solaris Studio</li><li>Honest-Profiler</li><li>Perf + perf-map-agent (or perfasm if your workload is wrapped in a JMH benchmark)</li></ul><p>没有哪种工具是完美的，但上述所有工具在识别 CPU 时间花费方面都还不错。</p>]]></content>
    
    
    <summary type="html">本文探讨了Java采样分析器因安全点偏差导致的不准确性，分析其工作原理及局限性，揭示热点代码识别的误导性，并推荐更精准的工具，助开发者优化性能。</summary>
    
    
    
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简述 jvm 中的安全点机制</title>
    <link href="https://wu3227834.github.io/2025/08/12/2025-08-12-jian-shu-jvm-zhong-de-an-quan-dian-ji-zhi/"/>
    <id>https://wu3227834.github.io/2025/08/12/2025-08-12-jian-shu-jvm-zhong-de-an-quan-dian-ji-zhi/</id>
    <published>2025-08-12T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一篇英文翻译转载文章，主要介绍了 Safepoints。<br><br>原英文链接：<a href="https://psy-lob-saw.blogspot.com/2015/12/safepoints.html">https://psy-lob-saw.blogspot.com/2015/12/safepoints.html</a><br></p></blockquote><p>在过去的一年里，我做了几次关于性能分析和 JVM 运行时/执行的演讲，在这两次演讲中，我都发现自己遇到了安全点（Safepoint）这个话题。大多数人对安全点的存在一无所知，而我通常会在一屋子人中找到一两个对这个术语有所了解的开发人员。这并不令人惊讶，因为安全点并不是 Java 语言规范的一部分。但是，由于安全点是每一个 JVM 实现（据我所知）的一部分，并且扮演着重要角色，所以一下是我对这个概述的拙劣尝试。</p><h2 id="什么是-Safepoint"><a href="#什么是-Safepoint" class="headerlink" title="什么是 Safepoint?"></a>什么是 Safepoint?</h2><p>最近有人问我：“安全点是像安全词一样的东西吗？” 简短的回答是 “完全不是”，但因为我喜欢这个比喻，所以我会继续使用它：</p><p>想象一下，一个 JVM 里挤满了忙碌的变异线程（Mutator Threads），它们挥汗如雨地在堆上进行变异操作。有些线程甚至（天哪！）共享了可变状态。它们肆无忌惮地并发修改彼此的状态，简直像野兽一样。有些线程则躲在角落里独自修改自己的状态（迟早会把自己搞瞎）。突然，一块霓虹灯牌闪亮，上面写着 “PINEAPPLES”（Stop-the-World）。变异线程一个接一个停下它们在堆上的疯狂折腾，静静等待，汗水滴落。当最后一个变异线程停下时，一群精灵（gc）走了进来，清空烟灰缸，装满所有饮料，清理地上的水洼，然后以最快的速度消失，回到北极。霓虹灯牌熄灭，线程们又重新开始它们的狂欢 ……</p><p>在网上可以找到许多关于安全点的引用，接下来是我尝试使用更细致入微的内容，从这一点开始，不再使用 “汗流浃背的变异线程”。</p><ol><li>安全点（Safepoint）是指线程执行过程中，其状态能被清晰描述的一段范围。变异线程（Mutator Threads）是那些操作 JVM 堆的线程（所有 Java 线程都是变异线程，非 Java 线程在调用与堆交互的 JVM API 时也可能被视为变异线程）</li><li>在安全点上，变异线程与堆的交换处于一个已知且定义明确的状态。这意味着栈上的所有引用都被映射（位于已知位置），并且 JVM 能够完全追踪这些引用。只要线程保持在安全点，我们就可以安全地操作堆和栈，确保线程在离开安全点时，其对世界的识图保持一致</li></ol><p>这一机制在 JVM 需要检查或更改堆时尤为重要，例如进行垃圾回收（GC）或出于其他多种原因。如果栈上的引用未被追踪，而 JVM 执行垃圾回收，可能会错误地认为某些对象已不再存活（尽管它们仍被栈上的引用所指向）而将其回收，或者可能在移动某个对象时未更新栈上的引用，导致内存损坏。</p><p>因此，JVM 需要一种方法将线程带入安全点（并保持在安全点），以便执行各种运行时“魔法”操作。以下是 JVM 在所有变异线程到达安全点并被锁定（即全局安全点）时才能执行的部分活动列表，这些活动有时被称为安全点操作：</p><ul><li>Some GC phases (the Stop The World kind)</li><li>JVMTI stack sampling methods (not always a global safepoint operation for Zing)</li><li>Class redefinition</li><li>Heap dumping</li><li>Monitor deflation (not a global safepoint operation for Zing)</li><li>Lock unbiasing</li><li>Method deoptimization (not always)</li><li>And many more!</li></ul><p>Azul 公司的 John Cuthbertson 在 2014 年 JavaOne 大会上发表了一场精彩的演讲，详细介绍了安全点的背景以及除垃圾回收外的其他安全点操作细节（我们在 Azul 认为垃圾回收问题已解决，因此该演讲聚焦于其他需要暂停线程的原因）。</p><p>需要注意的是，请求全局安全点和线程安全点之间的区别仅在某些 JVM 实现中存在（例如Azul Systems的Zing JVM，提醒：我为Azul工作）。在 OpenJDK/Oracle JVM 中没有这种区别。这意味着 Zing 可以单独将某个线程带入安全点。</p><p>总结如下：</p><ul><li>安全点是 JVM 实现中的一个常见细节。</li><li>它们用于暂停变异线程，以便 JVM 进行“修复”操作。</li><li>在 OpenJDK/Oracle JVM 中，每次安全点操作都需要全局安全点。</li><li>所有当前 JVM 都有对全局安全点的某些需求。</li></ul><h2 id="我的线程什么时候处于安全点？"><a href="#我的线程什么时候处于安全点？" class="headerlink" title="我的线程什么时候处于安全点？"></a>我的线程什么时候处于安全点？</h2><p>因此，将线程置于安全点允许 JVM 继续进行其托管运行时的“魔法表演”，太棒了！这个酷炫的状态何时发生呢？</p><ul><li>如果一个 Java 线程被锁或同步块阻塞、等待监听器、驻留或在阻塞 IO 上阻塞，那么它就处于安全点。本质上，这些都是 Java 线程的有序调度事件，并且是将线程带到安全点之前进行整理的一部分</li><li>Java 线程在执行 JNI 代码时处于安全点。在跨越本机调用边界之前，堆栈保持一致状态，然后移交给本机代码。这意味着线程仍然可以在安全点上运行</li><li>执行字节码的 Java 线程不在安全点（或者至少 JVM 不能假定它在安全点）</li><li>被操作系统中断但不在安全点的 Java 线程在取消调度之前不会被带到安全点</li></ul><p>JVM 和正在运行的 Java 线程围绕安全点有以下关系：</p><ul><li>JVM 不能强制任何线程进入安全点状态</li><li>JVM 可以阻止线程离开安全点状态</li></ul><p>那么，JVM 如何将所有线程带入安全点状态呢？问题是需要将线程暂停在已知状态，而不仅仅是中断它。为了实现这一目标，JVM 让 Java 线程在方便的地方挂起自己，如果它们观察到一个 “安全点标志” 的话。</p><h2 id="将-Java-线程引入安全点"><a href="#将-Java-线程引入安全点" class="headerlink" title="将 Java 线程引入安全点"></a>将 Java 线程引入安全点</h2><p>Java 线程会以“合理”的间隔轮询“安全点标志”（可以是全局标志或线程级标志），并在观察到“进入安全点”标志时转换到安全点状态（线程在安全点被阻塞）。这听起来很简单，但为了避免频繁检查是否需要暂停，C1/C2编译器（即-client/-server JIT编译器）会尽量减少安全点轮询的次数。除了检查标志本身的开销外，维持“已知状态”还会显著增加某些优化实现的复杂性。因此，将安全点轮询间隔拉长可以为优化提供更大的空间。综合这些考虑，安全点轮询通常出现在以下位置：</p><ul><li>在解释器中运行时，在任意两个字节码之间（有效）</li><li>在 C1/C2 编译代码中的“非计数”循环后沿 （ On ‘non-counted’ loop back edge in C1/C2 compiled code ）<ul><li>A common type of program loop is one that <strong>is controlled by an integer</strong> that counts up from a initial value to an upper limit. Such a loop is called a <strong>counting loop</strong>. The integer is called a loop control variable. Loops are implemented with the conditional branch, jump, and conditional set instructions.</li></ul></li><li>在 C1/C2 编译代码中的方法入口/出口（Zing JVM在方法入口，OpenJDK在方法出口）。注意，当方法被内联时，编译器会移除这些安全点轮询。</li></ul><p>如果你是那种以汇编为乐趣 (或利润，或两者兼而有之) 的人，你会在 <code>-XX:+PrintAssembly</code> 输出中找到安全点轮询，方法是：</p><ul><li>‘{poll}’ or ‘{poll return}’ on OpenJDK, this will be in the instructions comments</li><li>‘tls.pls_self_suspend’ on Zing, this will be the flag examined at the poll operation</li></ul><p>这一机制在不同的虚拟机上实现方式不同（以下以x86 + Linux为例，我未研究其他架构）：</p><ul><li>在 Oracle/OpenJDK 中，通过对一个特殊内存页的地址执行盲 TEST 指令来实现。所谓“盲”，是因为该指令后没有分支指令，因此非常不显眼（通常 TEST 指令会紧跟一个分支指令）。当 JVM 希望将线程带入安全点时，它会保护该内存页，导致发生 SEGV（段错误），JVM 会捕获并适当处理此错误。每个 JVM 只有一个这样的特殊内存页，因此要将某个线程带入安全点，必须将所有线程带入安全点。</li><li>在 Zing JVM 中，安全点标志是线程局部的（因此有 tls 前缀）。线程可以独立地被带入安全点。</li></ul><p>更多关于轮询的细节，可参见相关文章：<a href="https://psy-lob-saw.blogspot.com/2014/03/where-is-my-safepoint.html">Dude, Where’s My Safepoint?</a></p><p>一旦线程检测到安全点标志，它将执行轮询触发的安全点动作。这通常意味着线程会在某个 JVM 级别的锁上阻塞，直到安全点操作完成时被释放。可以将此视为一种锁机制，其中：</p><ul><li>线程可以自行锁定（例如，通过调用 JNI 或在安全点阻塞）。</li><li>线程可以尝试重新进入（例如，从 JNI 返回时），但如果锁被 JVM 持有，它们将被阻塞。</li><li>安全点操作会请求该锁，并阻塞直到获得锁（即所有变异线程都已自行锁定）。</li></ul><h2 id="补充-JIT"><a href="#补充-JIT" class="headerlink" title="补充 JIT"></a>补充 JIT</h2><p>JIT 是 just in time 的缩写，也就是即时编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。</p><p>当 JVM 执行代码时，它并不立即开始编译代码。这主要有两个原因：</p><p>首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译（编译成二进制）这段代码并执行代码来说，要快很多。</p><p>当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。其实说简单点，就是 JIT 在起作用，我们知道，对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。</p><p>JIT 编译器在运行程序时有两种编译模式可以选择，并且其会在运行时决定使用哪一种以达到最优性能。这两种编译模式的命名源自于命令行参数（eg: -client 或者 -server）。JVM Server 模式与 client 模式启动，最主要的差别在于：-server 模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。原因是：当虚拟机运行在 -client 模式的时候，使用的是一个代号为 C1 的轻量级编译器，而 -server 模式启动的虚拟机采用相对重量级代号为 C2 的编译器。C2 比 C1 编译器编译的相对彻底，服务起来之后，性能更高。</p>]]></content>
    
    
    <summary type="html">本文深入探讨了JVM中的安全点（Safepoint）机制，阐述其在垃圾回收和其他运行时操作中的关键作用，分析线程如何进入安全点，以及不同JVM实现（如OpenJDK和Zing）的差异和优化策略</summary>
    
    
    
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>性能分析思路</title>
    <link href="https://wu3227834.github.io/2025/08/04/2025-08-04-xing-neng-fen-xi-si-lu/"/>
    <id>https://wu3227834.github.io/2025/08/04/2025-08-04-xing-neng-fen-xi-si-lu/</id>
    <published>2025-08-04T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<p>我还年轻的时候，经常听一些大会或者演讲。有些人说，思路逻辑非常重要。我那时就想，你肯定是瞎忽悠的，因为我怎么就没听懂你说的思路呢？而现在轮到自己来写或者讲一些东西的时候，才发现他们说得对，而我之所以不理解，也是有原因的。性能分析思路和具体实现之间，有一道鸿沟，那就是操作的能力。之前我为什么听不懂那些人的思路，其实是因为我没有操作的功底。而有了操作的功底之后，还有一个大的鸿沟要越过去，那就是从操作到对监控计数器的理解。这一步可以说让很多性能测试人员都望而却步了。但是这还不算完，这一步迈过去之后，还有一个跳跃，就是相关性分析和证据链分析的过程。</p><p>如此一来，就会得到一张性能测试分析的能力阶梯视图，如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image.png" alt="性能分析能力阶梯视图"></p><ol><li>工具操作：包括压力工具、监控工具、剖析工具、调试工具</li><li>数值理解：包括上面工具中所有输出的数据</li><li><strong>趋势分析、相关性分析、证据链分析</strong>：就是了解了工具产生的数值之后，还要把它们的逻辑关系明白。这才是性能测试分析中最重要的一环</li><li>最后才是调优：有了第 3 步之后，调优的方案策略就有很多种了，具体选择取决于调优成本和产生的效果</li></ol><p>那么怎么把这些内容都融会贯通呢？下面我们就来说说性能测试分析的几个重要环节。</p><p>应该说，从我十几年的性能工作中，上面讲的这些内容是我觉得最有价值的内容了。在今天的文章中，我们将对它做一次系统的说明。我先把性能分析思路大纲列在这里：</p><ol><li>瓶颈的精确判断</li><li>线程递增的策略</li><li>性能衰退的过程</li><li>响应时间的拆分</li><li>构建分析决策树</li><li>场景的比对</li></ol><h2 id="瓶颈的精确判断"><a href="#瓶颈的精确判断" class="headerlink" title="瓶颈的精确判断"></a>瓶颈的精确判断</h2><h3 id="TPS-曲线"><a href="#TPS-曲线" class="headerlink" title="TPS 曲线"></a>TPS 曲线</h3><p>对性能瓶颈做出判断是性能分析的第一步，有了问题才能分析调优。之前有很多人在描述性能测试的过程中，说要找到性能测试中曲线上的“拐点”。我也明确说，大部分系统其实没有明确的拐点的。举例来说，TPS 的试图如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image2.png" alt="TPS图 1"></p><p>显然，这是一个阶梯式增加的场景，非常好。但是拐点在哪呢？有人说，显然在 1200TPS左右的时候。也有人说了，显然是到 1500TPS 才是拐点呀。但是也有人说，这都已经能到2000TPS 了，显然 2000TPS 是拐点。</p><p>我们再来看一下这张图对应的响应时间视图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image2.png" alt="响应时间图 1"></p><p>是不是有人要说响应时间为 4.5ms 时是拐点了？其实这些对拐点的判断，都是不合理的。如果我们对 TPS 的增加控制得更为精确的话，那么这个 TPS 的增加是是有一个有清晰的弧度，而不是有一个非常清晰的拐点。</p><p>但是至少我们可以有一个非常明确的判断，那就是瓶颈在第二个压力阶梯上已经出现了。因为响应时间增加了，TPS 增加得却没有那么多，到第三个阶梯时，显然增加的 TPS 更少了，响应时间也在不断地增加，所以，性能瓶颈在加剧，越往后就越明显。</p><p>那么我们的判断就是：</p><ol><li>有瓶颈！</li><li>瓶颈和压力有关</li><li>压力呈阶梯，并且增长幅度在衰减</li></ol><p>如果你觉得上面的瓶颈还算清晰的话，那么我们再来看一张图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image4.png" alt="TPS图 2"></p><p>在这个 TPS 的曲线中，你还能判断出拐点在哪吗？</p><p>显然是判断不出来拐点的，但是我们根据图得出以下几个结论：</p><ol><li>有瓶颈！</li><li>瓶颈和压力有关</li><li>压力也是阶梯的，但是并没有明确的拐点</li></ol><p>我们再来看一个 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image5.png" alt="TPS图 3"></p><p>看到这张图，是不是明显感觉系统有瓶颈呢？那么瓶颈是不是和压力大小有关呢？</p><p>这种比较有规律的问题，显然不是压力大小的原因。为什么呢？因为 TPS 周期性地出现降低，并且最大的 TPS 也都恢复到了差不多的水位上。所以，即使是压力降低，也最多降低最大的 TPS 水位，会让问题出现得更晚一点，但是不会不出现。</p><p>综合以上，如果画一个示意图的话，TPS 的衰减过程大概会如下所示：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image6.png" alt="示意图"></p><ol><li>随着用户数的增加，响应时间也在缓慢增加</li><li>TPS 前期一直都在增加，但是增加的幅度在变换，直至变平</li></ol><p>在这样的曲线图中，我们是看不到明确的观点的。但是我们能做的清晰的判断就是：有瓶颈！</p><p>所以对 TPS 曲线来说，它可以明确告诉我们的就是：</p><ol><li>有没有瓶颈：其实准确来说所有的系统都有性能瓶颈，只看我们在哪个量级上做性能测试了</li><li>瓶颈和压力有没有关系：TPS 随着压力的变化而变化，那就是有关系。不管压力增不增加，TPS 都会出现曲线趋势问题，那就是无关</li></ol><p>这时你可能会问，为什么不看响应时间就武断地下此结论呢？其实响应时间用来判断业务有多快的，而 TPS 才是用来判断容量有多大的。</p><h3 id="响应时间的曲线"><a href="#响应时间的曲线" class="headerlink" title="响应时间的曲线"></a>响应时间的曲线</h3><p>我们还是来看看响应时间，下面看一张响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image7.png" alt="响应时间图"></p><p>它对应的线程图是：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image8.png" alt="线程图"></p><p>多明显的问题，随着线程的增多，响应时间也在增加，是吧。再来看它们对应的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image9.png" alt="TPS图"></p><p>到第 40 个线程时，TPS 基本上达到上限，为 2500 左右。响应时间随着线程数的增加而增加了，系统的瓶颈显而易见地出现了。</p><p>但是，如果只让你看 TPS 曲线，你是不是也会有同样的判断？那就是：有瓶颈！并且和压力有关？所以说，其实 TPS 就可以告诉我们系统有没有瓶颈了，而响应时间是用来判断业务有多块的。</p><p>后面我们还会提到响应时间会是性能分析调优地重要分析对象。</p><h2 id="线程递增的策略"><a href="#线程递增的策略" class="headerlink" title="线程递增的策略"></a>线程递增的策略</h2><p>讲完响应时间之后，我们再来看下线程递增。在见识了很多性能测试人员做的场景之后，必须得承认，有些场景地问题太多了。</p><p>首先，我们来看两个场景地执行对比。</p><p>场景 1 的线程图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image10.png" alt="线程图 1"></p><p>场景 1 的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image11.png" alt="TPS图 1"></p><p>场景 1 的响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image12.png" alt="响应时间图 1"></p><p>场景 2 的线程图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image13.png" alt="线程图 2"></p><p>场景 2 的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image14.png" alt="TPS图 2"></p><p>场景 2 的响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image15.png" alt="响应时间图 2"></p><p>这两个场景的比对如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image16.png" alt="比对图"></p><table><thead><tr><th>对比项</th><th>场景 1</th><th>场景 2</th></tr></thead><tbody><tr><td>线程数</td><td>一次性加到500</td><td>10线程递增，并且递增中也是有梯度的</td></tr><tr><td>TPS</td><td>最大值达到400</td><td>最大值达到400，但递增过程中有抖动</td></tr><tr><td>响应时间</td><td>在600ms~660ms之间</td><td>在20ms~150ms之间</td></tr><tr><td>错误率</td><td>无</td><td>无</td></tr><tr><td>粒度</td><td>以分钟为粒度</td><td>以2秒为粒度</td></tr></tbody></table><p>有了这些对比数据之后，你是不是觉得哪里似乎是有问题的？</p><p>对的！</p><p>TPS 都是达到 400，但两个场景中线程递增的策略不同。产生的响应时间完全不同。虽然都没有报错，但是第一种场景是完全不符合真实的业务场景的。这是为什么呢？</p><p>在场景的执行过程中，首先，响应时间是从低到高的，而在场景 1 中不是这样。其次，线程应该是递增的，而场景 1 并没有这样做（这里或许有人会想到秒杀的场景，认为场景 1 符合秒杀的业务设定，这个问题我们稍后提及）。最后，在两个场景中，TPS 的上限都达到了 400 TPS。但是你可以看到，在场景 2 中，只要 40 线程即可达到，但场景 1 中居然用到了 500 线程，显然压力过大，所以响应时间才那么长。</p><p>其实在生产环境中，像场景 1 这样的情形是不会出现的。如果它出现了，那就是你作为性能测试的责任，因为你没有给出生成环境中应该如何控制流量的参数配置说明。</p><p>同时，我们从上面的场景对比中可以看到，<strong>对一个系统来说，如果仅在改变压力策略（其他的条件比如环境、数据、软硬件配置等都不变）的情况下，系统的最大 TPS 上限是固定的。</strong></p><p>场景 2 使用了递增的策略，在每个阶梯递增的过程中，出现了抖动，这就明显是系统设置的不合理导致的。设置不合理，有两种可能性：</p><ol><li>资源的动态分配不合理，向后端线程池、内存、缓存等等</li><li>数据没有预热</li></ol><p>我们再回到之前说的秒杀场景。说到秒杀场景，有人觉得用大线程并发是合理的，其实这属于认知上的错误。因为即使线程数增加得再多，对已经达到 TPS 上限的系统来说，除了会增加响应时间之外，并无其他作用。所以他们描述系统的容量是用系统当前能处理的业务量（你用 TPS 也好，RPS 也好，HPS 也好，它们都是用来描述服务端的处理能力的），而不是压力工具中的线程数。</p><p>那么，对于场景中线程（有些工具中叫虚拟用户）递增的策略，我们要做到以下几点：</p><ol><li>场景中的现场递增一定是连续的，并且在递增的过程中也是有梯度的。</li><li>场景中的线程递增一定要和 TPC 的递增有比例关系，而不是突然达到最上限。</li><li>上面两点针对的是常规的性能场景。对于秒杀类的场景，我们前期一定要做好了系统预热的工作的，在预热后，线程突增产生的压力，也是在可处理范围的。这是，我们可以设计线程徒增的场景来看系统瞬间的处理能力。如果不能模拟出秒杀的徒增，就是不合理的场景。</li></ol><p>这里给出我做性能场景递增的经验值：</p><table><thead><tr><th>响应时间</th><th>递增幅度</th></tr></thead><tbody><tr><td>0-50ms</td><td>1</td></tr><tr><td>50-100ms</td><td>1-3</td></tr><tr><td>100-200ms</td><td>3-5</td></tr><tr><td>200-500ms</td><td>5-10</td></tr></tbody></table><p>当然这里也不会放在哪个系统中合适的递增幅度，你还是要根据实际的测试过程来做相应的判断。</p><h2 id="性能衰减的过程"><a href="#性能衰减的过程" class="headerlink" title="性能衰减的过程"></a>性能衰减的过程</h2><p>有瓶颈的判断能力，也有了线程递增的意识，那么下面在场景执行，我们就要有判断性能衰减的能力了吧。来，我们先看一个压力过程中产生的结果图。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image17.png" alt="压力结果图"></p><p>在递增的压力过程中，随着用户数的增加。我们可以做几次计算。</p><p>第一次计算，在线程达到 24 时，TPS 为 1810.6，也就是每线程每秒发出 75.44 个请求。</p><p>第二次计算，在线程达到 72 时，TPS 为 4375.1，也就是每线程每秒发出 60.77 个请求。</p><p>第三次计算，在线程达到 137 时，TPS 为 5034，也就是每线程每秒发出 36.74 个请求。</p><p>通过这三次计算，我们是不是可以看到，每线程每秒发出的请求数在变少，但是整体 TPS 是在增加的。</p><p>我们很多做性能测试的人，基本上，只看 TPS 和响应时间的时候，在上面这个示例中，肯定会一直往上加用户。虽然响应时间在增加，但是增加得也不多嘛。</p><p>但实际上，通过我们的计算可以知道，性能是在不断地衰减的。我们来看一张统计图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image18.png" alt="统计图"></p><p>通过红线德大致比对可以知道，当每线程每秒的请求数降到 55 左右的时候，TPS 就达到上线了，大概在 5000 左右，再接着往上增加线程已经没有用了，响应时间开始往上增加了。</p><p>这就是性能衰减的过程（题外话，再上图中，其实还有一个问题，就是在红线前面，性能在上升的过程中有几次抖动，这个抖动到后面变大了，也变频繁了，如果这是必然出现的抖动，那也是配置问题）</p><p>为什么要这么细致地描述性能衰退的过程呢？</p><p>其实我就是想告诉你，<strong>只要每线程每秒的 TPS 开始变少，就意味着性能瓶颈已经出现了。但是瓶颈出现之后，并不是说服务器的处理能力（这里我们用 TPS 来描述）会下降，应该说 TPS 仍然会上升，在性能不断衰退的过程中，TPS 就会达到上限。</strong></p><p>这也是前面说的，性能瓶颈其实在最大 TPS 之前早就已经出现了。</p><p>那么我们是不是应该在性能衰减到最大 TPS 时就停止场景呢？这个不一定的哦。</p><p>因为停不停场景，取决于我们的场景目标，如果我们只是为了得到最大 TPS，那确实可以停止场景了。但是，如果我们要扩大化性能瓶颈，也就是说为了瓶颈更为明显，就完全不需要停止场景，只要不报错，就接着往上压，一直压到我们能要说的下一个话题 ———— 响应时间变长，需要拆分。</p><h2 id="响应时间的拆分"><a href="#响应时间的拆分" class="headerlink" title="响应时间的拆分"></a>响应时间的拆分</h2><p>在性能分析中，响应时间的差分通常是一个分析起点。因为在性能场景中，不管是什么原因，只要系统达到了瓶颈，再接着增加压力，肯定会导致响应时间的上升，直至达到超时为止。</p><p>在判断了瓶颈之后，我们需要找到问题出现在什么地方。在压力工具上看到的响应时间，都是经过了后端的每一个系统的。</p><p>那么，当响应时间变长，我们就要知道，它在哪个阶段时间变长了，来看下面这个图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image19.png" alt="压力测试逻辑图"></p><p>这应该是最简单的一个压力测试逻辑图。一个应用，一个 DB，结果也拆分出了 8 个时间段，这还是在我没有加上压力工具自己所消耗的时间的情况下。但是在真实的场景中，基本上不是这样的。如果是内网，那基本上都是连在一个交换机上，所以通常是这样的：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image20.png" alt="拓扑图1"></p><p>在这样的拓扑中，我们仍然可以拆出来 t1 到 t8 的时间。只是实际动手的时候，思路一定要清晰，时间拆分是从哪里到哪里，要画出来，不能混乱。</p><p>我们有很多手段可以进行时间的拆分，当然要看我们的应用支持哪一种。如果我们是这样的架构，拆分时间应该是比较清楚的。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image21.png" alt="拓扑图2"></p><p>首先我们需要查看 Nginx 上的时间。日志里就可以通过配置$request_time $upstream_response_time得到日志如下信息：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14.131.17.129</span> - - <span class="string">[09/Dec/2019:08:08:09 +0000]</span> <span class="string">&quot;<span class="keyword">GET</span> / HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">25317</span> <span class="number">0</span>.<span class="number">028</span> <span class="number">0</span>.<span class="number">028</span></span><br></pre></td></tr></table></figure><p>最后两列中，前面是请求时间的 28ms，后面是后端响应时间的 28ms。同时，我们再到 Tomcat 上去看时间。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">172.18.0.1</span> - - <span class="string">[09/Dec/2019:08:08:09 +0000]</span> <span class="string">&quot;<span class="keyword">GET</span> / HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">25317</span> <span class="number">28</span> <span class="number">27</span> http-nio-<span class="number">8080</span>-exec-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>请求时间消耗了 28ms，响应时间消耗了 27ms。接着再来看一下前端的时间消耗。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image22.png" alt="前端耗时图"></p><p>从这里可以看到，从发出请求到接收到第一个字节，即 TTFB 是 55.01ms，内容下载用了 11.75ms。从这就可以看得出 Nginx 基本上没消耗时间，因为它和 Tomcat 上的请求响应时间非常接近。</p><p>那么网络上的消耗时间怎么样呢？我看到有很多人用 TTFB 来描述网络的时间。先来说明一下，TTFB 中显然包括了后端一系列处理和网络传输的时间。如下图所示。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image23.png" alt="TTFB 图1"></p><p>下面的红色点是指要接收的内容。上面的红色线就是 TTFB。如果接收完了呢？就是这个状态。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image24.png" alt="TTFB 图2"></p><p>所以，我觉得用 TTFB 描述网络的健康状态并不合理。如果用 Content Download 来描述会更为合理。比如我们上面的这个例子中，那就是 11.75ms 下载了 25317 Bytes 的内容。</p><p>Tomcat 上基本上是消耗了处理的所有时间，当然这中间也包括了 MySQL 花费的时间。而前端看到的其他时间就消耗在了网络中。</p><p>在这个例子中，主要说明了响应时间怎么一步步拆。当然，如果你是下面这种情况的话，再一个个拆就比较辛苦了，需要换另一种方式。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image25.png" alt="拓扑图3"></p><p>你肯定想知道每个系统消耗了多长时间，那么我们就需要链路监控工具来拆分时间了。比如像这样来拆分：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image26.png" alt="拆分图"></p><p>从 User 开始，每个服务之间的调用时间，都需要看看时间消耗的监控。这就是时间拆分的一种方式。其实不管我们用什么样的工具来监控，最终我们想要得到的无非是每个环节消耗了多长时间。用日志也好，用链路监控也好，甚至抓包都可以。当我们拆分到了某个环节之后，就有了下一步的动作：构建分析决策树。</p><h2 id="构建分析决策树"><a href="#构建分析决策树" class="headerlink" title="构建分析决策树"></a>构建分析决策树</h2><p>分析决策树，对性能测试分析人员实在太重要了，是性能分析中不可或缺的一环。<strong>它是对架构的梳理，是对系统的梳理，是对问题的梳理，是对查找证据链过程的梳理，是对分析思路的梳理。它起的是纵观全局，高屋建瓴的指导作用。</strong></p><p>性能做到了艺术的层级之后，分析决策树就是提炼出来的，可以触及旁通的方法论。而我要在这里跟你讲的，就是这样的方法论。应该说，所有的技术行业在面对自己的问题时，都需要分析决策树。再广而推之，所有的问题都要有分析决策树来协助。</p><p>通过上面的几个步骤，我们就会知道时间消耗在了哪个节点上。那么之后呢？又当如何？总要找到根本的原因才可以把，我画了如下的分析决策图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image27.png" alt="分析决策图"></p><p>从压力工具中，只需知道 TPS、响应时间和错误率三条曲线，就可以明确判断瓶颈是否存在。再通过分段分层策略，结合监控平台、日志平台，或者其他实时分析平台，知道架构中哪个环节有问题，然后再根据更细化的架构图一一拆解下去。</p><p>我在这里，以数据库分析和操作系统分析举一下例子。首先我们看一下数据库分析决策树，比如针对 RDBMS 中的 MySQL，我们就可以画一下如下的决策树：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image28.png" alt="mysql分析决策图"></p><p>由于这里面的内容实在过多，无法一次性展现在这里。我举几个具体的例子给你说明一下。</p><p>MySQL 中的索引统计信息有配置值，有状态值。我们要根据具体的结果来判断是否需要增加 key_buffer_size 值的大小。比如这种就无所谓了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Buffer</span> used     <span class="number">3</span>.<span class="number">00</span>k of   <span class="number">8</span>.<span class="number">00</span>M  %Used:   <span class="number">0</span>.<span class="number">0004</span></span><br></pre></td></tr></table></figure><p>从上面的数据可以看到，key buffer size 就用到了 4%，显然不用增加。</p><p>再比如，我们看到这样的数据：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="attribute">__Tables_______________________</span></span><br><span class="line"><span class="attribute">Open</span>             <span class="number">2000</span> of <span class="number">2000</span>    %Cache: <span class="number">100</span>.<span class="number">00</span></span><br><span class="line"><span class="attribute">Opened</span>         <span class="number">15</span>.<span class="number">99</span>M     <span class="number">4</span>.<span class="number">1</span>/s</span><br></pre></td></tr></table></figure><p>这就明显有问题了。配置值为 2000 的 Open Table Cache，已经被占满了。显然这里需要分析。但是，看到状态值达到配置值并不意味着我们需要赶紧加大配置值，而是要分析是否合理，再做相应的处理。比如说上面这个，Table 确实打开得多，但是如果我们再对应看下这一条。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Slow</span> <span class="number">2</span> s        <span class="number">6</span>.<span class="number">21</span>M     <span class="number">1</span>.<span class="number">6</span>/s</span><br></pre></td></tr></table></figure><p>你是不是觉得应该先去处理慢 SQL 的问题了？</p><p>关于数据库的我们就不举更多的例子了。在这里只是为了告诉你，在分析决策树的创建过程中，有非常多的相互依赖关系。</p><p>然后我们再来看一下操作系统分析决策树，我在这里需要强调一下，操作系统的分析决策树，不可以绕过。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image29.png" alt="操作系统分析决策图"></p><p>如果你想到操作系统架构图就头大，那么这时候应该觉得有了希望。那就是我觉得操作系统上的问题判断是比较清晰的，所以基于此决策树，每个人都可以做到对操作系统中性能问题的证据链查找。</p><p>但是！对嘛，总得有个但是。</p><p>对操作系统的理解是个必然的前提。我看过很多人写的操作系统性能分析方面的书籍或资料，发现大部分人把描述计数器的数值当成性能分析。怎么理解这句话呢？比如说</p><p>“CPU 使用率在 TPS 上升的过程中，从 10% 增加到 95%，超过了预期值。” “内存使用率达到 99%，所以是瓶颈点。” “I/O 使用率达到 100%。” 等等。</p><p>像这样的描述，在我的性能团队中，一定会被骂回去重写。我要这些描述有什么用？我要的是为什么达到了这样的值，原因在哪？怎么解决？</p><p>就像分析决策树中所描述的那样，性能工程师要做的是一步步地细化分析，给出最终的原因。</p><p>有人说，如果按这个路子，似乎操作系统的分析并不复杂嘛。大概三五个命令就可以跳到代码层了。是的，对于操作来说，确实不多，但是对于判断来说，那就复杂了。举个例子来说明一下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image30.png" alt="TOP图"></p><p>看到这样的图，你是不是有种手足无措的感觉？中断能占 40%，sy CPU 也能占 40%。这系统还用干业务的事吗？全干自己的事去了，可见操作系统有问题！你是不是要做这个判断了？</p><p>而实际情况是，这个主机上只有一个网卡队列，而请求量又比较大。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image31.png" alt="网卡队列图"></p><p>所以要解决的是网卡队列的问题，至于怎么解决，那手段就多了。可以换个服务器，可以多加几个队列，可以多接几个节点…</p><p>以上只是给出几个性能分析过程中常见的决策树示例。在后续的分析过程实例中，我们将秉承着这种分析思路，一步步地走到瓶颈的面前。</p><h2 id="场景的比对"><a href="#场景的比对" class="headerlink" title="场景的比对"></a>场景的比对</h2><p>为什么要写这一部分呢？因为我看到很多人对瓶颈的判断，并不那么精确，所以想写一下场景对比的建议。其实简单来说，就一句话：当你觉得系统中哪个环节不行的话，又没能力分析她，你可以直接做该环节的增加。举例来说，我们现在有一个如下的架构：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image32.png" alt="架构图"></p><p>可以得到这样的结果：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image33.png" alt="结果图"></p><p>从 TPS 曲线中，我们明显看到系统是有瓶颈的，但是并不知道在哪里。鉴于系统架构如此简单，我们索性直接再某环节上加上一台服务器，变成这样：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image34.png" alt="架构图"></p><p>然后得到如下数据：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image35.png" alt="结果图"></p><p>哟，没好使！</p><p>怎么办？再接着加其他节点，我加了更多的 JMeter 机器。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image36.png" alt="架构图"></p><p>再来看下结果：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image37.png" alt="结果图"></p><p>真巧，TPS 增加了！</p><p>看到了吧，这就是我说的场景比对。</p><p>当我们不知道系统中哪个环节存在性能瓶颈时，对架构并不复杂的系统来说，可以使用这样的手段，来做替换法，以快速定位问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一篇中，我说到了瓶颈的精准判断、线程递增的策略、性能衰减的过程、响应时间的拆分、构建分析决策树以及场景的比对，这几个环节，是性能分析过程中非常重要的环节。</p><p>从我的经验上来说，这一篇文章可能是我工作十几年的精华所在了。而这里的每一个环节，又有非常多的细分，特别是构建分析决策树这一块，它需要太多的架构知识、系统知识、数据库知识等等。鉴于本文只是想起到一个提纲挈领的作用，所以无法展开描述，希望在后续的篇幅中，我们尽量细致拆解。</p>]]></content>
    
    
    <summary type="html">介绍了瓶颈的精准判断、线程递增的策略、性能衰减的过程、响应时间的拆分、构建分析决策树以及场景的比对，这几个环节，是性能分析过程中非常重要的环节</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="极客时间" scheme="https://wu3227834.github.io/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何用perf工具分析Java程序</title>
    <link href="https://wu3227834.github.io/2025/07/21/2025-07-21-ru-he-yong-perf-gong-ju-fen-xi-java-cheng-xu/"/>
    <id>https://wu3227834.github.io/2025/07/21/2025-07-21-ru-he-yong-perf-gong-ju-fen-xi-java-cheng-xu/</id>
    <published>2025-07-21T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何分析容器内的进程"><a href="#如何分析容器内的进程" class="headerlink" title="如何分析容器内的进程"></a>如何分析容器内的进程</h2><p><img src="/img/2025-07-21-%E5%A6%82%E4%BD%95%E7%94%A8perf%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90Java%E7%A8%8B%E5%BA%8F/image.png" alt="perf record"></p><p>当使用 perf 工具时，看到 16 进制地址而不是函数名，通常是因为缺少符号信息（symbol information）或调试信息，导致 perf 无法将地址解析为对应的函数名或源代码行。比较常见的场景是分析容器内的子进程，因为容器应用依赖的库都在镜像里面。</p><p>针对容器的情况，总结了一下四种解决方法。</p><p><strong>第一种方法，再容器外构建相同路径的依赖库。</strong>这种方法从原理上可行，但是并不推荐，一方面是因为找出这些依赖库比较麻烦，更重要的是，构建这些路径，会污染容器主机环境</p><p><strong>第二种方法，在容器内部运行 perf。</strong>不过，这需要容器运行在特权模式下，但实际的应用程序往往只以普通容器的方式运行。所以，容器内部一般没有权限执行 perf 分析。</p><p>比方说，如何你在普通容器内运行 perf record，你将会看到下面这个错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@efbd40d93ebf /]# perf record -g -p 1</span><br><span class="line"></span><br><span class="line">perf_event_open(…, PERF_FLAG_FD_CLOEXEC) failed with unexpected error 1 (Operation not permitted)</span><br><span class="line"></span><br><span class="line">perf_event_open(…, 0) failed unexpectedly with error 1 (Operation not permitted)</span><br><span class="line"></span><br><span class="line">Error:</span><br><span class="line"></span><br><span class="line">No permission to enable cycles event.</span><br><span class="line">You may not have permission to collect stats.</span><br><span class="line">Consider tweaking /proc/sys/kernel/perf_event_paranoid,</span><br><span class="line">which controls use of the performance events system by</span><br><span class="line">unprivileged users (without CAP_SYS_ADMIN).</span><br><span class="line">The current value is -1:</span><br><span class="line">-1: Allow use of (almost) all events by all users</span><br><span class="line"></span><br><span class="line"> Ignore mlock limit after perf_event_mlock_kb without CAP_IPC_LOCK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 0: Disallow ftrace <span class="keyword">function</span> tracepoint by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line"></span><br><span class="line"> Disallow raw tracepoint access by users without CAP_SYS_ADMIN</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 1: Disallow CPU event access by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 2: Disallow kernel profiling by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line">To make this setting permanent, edit /etc/sysctl.conf too, e.g.:</span><br><span class="line">kernel.perf_event_paranoid = -1</span><br></pre></td></tr></table></figure><p>从<a href="https://docs.docker.com/engine/security/seccomp/">docker seccomp</a>文档中可以看出，由于安全问题，系统调用 “perf*” 和 “ptrace” 默认被禁止。当然，其实你可以通过配置 /proc/sys/kernel/perf_event_paranoid（比如改成 -1），来允许非特权用户执行 perf 事件分析；不过还是那句话，为了安全起见，这种方式不太推荐。</p><p><strong>第三种方法，指定符号路径为容器文件系统的路径。</strong></p><p>举个例子：我们要分析一个在 Nginx 容器中运行的 worker 进程，可以执行一下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 worker 在宿主机上的进程号</span></span><br><span class="line">PID = $(docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; mynginx)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机上创建临时目录作为挂载点</span></span><br><span class="line">mkdir /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 bindfs 进行挂载 (需要 root 权限)</span></span><br><span class="line">bindfs /proc/$PID/root /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 perf record 记录性能数据</span></span><br><span class="line">perf record -p $PID -g -- sleep 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 perf report 分析数据并指定符号路径</span></span><br><span class="line">perf report --symfs /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载 bindfs 挂载</span></span><br><span class="line">umount /tmp/foo/</span><br></pre></td></tr></table></figure><p>不过要注意，bindfs 这个工具需要你额外安装。bindfs 的基本功能是实现目录绑定（类似于 mount –bind）。</p><p><strong>第四种方法，在容器外吧分析记录保存下来，再去容器里查看结果。</strong>这样，库和符号的路径也就都对了。比如，你可以这么做。先运行 <code>perf record -g -p &lt;pid&gt;</code>，执行一会儿（比如 15 秒）后，按 Ctrl+C 停止。</p><p>然后，把生成的 perf.data 文件，拷贝到容器里边来分析，不过，这里也需要注意 perf 工具的版本问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker cp perf.data mynginx:/tmp </span><br><span class="line">docker exec -i -t mynginx bash</span><br><span class="line"></span><br><span class="line">cd /tmp/ </span><br><span class="line">yum install perf</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><p>当你按照前面这几种方法操作后，你就可以在容器内部看到：</p><p><img src="/img/2025-07-21-%E5%A6%82%E4%BD%95%E7%94%A8perf%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90Java%E7%A8%8B%E5%BA%8F/image2.png" alt="perf report"></p><h2 id="为何看不到原生的Java的调用栈"><a href="#为何看不到原生的Java的调用栈" class="headerlink" title="为何看不到原生的Java的调用栈"></a>为何看不到原生的Java的调用栈</h2><p>分析 Java 应用时，perf 工具面临一个根本挑战：Java 代码并非直接在 CPU 上执行原生机器码，而是运行在一个名为 JVM（Java 虚拟机）的托管环境中：</p><ul><li>JIT 编译的抽象层：JVM 会在运行时通过即时编译（JIT）技术将热点的 Java 字节码动态编译成高效的机器码。这个过程意味着 perf 采样到的是这些动态生成的、无明确符号（函数名）的机器码地址</li><li>非标准调用栈：perf 默认只能识别操作系统层面的函数调用，因此它能看到 JVM 自身的函数（如 JavaMain），但是无法理解 JVM 内部的、属于 Java 应用程序的调用关系</li></ul><p>为了让 perf 发挥最用，必须建立一座桥梁，将 JVM 内的函数调用信息与 perf 的系统级采样数据关联起来。可以采用以下方案解决：</p><p>步骤一：保留帧指针（Preserve Frame Pointer），这是确保调用栈能被正常回溯的基础</p><ul><li>操作：在启动 Java 应用时，添加 JVM 参数 <code>-XX:-PreserveFramePointer</code></li><li>原理：处于性能优化，JIT 编译器默认会省略帧指针，这会释放一个寄存器提供其他用途。然后，perf 等多数性能分析工具依赖帧指针来遍历和回溯函数调用栈。启动此选项可以强制 JVM 保留该信息，从而生成完整、可追溯的调用栈。</li></ul><p>步骤二：生成 Java 符合映射表</p><p>此步骤的目的是将 perf 看到的内存地址翻译成可读的 Java 函数名</p><ul><li>工具：使用 <a href="https://github.com/jvm-profiling-tools/perf-map-agent">perf-map-agent</a>，这是一个专门为此设计的开源工具</li><li>原理：perf-map-agent 会作为一个 Java Agent 附加到目标 JVM 进程上，查询 JIT 编译后的机器码地址与原始 Java 方法名的对应关系，并将其写入一个 perf 能够识别的映射文件（通常是 /tmp/perf-<pid>.map）。perf 在生成报告时会自动检测并使用此文件。</li></ul><p>步骤三：使用 perf 采样与分析</p><p>完成上述准备后，就可以使用标准的 perf 命令进行性能分析。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -F 99 -p &lt;pid&gt; -g -- sleep 30 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-F 99：以 99Hz 的频率采样</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g：记录调用图（Call Graph）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分析采样数据</span></span><br><span class="line">sudo perf report</span><br></pre></td></tr></table></figure><p><strong>拓展</strong>：目前有现成的工具解决上述问题，<a href="https://github.com/async-profiler/async-profiler">async-profiler</a>，是一个专为 Java 设计的低开销、高精度的性能分析器，它集成了 perf 的功能并做了大量优化，是目前 Java 性能分析的优选工具。</p>]]></content>
    
    
    <summary type="html">使用 perf 分析 Java 程序需解决符号缺失和调用栈问题，可通过容器内外路径映射、保留 JVM 帧指针、使用 perf-map-agent 或 async-profiler 优化分析</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：网络</title>
    <link href="https://wu3227834.github.io/2025/06/17/2025-06-17-linux-tracing-network/"/>
    <id>https://wu3227834.github.io/2025/06/17/2025-06-17-linux-tracing-network/</id>
    <published>2025-06-17T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux网络性能指标"><a href="#Linux网络性能指标" class="headerlink" title="Linux网络性能指标"></a>Linux网络性能指标</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li>带宽，表示链路的<strong>最大传输速率</strong>，单位通常为 b/s（比特/秒）</li><li>吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特/秒）或者 B/s(字节/秒)。<strong>吞吐量受带宽限制</strong>，而吞吐量/带宽，也就是该网络的使用率</li><li>延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同的涵义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）</li><li>PSS，是 Packet Per Second（包/秒）的缩写，表示以<strong>网络包为单位的传输速率</strong>。PSS 通常用来评估<strong>网络的转发能力</strong>，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响</li></ul><p>另外，<strong>网络的可用性</strong>（网络能否正常通信）、<strong>并发连接数</strong>（TCP 连接数量）、<strong>丢包率</strong>（丢包百分比）、<strong>重传率</strong>（重新传输的网络包比例）等也是常用的性能指标。</p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>使用命令 ifconfig 或者 ip 查看</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth1</span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 9.134.194.74  netmask 255.255.248.0  broadcast 9.134.199.255</span><br><span class="line">        ether 52:54:00:82:12:e8  txqueuelen<span class="number"> 1000 </span> (Ethernet)</span><br><span class="line">        RX packets<span class="number"> 70297502 </span> bytes<span class="number"> 34143392231 </span>(31.7 GiB)</span><br><span class="line">        RX errors<span class="number"> 0 </span> dropped<span class="number"> 0 </span> overruns<span class="number"> 0 </span> frame 0</span><br><span class="line">        TX packets<span class="number"> 78816203 </span> bytes<span class="number"> 45528648722 </span>(42.4 GiB)</span><br><span class="line">        TX errors<span class="number"> 0 </span> dropped<span class="number"> 0 </span>overruns<span class="number"> 0 </span> carrier<span class="number"> 0 </span> collisions 0</span><br><span class="line"></span><br><span class="line">$ ip -s  addr show dev eth1</span><br><span class="line">2: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu<span class="number"> 1500 </span>qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 52:54:00:82:12:e8 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 9.134.194.74/21 brd 9.134.199.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">   <span class="number"> 34143407013 </span>70297654<span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>      </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns </span><br><span class="line">   <span class="number"> 45528723929 </span>78816328<span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span> </span><br></pre></td></tr></table></figure><p>第一，网络接口的状态标志。ifconfig 输出 RUNNING，或者 ip 输出中的 LOWER_UP，都表示物理网络是连通，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了。</p><p>第二，MTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。</p><p>第三，网络接口的 IP 地址、子网以及 MAC 地址。这些地址都是保障网络功能正常工作所必须的，你需要确保配置正确。</p><p>第四，网络收发的字节数、包数、错误数以及丢包情况，特别是 TX 和 RX 部分的 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，通常表示出现了网络 I/O 问题。其中：</p><ul><li>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等</li><li>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包</li><li>overruns 表示超限数据丢包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包</li><li>carrier 表示发生 carrirer 错误的数据报数，比如双工模式不匹配、物理电缆出现问题等</li><li>collisions 表示碰撞数据包数</li></ul><h3 id="嵌套字信息"><a href="#嵌套字信息" class="headerlink" title="嵌套字信息"></a>嵌套字信息</h3><p>使用 netstat 或 ss 来表示<strong>嵌套字、网络栈、网络接口以及路由表的信息</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nlp | head -n <span class="number">3</span></span><br><span class="line">Active Internet connections (<span class="keyword">only</span> servers)</span><br><span class="line">Proto Recv-Q Send-Q <span class="keyword">Local</span> Address           <span class="keyword">Foreign</span> Address         State       PID/Program <span class="type">name</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10248</span>         <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:*               <span class="keyword">LISTEN</span>      <span class="number">624565</span>/kubelet</span><br><span class="line"></span><br><span class="line">$ ss -ltnp | head -n <span class="number">3</span></span><br><span class="line">State      Recv-Q Send-Q <span class="keyword">Local</span> Address:Port               Peer Address:Port</span><br><span class="line"><span class="keyword">LISTEN</span>     <span class="number">0</span>      <span class="number">65535</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10248</span>                    *:*                   users:((&quot;kubelet&quot;,pid=<span class="number">624565</span>,fd=<span class="number">29</span>))</span><br><span class="line"><span class="keyword">LISTEN</span>     <span class="number">0</span>      <span class="number">65535</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10249</span>                    *:*                   users:((&quot;kube-proxy&quot;,pid=<span class="number">624952</span>,fd=<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>其中，<strong>接收队列（Recv-Q）和发送队列（Send-Q）</strong>需要关注，它们通常是 0。当你发现它们不是 0 时，说明有网络包的堆积发生</p><p>当嵌套字处于连接状态（Established）时，</p><ul><li>Recv-Q 表示嵌套字缓冲还没有被应用程序取走的字节数（即接收队列长度）</li><li>Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）</li></ul><p>当嵌套字处于监听状态（Listening）时，</p><ul><li>Recv-Q 表示当前全连接队列（accept 队列）长度</li><li>Send-Q 表示全连接队列的最大长度</li></ul><h3 id="协议栈统计信息"><a href="#协议栈统计信息" class="headerlink" title="协议栈统计信息"></a>协议栈统计信息</h3><p>使用 netstat 或 ss 命令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -s</span><br><span class="line">Ip:</span><br><span class="line">   <span class="number"> 11236847787 </span>total packets received</span><br><span class="line">   <span class="number"> 76906 </span>forwarded</span><br><span class="line">   <span class="number"> 0 </span>incoming packets discarded</span><br><span class="line">   <span class="number"> 10964584370 </span>incoming packets delivered</span><br><span class="line">   <span class="number"> 10948611259 </span>requests sent out</span><br><span class="line">   <span class="number"> 448 </span>outgoing packets dropped</span><br><span class="line">   <span class="number"> 4 </span>dropped because of missing route</span><br><span class="line">Icmp:</span><br><span class="line">   <span class="number"> 37370022 </span>ICMP messages received</span><br><span class="line">   <span class="number"> 158 </span>input ICMP message failed.</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 141016</span><br><span class="line">        echo requests: 20256273</span><br><span class="line">        echo replies: 16972733</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@pudding-161 ~]<span class="comment"># ss -s</span></span><br><span class="line">Total:<span class="number"> 1434 </span>(kernel 1816)</span><br><span class="line">TCP:  <span class="number"> 1144 </span>(estab 894, closed 164, orphaned 0, synrecv 0, timewait 158/0), ports 0</span><br><span class="line"></span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line">*        <span class="number"> 1816 </span>     -         -</span><br><span class="line">RAW      <span class="number"> 2 </span>       <span class="number"> 1 </span>        1</span><br><span class="line">UDP      <span class="number"> 13 </span>      <span class="number"> 7 </span>        6</span><br><span class="line">TCP      <span class="number"> 980 </span>     <span class="number"> 349 </span>      631</span><br><span class="line">INET     <span class="number"> 995 </span>     <span class="number"> 357 </span>      638</span><br><span class="line">FRAG     <span class="number"> 0 </span>       <span class="number"> 0 </span>        0</span><br></pre></td></tr></table></figure><h3 id="网络吞吐-和-PPS"><a href="#网络吞吐-和-PPS" class="headerlink" title="网络吞吐 和 PPS"></a>网络吞吐 和 PPS</h3><p>使用 sar 命令，加上 -n 参数，可以查看网络的统计信息，比如网络接口（DEV）、网络接口错误（EDEV）、TCP、UDP、ICMP 等</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sar <span class="operator">-</span>n DEV <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span><span class="operator">-</span><span class="number">957</span>.el7.x86_64 (xxx)       <span class="number">06</span><span class="symbol">/18/2025</span>      _x86_64_        (<span class="number">8</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">42</span> PM     IFACE   rxpck<span class="symbol">/s</span>   txpck<span class="symbol">/s</span>    rxkB<span class="symbol">/s</span>    txkB<span class="symbol">/s</span>   rxcmp<span class="symbol">/s</span>   txcmp<span class="symbol">/s</span>  rxmcst<span class="symbol">/s</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM    dummy0      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM      eth0    <span class="number">695.00</span>    <span class="number">663.00</span>   <span class="number">6938.75</span>   <span class="number">3796.65</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM        lo    <span class="number">112.00</span>    <span class="number">112.00</span>     <span class="number">39.30</span>     <span class="number">39.30</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM kube-ipvs0      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure><ul><li>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包/秒</li><li>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/s</li><li>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包/秒</li></ul><p>带宽可以用 ethtool 来查询，它的单位通常是 Gb/s 或者 Mb/s（千兆网卡或者万兆网卡的单位都是 bit）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool enp4s0f0 <span class="string">| grep Speed</span></span><br><span class="line">        Speed<span class="punctuation">:</span> <span class="number">1000</span>Mb/s</span><br></pre></td></tr></table></figure><h3 id="连通性和延时"><a href="#连通性和延时" class="headerlink" title="连通性和延时"></a>连通性和延时</h3><p>使用命令 ping，来测试远程主机的连通性和延时（基于 ICMP 协议）</p><p>如下，测试本机到 baidu.com 这个地址的连通性和延时</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in"> ping </span>-c3 baidu.com<span class="built_in"></span></span><br><span class="line"><span class="built_in">PING </span>baidu.com (182.61.201.211) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=29.1 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=27.2 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=27.8 ms</span><br><span class="line"></span><br><span class="line">--- baidu.com<span class="built_in"> ping </span>statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 27.280/28.097/29.158/0.785 ms</span><br></pre></td></tr></table></figure><p>ping 的输出，可以分为两部分：</p><ul><li>每个 ICMP 请求的信息，包括 ICMP 序列号（icmp_seq）、TTL（生存时间，或者跳数）以及往返延时</li><li>三次 ICMP 请求的汇总</li></ul><h2 id="C10K和C100K问题"><a href="#C10K和C100K问题" class="headerlink" title="C10K和C100K问题"></a>C10K和C100K问题</h2><h3 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h3><p>C10K 代表同时处理 10000 个请求</p><p>从资源上来说，对 2GB 内存和千兆网卡的服务器来说，同时处理 10000 个请求，只要每个请求处理占用不到 200KB（2GB/10000）的内存和 100Kbit（1000Mbit/10000）的网络带宽就可以。</p><p>从软件上来看，主要是网络 I/O 模型的问题，在 C10K 之前，Linux 主要是<strong>同步阻塞</strong>的方式，每个请求都分配一个进程或者线程，而 10000 个进程或者线程的调度、上下文切换和内存，都可能成为瓶颈。</p><p>需要解决的问题：</p><ul><li>怎样在一个线程内处理多个请求，也就是要在一个线程内响应多个网络 I/O？</li></ul><h4 id="I-O-模型优化"><a href="#I-O-模型优化" class="headerlink" title="I/O 模型优化"></a>I/O 模型优化</h4><p>异步、非阻塞 I/O 的思路：I/O 多路复用</p><blockquote><p>两种 I/O 时间通知的方式：水平触发和边缘触发<br>水平触发：只要文件描述符可以非阻塞地执行 I/O，就会触发通知。也就是说，应用程序可以随时检查文件描述符地状态，然后再根据状态，进行 I/O 操作。<br>边缘触发：只有在文件描述符的状态发生改变（也就是 I/O 请求达到）时，才会发送一次通知。这时候，应用程序需要尽可能多地执行 I/O，知道无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了</p></blockquote><ul><li>第一种，使用非阻塞 I/O 和水平触发通知，比如使用 select 或者 poll</li><li>第二种，使用非阻塞 I/O 和边缘触发通知，比如 epoll（在 select 和 poll 基础上进行优化）</li><li>第三种，使用异步 I/O（Asynchronous I/O，简称为 AIO）</li></ul><h4 id="工作模型优化"><a href="#工作模型优化" class="headerlink" title="工作模型优化"></a>工作模型优化</h4><p>I/O 多路复用有两种主要的工作模式：</p><p><strong>第一种</strong>：主进程 + 多个 worker 子进程（比如 nginx），主要流程是：</p><ul><li>主进程执行 bind() + listen() 后，创建多个子进程；</li><li>在每个子进程中，都通过 accept() 或 epoll_wait() ，来处理相同的套接字</li></ul><p><img src="/img/2025-06-17-linux_tracing_network/image.png" alt="示意图"></p><p><strong>注意</strong>：accept() 和 epoll_wait() 调用，还存在一个<strong>惊群</strong>的问题（当网络 I/O 事件发生时，多个进程被同时唤醒，但实际上只有一个进程来响应这个事件，其他被唤醒的进程都会重新休眠）</p><p>为了避免<strong>惊群问题</strong>，Nginx 在每个 worker 进程中，都会增加一个全局锁（accept_mutex）。这些 worder 进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到 epoll 中，这样就确保只有一个 worker 子进程被唤醒</p><p><strong>第二种</strong>：监听到相同端口的多进程模型，所有的进程都监听相同的端口，有各自的套接字，开启 SO_REUSEPORT 选项（Linux 3.9+ 才支持），由内核负责将请求负载均衡到这些监听进程中去</p><p><img src="/img/2025-06-17-linux_tracing_network/image2.png" alt="示意图"></p><h3 id="C1000K"><a href="#C1000K" class="headerlink" title="C1000K"></a>C1000K</h3><p>C1000K 代表同时 100w 个请求</p><ul><li>从物理资源上来说，100 万个请求需要大量的系统资源<ul><li>内存：假设每个请求需要 16KB 内存的化，那么总共就需要大约 15GB 内存</li><li>带宽：假设只有 20% 活跃连接，即使每个连接只需要 1KB/s 的吞吐量，总共需要 200000 * 8 / 1024 / 1024 = 1.6 Gb/s 的吞吐量，千兆网卡已经不能够满足，需要配置万兆网卡</li></ul></li><li>从软件资源上来说，大量的连接也会占用大量的软件资源，比如<strong>文件描述符的数据、连接状态的跟踪（CONNTRACK）、网络协议栈的缓存大小（比如套接字读写缓存、TCP 读写缓存）</strong>等等，也会带来<strong>大量的中断处理</strong></li></ul><p><strong>优化</strong>：在 I/O 多路复用的基础上，需要多队列网卡、硬中断负载均衡、CPU 绑定、RPS/RFS（软中断负载均衡到多个 CPU 核上），以及将网络包的处理卸载（Offload）到网络设备（如 TSO/GSO、LRO/GRO、VXLAN OFFLOAD）等各种硬件和软件的优化。</p><h3 id="C10M"><a href="#C10M" class="headerlink" title="C10M"></a>C10M</h3><p>同时有 1000w 个请求，解决方法是<strong>跳过内核协议栈</strong>，将网络包直接发送到要处理的应用程序</p><p>第一种机制：DPDK（Data Plane Development Kit），用户网络的标准，跳过内核协议栈，直接由用户态进程通过轮询的方式来处理网络请求</p><p><img src="/img/2025-06-17-linux_tracing_network/image3.png" alt="示意图"></p><p>第二种机制：XDP（eXpress Data Path），Linux 内核提供的一种高性能网络数据路径，它允许网络包，在进入内核协议栈之前，就进行处理</p><p><img src="/img/2025-06-17-linux_tracing_network/image4.png" alt="示意图"></p><h2 id="怎么评估系统的网络性能"><a href="#怎么评估系统的网络性能" class="headerlink" title="怎么评估系统的网络性能"></a>怎么评估系统的网络性能</h2><h3 id="各协议层的性能测试"><a href="#各协议层的性能测试" class="headerlink" title="各协议层的性能测试"></a>各协议层的性能测试</h3><h4 id="转发性能"><a href="#转发性能" class="headerlink" title="转发性能"></a>转发性能</h4><p>hping3 工具，测试网络包的处理能力：<a href="https://wangchujiang.com/linux-command/c/hping3.html"> hping3 手册 </a></p><h4 id="TCP-UDP-性能"><a href="#TCP-UDP-性能" class="headerlink" title="TCP/UDP 性能"></a>TCP/UDP 性能</h4><p>iperf 网络性能测试工具：<a href="https://wangchujiang.com/linux-command/c/iperf.html"> iperf 手册 </a></p><p>iperf3 是 iperf 的重写版本，一些常用参数：</p><table><thead><tr><th>主要参数</th><th>参数说明</th></tr></thead><tbody><tr><td>-s</td><td>服务端专用参数，表示 iperf3 以服务端模式运行</td></tr><tr><td>-c</td><td>客户端专用参数，表示 iperf3 以客户端模式运行</td></tr><tr><td>-i</td><td>设置每次报告之间的时间间隔，单位为秒</td></tr><tr><td>-p</td><td>服务端：指定服务端监听的端口，默认为 5201，同时监听 TCP/UDP。<br> 客户端：指定客户端连接服务端的端口，默认为 5201。如果同时有 -u 参数，表示通过 UDP 发起连接，否则默认使用 TCP 连接</td></tr><tr><td>-u</td><td>表示使用 UDP 协议发送报文。若不指定该参数则表示使用 TCP 协议</td></tr><tr><td>-l</td><td>设置读写缓冲区的长度。通常测试包转发性能时建议该值设为 16，测试带宽时建议该值设为 1400</td></tr><tr><td>-b</td><td>UDP 模式使用的带宽，单位 bit/s</td></tr><tr><td>-t</td><td>设置传输的总时间。iperf3 在指定时间内，重复发送指定长度数据包的时间，默认值为 10 秒</td></tr><tr><td>-A</td><td>设置 CPU 亲和性，可以将 iperf3 进程绑定对应编号的逻辑 CPU，避免 iperf3 进程在不同的 CPU 间被调度</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文介绍 Linux 网络性能指标、调优方法及 C10K/C1000K 问题的应对策略</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：I/O</title>
    <link href="https://wu3227834.github.io/2025/06/02/2025-06-02-linux-tracing-io/"/>
    <id>https://wu3227834.github.io/2025/06/02/2025-06-02-linux-tracing-io/</id>
    <published>2025-06-02T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统和磁盘的区别"><a href="#文件系统和磁盘的区别" class="headerlink" title="文件系统和磁盘的区别"></a>文件系统和磁盘的区别</h2><p>磁盘是一个存储设备（确切来说是块设备），可以划分为不同的磁盘分区。而在磁盘或者磁盘分区上，还可以在创建文件系统，并挂载到系统的某个目录。这样，系统就可以通过这个挂载目录，来读写文件。</p><p>换句话说，磁盘是存储数据的块设备，也是文件系统的载体。所以，文件系统确实还是要通过磁盘，来保证数据的持久化存储。</p><p><strong>Linux 中一切皆文件</strong>。可以通过相同的文件接口，来访问磁盘和文件（比如 open、read、write、close 等）</p><ul><li>通常说的“文件”，是指普通文件</li><li>磁盘和分区，是指块设备文件</li></ul><p>在读写普通文件时，I/O 请求会首先经过文件系统，然后由文件系统负责，来与磁盘进行交互。而读写块设备文件时，会跳过文件系统，直接与磁盘交互，也就是所谓的“裸 I/O”。文件系统管理的缓存，是 Cache 的一部分；而裸磁盘的缓存，用的正是 Buffer。</p><blockquote><p>裸磁盘，也称为原始磁盘，是一种未被任何文件系统（如NTFS、FAT32）格式化或管理的磁盘。换句话说，它是直接与磁盘硬件交互，而不通过操作系统的文件系统层进行访问。</p></blockquote><p>缓存 I/O 与直接 I/O（裸磁盘 I/O ）的对比</p><table><thead><tr><th>特性</th><th>缓存I/O（文件系统）</th><th>直接I/O（裸磁盘）</th></tr></thead><tbody><tr><td>数据流</td><td>磁盘 → 内核缓冲区 → 应用程序地址空间</td><td>磁盘 → 直接应用程序地址空间</td></tr><tr><td>缓存使用</td><td>使用文件系统管理的Cache</td><td>使用磁盘的Buffer</td></tr><tr><td>性能</td><td>适合常规文件操作，减少磁盘读写次数</td><td>适合高性能场景，如数据库，减少文件系统开销</td></tr><tr><td>应用场景</td><td>普通文件读写，系统默认方式</td><td>虚拟化、数据库优化、低级别磁盘操作</td></tr><tr><td>优点</td><td>保护系统安全，减少直接磁盘访问风险</td><td>降低数据复制开销，提高I/O效率</td></tr><tr><td>缺点</td><td>数据复制开销高，CPU和内存占用多</td><td>需要应用程序管理缓存，可能增加复杂性</td></tr></tbody></table><h2 id="Linux-文件系统如何工作"><a href="#Linux-文件系统如何工作" class="headerlink" title="Linux 文件系统如何工作"></a>Linux 文件系统如何工作</h2><h3 id="索引节点和目录项"><a href="#索引节点和目录项" class="headerlink" title="索引节点和目录项"></a>索引节点和目录项</h3><ul><li>索引节点（inode），和文件一一对应，存储在磁盘中，记录文件的元数据</li><li>目录项（dentry），记录文件的名字、索引节点以及其他目录项的关联关系</li></ul><p>举例说明，为文件创建的硬链接，会对应不同的目录项，他们都连接到同一个文件，索引节点相同。</p><p>磁盘的最小单位是<strong>扇区</strong>，文件系统将连续的扇区组成逻辑块，以逻辑块为最小单位，来读写磁盘数据。常见的逻辑块 4KB，由连续的 8 个扇区组成。</p><p><img src="/img/2025-06-02-linux_tracing_io/image.png" alt="示意图"></p><p>磁盘在执行文件系统格式化时，分为三个区域：超级块、索引节点和数据块：</p><ul><li>超级块：整个文件系统的状态</li><li>索引节点区：存储索引节点</li><li>数据块区：存储文件数据</li></ul><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><img src="/img/2025-06-02-linux_tracing_io/image2.png" alt="示意图"></p><p>文件系统分类：</p><ul><li>基于磁盘的文件系统：常见的 ext4、XFS、OverlayFS 等，都是这类文件系统</li><li>基于内存的文件系统：常说的虚拟文件系统，不需要磁盘空间，但是占用内存。比如，/proc 和 /sys</li><li>网络文件系统：用于访问其他计算机的文件系统，比如 NFS、SMB、ISCSI 等</li></ul><p><strong>注意</strong>：这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为<strong>挂载点</strong>），然后才能访问其中的文件。</p><h3 id="文件系统-I-O"><a href="#文件系统-I-O" class="headerlink" title="文件系统 I/O"></a>文件系统 I/O</h3><p>根据是否利用标准库缓存，分为<strong>缓冲 I/O 和非缓冲 I/O</strong>：</p><ul><li>缓存 I/O：利用标准库缓存，加速文件访问，标准库内部利用系统调用访问文件</li><li>非缓存 I/O：直接通过系统调用访问文件，不再经过标准库缓存</li></ul><p><strong>注意</strong>：这里的“缓冲”，是指<strong>标准库内部实现的缓存</strong>，最终还是需要通过系统调用，而系统调用还会通过<strong>页缓存</strong>，来较少磁盘的 I/O 操作</p><p>根据是否利用操作系统的<strong>页缓存</strong>，分为<strong>直接 I/O 和非直接 I/O</strong>：</p><ul><li>直接 I/O：跳过操作系统的页缓存，直接和<strong>文件系统</strong>交互来访问文件</li><li>非直接 I/O：先通过页缓存，再通过内核或者额外的系统调用，真正和磁盘交互（O_DIRECT 标志）</li></ul><p>根据应用程序是否阻塞自身，分为<strong>阻塞 I/O 和非阻塞 I/O</strong>：</p><ul><li>阻塞 I/O：是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程</li><li>非阻塞 I/O：是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过<strong>轮询或者事件通知</strong>的形式，获取调用的结果</li></ul><p>根据是否等待相应结果，分为<strong>同步 I/O 和异步 I/O</strong>：</p><ul><li>同步 I/O：应用程序执行 I/O 操作之后，要等到整个 I/O 完成后，才能获得 I/O 响应</li><li>异步 I/O：应用程序不用等待 I/O 完成，会继续执行，等到 I/O 执行完成，会以事件的方式通知应用程序</li></ul><p>设置 O_SYNC 或者 O_DSYNC，代表同步 I/O。如果是 O_DSYNC，要等到文件数据写入磁盘之后，才能返回，如果是 O_SYNC，是在 O_DSYNC 的基础上，要求文件<strong>元数据</strong>写入磁盘，才返回。</p><p>设置 O_ASYNC，代表异步 I/O，系统会再通过 SIGIO 或者 SIFPOLL 通知进程。</p><h3 id="性能观测"><a href="#性能观测" class="headerlink" title="性能观测"></a>性能观测</h3><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>df 命令查看磁盘空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -h /dev/vdb</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vdb        400G   95G  306G  24% /var/lib/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引节点所占的空间</span></span><br><span class="line">$ <span class="built_in">df</span> -i /dev/vdb</span><br><span class="line">Filesystem        Inodes  IUsed     IFree IUse% Mounted on</span><br><span class="line">/dev/vdb       209715200 546727 209168473    1% /var/lib/docker</span><br></pre></td></tr></table></figure><p>当索引节点空间不足，但是索引空间充足时，可能是过多小文件导致的。<strong>解决方法</strong>一般是删除这些小文件，或者移动到索引节点充足的其他磁盘区。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>可以使用 free 或者 vmstat，观察页缓存的大小；也可以查看 /proc/meminfo</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="keyword">/proc/</span>meminfo | grep -E <span class="string">&quot;SReclaimable|Cached&quot;</span></span><br><span class="line"><span class="symbol">Cached:</span>          <span class="number">3987272</span> kB</span><br><span class="line"><span class="symbol">SwapCached:</span>       <span class="number">109532</span> kB</span><br><span class="line"><span class="symbol">SReclaimable:</span>    <span class="number">4095228</span> kB</span><br></pre></td></tr></table></figure><p>内核使用 slab 机制，管理目录项和索引节点的缓存，/proc/meminfo 给出了整体的 slab 大小，/proc/slabinfo 可以查看每一种 slab 的缓存</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]<span class="comment"># cat /proc/slabinfo | grep -E &#x27;^#|dentry|inode&#x27;</span></span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line">fuse_inode          <span class="number"> 189 </span>  <span class="number"> 189 </span>  <span class="number"> 768 </span> <span class="number"> 21 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 9 </span>    <span class="number"> 9 </span>     0</span><br><span class="line">ovl_inode         <span class="number"> 11534 </span><span class="number"> 15600 </span>  <span class="number"> 680 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 650 </span>  <span class="number"> 650 </span>     0</span><br><span class="line">xfs_inode        <span class="number"> 175054 </span>175372   <span class="number"> 960 </span> <span class="number"> 34 </span>  <span class="number"> 8 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 5158 </span> <span class="number"> 5158 </span>     0</span><br><span class="line">mqueue_inode_cache   <span class="number"> 288 </span>  <span class="number"> 288 </span>  <span class="number"> 896 </span> <span class="number"> 36 </span>  <span class="number"> 8 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 8 </span>    <span class="number"> 8 </span>     0</span><br><span class="line">hugetlbfs_inode_cache    <span class="number"> 52 </span>   <span class="number"> 52 </span>  <span class="number"> 608 </span> <span class="number"> 26 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 2 </span>    <span class="number"> 2 </span>     0</span><br><span class="line">sock_inode_cache   <span class="number"> 2255 </span> <span class="number"> 2475 </span>  <span class="number"> 640 </span> <span class="number"> 25 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata    <span class="number"> 99 </span>   <span class="number"> 99 </span>     0</span><br><span class="line">shmem_inode_cache  <span class="number"> 6783 </span> <span class="number"> 7056 </span>  <span class="number"> 680 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 294 </span>  <span class="number"> 294 </span>     0</span><br><span class="line">proc_inode_cache  <span class="number"> 28816 </span><span class="number"> 29688 </span>  <span class="number"> 656 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 1237 </span> <span class="number"> 1237 </span>     0</span><br><span class="line">inode_cache       <span class="number"> 34463 </span><span class="number"> 35208 </span>  <span class="number"> 592 </span> <span class="number"> 27 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 1304 </span> <span class="number"> 1304 </span>     0</span><br><span class="line">dentry           <span class="number"> 20014134 </span>20014134   <span class="number"> 192 </span> <span class="number"> 21 </span>  <span class="number"> 1 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata<span class="number"> 953054 </span>953054      0</span><br><span class="line">selinux_inode_security <span class="number"> 15708 </span><span class="number"> 15708 </span>   <span class="number"> 40 </span><span class="number"> 102 </span>  <span class="number"> 1 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 154 </span>  <span class="number"> 154 </span>     0</span><br></pre></td></tr></table></figure><p>其中 dentry 代表目录项缓存，inode_cache 代表 VFS 索引节点缓存，其他的就是各种文件系统的索引节点缓存。</p><p>实际性能分析中，更常使用 slabtop 命令，来找出占用内存最多的缓存类型。</p><p>示例如下：可以看到，目录项占用了最多的 Slab 缓存，大约 3.91 G</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下c按照缓存大小排序，按下a按照活跃对象数排序 </span></span><br><span class="line">$ slabtop</span><br><span class="line"> Active / Total Objects (% used)    :<span class="number"> 22757396 </span>/<span class="number"> 23018218 </span>(98.9%)</span><br><span class="line"> Active / Total Slabs (% used)      :<span class="number"> 1067320 </span>/<span class="number"> 1067320 </span>(100.0%)</span><br><span class="line"> Active / Total Caches (% used)     :<span class="number"> 72 </span>/<span class="number"> 103 </span>(69.9%)</span><br><span class="line"> Active / Total Size (% used)       : 4462258.28K / 4545420.86K (98.2%)</span><br><span class="line"> Minimum / Average / Maximum Object : 0.01K / 0.20K / 8.00K</span><br><span class="line"></span><br><span class="line">  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME</span><br><span class="line">21574896<span class="number"> 21574735 </span> 99%    0.19K<span class="number"> 1027376 </span>     <span class="number"> 21 </span>  4109504K dentry</span><br><span class="line">355914<span class="number"> 286236 </span> 80%    0.10K  <span class="number"> 9126 </span>     <span class="number"> 39 </span>    36504K buffer_head</span><br><span class="line">223872<span class="number"> 205323 </span> 91%    0.06K  <span class="number"> 3498 </span>     <span class="number"> 64 </span>    13992K kmalloc-64</span><br><span class="line">175372<span class="number"> 175125 </span> 99%    0.94K  <span class="number"> 5158 </span>     <span class="number"> 34 </span>   165056K xfs_inode</span><br><span class="line"><span class="number"> 57600 </span><span class="number"> 57529 </span> 99%    0.16K  <span class="number"> 2400 </span>     <span class="number"> 24 </span>     9600K xfs_ili</span><br><span class="line">136528 <span class="number"> 53170 </span> 38%    0.57K  <span class="number"> 4876 </span>     <span class="number"> 28 </span>    78016K radix_tree_node</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Linux-磁盘-I-O-工作原理"><a href="#Linux-磁盘-I-O-工作原理" class="headerlink" title="Linux 磁盘 I/O 工作原理"></a>Linux 磁盘 I/O 工作原理</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>根据存储介质，磁盘分为：</p><ul><li>机械磁盘，也称为硬盘驱动器（Hard Disk Driver），通常缩写为 HDD。机械磁盘主要有盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位数据所在的磁道，才能访问数据。如果 I/O 请求刚好连续，就不需要磁道寻址，可以获得最佳性能。这就是连续 I/O 的工作原理。与之对应的是随机 I/O，它需要不停地移动磁头，来定位数据位置，读写速度就会比较慢。</li><li>固态磁盘（Silid State Disk），通常缩写为 SSD，由固态电子元件组成。固态磁盘不需要磁盘寻址，不管是连续 I/O，还是随机 I/O 的性能，都比机械磁盘要好得多。</li></ul><p>无论是机械磁盘，还是固态磁盘，相同磁盘的随机 I/O 都要比连续 I/O 慢得多，原因是：</p><ul><li>随机 I/O 需要更多的磁头寻道和盘片旋转，它的性能自然要比连续 I/O 慢</li><li>对于固态硬盘来说，虽然它的随机性能比机械磁盘好很多，但同样存在“先擦除再写入”的限制。随机读写会导致大量的垃圾回收，所以相对应的，随机 I/O 的性能比起连续 I/O 来，也还差了很多</li><li>连续 I/O 还可以通过预读的方式，来减少 I/O 请求的次数，这也是其性能优异的一个原因</li></ul><p>最小读写单位：</p><ul><li>机械硬盘的最小读写单位是扇区，一般是 512 字节</li><li>固态硬盘的最小读写单位是页，一般是 4KB 或者 8KB</li></ul><p>按照接口，磁盘可分为 IDE（Integrated Drive Electronics）、SCSI（Small Computer System Interface） 、SAS（Serial Attached SCSI） 、SATA（Serial ATA） 、FC（Fibre Channel）等。</p><p>磁盘介入服务器时，按照不通的使用方式，会划分为不用的架构：</p><ul><li>最简单的直接作为独立磁盘设备来使用</li><li>将多块磁盘组合成一个逻辑磁盘，构成冗余独立磁盘阵列（RAID），提高数据访问的性能，并增强数据存储的可靠性</li><li>最后一种，是将磁盘组合成网络存储集群，再通过 NFS、SMB、ISCSI 等网络存储协议，暴露给服务器使用</li></ul><p>在 Linux 中，磁盘是作为一个块设备来管理，以块为单位来读写，支持随机读写。每个块设备赋予两个设备号，分别是主、次设备号，主设备号用在驱动程序中，用来区分设备类型；次设备号用来在多个同类设备编号。</p><h3 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h3><p>和 VFS 类似，为了减少不同设备的差异带来的影响，Linux 通过统一的通用块（块 I/O 层），管理不同的块设备。</p><p>块设备层是处在文件系统和磁盘驱动中间的一个块设备抽象层，主要功能是：</p><ul><li>向上为文件系统和应用程序提供访问块设备的标准接口；向下，把各种异构的磁盘块设备抽象为统一的块设备，提供统一框架管理这些设备的驱动程序</li><li>通用块层还会给文件系统和应用程序发来 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率</li></ul><p>对 I/O 请求排序的过程就是 I/0 调度，Linux 支持的四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine：</p><ul><li>NONE，不适用任何调度，对 I/O 不做任何处理（常用在虚拟机，此时磁盘 I/O 完全由物理机复杂）</li><li>NOOP，先入先出调度（常用在 SSD）</li><li>CFQ（Completely Fair Schedule）完全公平调度器，很多 Linux 发行版的默认调度器，它为每个进程维护了一个 I/O 调度队列，按照时间片来均匀分配每个进程的 I/O 请求；还支持优先级调度，适用于大量进程的系统（如桌面、多媒体应用等）</li><li>DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保打到最终期限（deadline）的请求被优化处理，多用在 I/O 压力比较重的场景，比如数据库等</li></ul><h3 id="I-O-栈"><a href="#I-O-栈" class="headerlink" title="I/O 栈"></a>I/O 栈</h3><p><img src="/img/2025-06-02-linux_tracing_io/image3.png" alt="示意图"></p><p>根据这张 I/O 栈的全景图，可以看出存储系统 I/O 的工作原理</p><ul><li>文件系统层，包括虚拟文件系统和其他文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过快层，来存储和管理磁盘资源</li><li>通用块层，包括块设备 I/O 队列和 I/O 调度器。他会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发给下一级的设备层</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作</li></ul><p>存储系统的 I/O，通常是整个系统最慢的一环。</p><p>Linux 通过多种缓存机制来优化 I/O 效率。为了优化文件访问的性能，会使用页缓存、索引节点缓存等多种机制，以减少对下层块设配的直接调用。同样，为了优化块设备，会使用缓冲区，来缓存块设备的数据。</p><h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><p>使用率、饱和度、IOPS、吞吐量以及响应时间五个指标，是磁盘性能的基本指标</p><ul><li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈</li><li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求</li><li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数</li><li>吞吐量，是指每秒 I/O 请求大小</li><li>响应时间，是指 I/O 请求从发出到收到响应的间隔时间</li></ul><p>注意：</p><ol><li>使用率只考虑有没有 I/O，而不考虑 I/O 的大小。换句话说，当使用率是 100% 的时候，磁盘依然有可能接受到新的 I/O 请求</li><li>随即读写多（如数据库、大量小文件）的情况下主要关注 IOPS，而顺序读写（如流媒体）的情况下，主要关注吞吐量</li></ol><p>在为应用程序的服务器选型时，要先对磁盘的 I/O 性能进行基准测试，以便可以准确评估，磁盘性能是否可以满足应用程序的需求</p><h3 id="磁盘-I-O-观测"><a href="#磁盘-I-O-观测" class="headerlink" title="磁盘 I/O 观测"></a>磁盘 I/O 观测</h3><p>使用 iostat 观测每块磁盘的使用情况，提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，这些指标实际上来自 /proc/diskstats</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ iostat <span class="operator">-</span>dx <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span><span class="operator">-</span><span class="number">1160.76</span>.<span class="number">1</span>.el7.x86_64 (idc16)       <span class="number">2025</span>年<span class="number">06</span>月<span class="number">16</span>日  _x86_64_        (<span class="number">40</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="params">Device:</span>         rrqm<span class="symbol">/s</span>   wrqm<span class="symbol">/s</span>     r<span class="symbol">/s</span>     w<span class="symbol">/s</span>    rkB<span class="symbol">/s</span>    wkB<span class="symbol">/s</span> avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               <span class="number">0.00</span>     <span class="number">0.69</span>    <span class="number">1.56</span>   <span class="number">25.12</span>    <span class="number">62.56</span>   <span class="number">270.97</span>    <span class="number">25.01</span>     <span class="number">0.27</span>   <span class="number">10.01</span>    <span class="number">0.84</span>   <span class="number">10.58</span>   <span class="number">1.18</span>   <span class="number">3.14</span></span><br><span class="line">sdd               <span class="number">0.00</span>     <span class="number">0.27</span>    <span class="number">0.17</span>    <span class="number">1.33</span>    <span class="number">10.66</span>    <span class="number">42.08</span>    <span class="number">70.12</span>     <span class="number">0.01</span>    <span class="number">8.48</span>    <span class="number">6.95</span>    <span class="number">8.68</span>   <span class="number">0.26</span>   <span class="number">0.04</span></span><br><span class="line">sdc               <span class="number">0.00</span>     <span class="number">0.61</span>    <span class="number">0.27</span>    <span class="number">9.80</span>    <span class="number">13.02</span>   <span class="number">193.43</span>    <span class="number">41.03</span>     <span class="number">0.04</span>    <span class="number">3.52</span>    <span class="number">0.82</span>    <span class="number">3.59</span>   <span class="number">0.06</span>   <span class="number">0.06</span></span><br><span class="line">sde               <span class="number">0.00</span>     <span class="number">0.22</span>    <span class="number">0.21</span>    <span class="number">1.38</span>    <span class="number">11.79</span>    <span class="number">43.80</span>    <span class="number">70.07</span>     <span class="number">0.01</span>    <span class="number">8.43</span>    <span class="number">7.23</span>    <span class="number">8.61</span>   <span class="number">0.26</span>   <span class="number">0.04</span></span><br><span class="line">sdf               <span class="number">0.00</span>     <span class="number">0.24</span>    <span class="number">0.07</span>    <span class="number">1.29</span>    <span class="number">13.02</span>    <span class="number">18.95</span>    <span class="number">47.09</span>     <span class="number">0.00</span>    <span class="number">3.29</span>   <span class="number">17.06</span>    <span class="number">2.56</span>   <span class="number">0.20</span>   <span class="number">0.03</span></span><br><span class="line">sdh               <span class="number">0.00</span>     <span class="number">0.26</span>    <span class="number">0.01</span>    <span class="number">1.32</span>     <span class="number">1.49</span>    <span class="number">19.72</span>    <span class="number">31.78</span>     <span class="number">0.00</span>    <span class="number">1.70</span>    <span class="number">9.23</span>    <span class="number">1.63</span>   <span class="number">0.09</span>   <span class="number">0.01</span></span><br><span class="line">sdg               <span class="number">0.00</span>     <span class="number">0.23</span>    <span class="number">0.05</span>    <span class="number">1.30</span>    <span class="number">11.18</span>    <span class="number">21.33</span>    <span class="number">48.10</span>     <span class="number">0.01</span>    <span class="number">4.07</span>   <span class="number">24.12</span>    <span class="number">3.28</span>   <span class="number">0.21</span>   <span class="number">0.03</span></span><br><span class="line">sdi               <span class="number">0.00</span>     <span class="number">0.28</span>    <span class="number">0.04</span>    <span class="number">1.67</span>     <span class="number">9.65</span>    <span class="number">19.50</span>    <span class="number">33.96</span>     <span class="number">0.00</span>    <span class="number">1.86</span>   <span class="number">25.33</span>    <span class="number">1.26</span>   <span class="number">0.15</span>   <span class="number">0.03</span></span><br><span class="line">sdj               <span class="number">0.00</span>     <span class="number">0.24</span>    <span class="number">0.36</span>    <span class="number">2.35</span>    <span class="number">21.61</span>   <span class="number">247.35</span>   <span class="number">198.58</span>     <span class="number">0.14</span>   <span class="number">51.46</span>    <span class="number">4.47</span>   <span class="number">58.60</span>   <span class="number">0.49</span>   <span class="number">0.13</span></span><br><span class="line">sdb               <span class="number">0.00</span>     <span class="number">0.46</span>    <span class="number">1.66</span>    <span class="number">8.00</span>   <span class="number">180.35</span>   <span class="number">210.13</span>    <span class="number">80.81</span>     <span class="number">0.08</span>    <span class="number">8.74</span>    <span class="number">2.84</span>    <span class="number">9.97</span>   <span class="number">0.20</span>   <span class="number">0.19</span></span><br><span class="line">dm-<span class="number">0</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.85</span>   <span class="number">18.11</span>    <span class="number">38.11</span>   <span class="number">144.32</span>    <span class="number">19.24</span>     <span class="number">0.17</span>    <span class="number">8.82</span>    <span class="number">0.56</span>    <span class="number">9.21</span>   <span class="number">1.14</span>   <span class="number">2.16</span></span><br><span class="line">dm-<span class="number">1</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">49.16</span>     <span class="number">0.00</span>   <span class="number">11.10</span>   <span class="number">11.10</span>    <span class="number">0.00</span>   <span class="number">9.62</span>   <span class="number">0.00</span></span><br><span class="line">scd0              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">80.31</span>     <span class="number">0.00</span>  <span class="number">813.35</span>  <span class="number">813.35</span>    <span class="number">0.00</span> <span class="number">809.27</span>   <span class="number">0.00</span></span><br><span class="line">dm-<span class="number">2</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.21</span>     <span class="number">0.04</span>    <span class="number">16.16</span>   <span class="number">155.78</span>     <span class="number">0.02</span>   <span class="number">99.54</span>    <span class="number">2.63</span>  <span class="number">100.60</span>   <span class="number">1.79</span>   <span class="number">0.04</span></span><br><span class="line">dm-<span class="number">3</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.68</span>    <span class="number">4.54</span>    <span class="number">22.80</span>    <span class="number">72.63</span>    <span class="number">36.54</span>     <span class="number">0.07</span>   <span class="number">14.35</span>    <span class="number">1.04</span>   <span class="number">16.35</span>   <span class="number">1.31</span>   <span class="number">0.69</span></span><br><span class="line">dm-<span class="number">4</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.02</span>    <span class="number">2.93</span>     <span class="number">0.38</span>    <span class="number">37.73</span>    <span class="number">25.90</span>     <span class="number">0.03</span>   <span class="number">10.70</span>    <span class="number">4.72</span>   <span class="number">10.73</span>   <span class="number">1.32</span>   <span class="number">0.39</span></span><br></pre></td></tr></table></figure><p>各个指标解读如下</p><p><img src="/img/2025-06-02-linux_tracing_io/image4.png" alt="iostat 指标解读图"></p><p>注意：</p><ul><li>%util，就是我们前面提到的磁盘 I/O 使用率</li><li>r/s + w/s，就是 IOPS</li><li>rkB/s + wkB/s，就是吞吐量</li><li>r_await+w_await，就是响应时间</li></ul><p>在观测指标时，可以结合请求的大小（rareq-sz 和 wareq-sz）一起分析。</p><h3 id="进程-I-O-观测"><a href="#进程-I-O-观测" class="headerlink" title="进程 I/O 观测"></a>进程 I/O 观测</h3><p>pidstat 可以实时查看某个进程的 I/O 情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -d 1</span><br><span class="line">Linux 3.10.0-957.el7.x86_64 (xxx)       06/17/2025      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">07:12:18 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">07:12:19 PM   <span class="number"> 27 </span>  <span class="number"> 362006 </span>     0.00    594.17    590.29  mysqld</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362323 </span>     0.00      3.88      3.88  docker-containe</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362403 </span>     0.00      7.77      0.00  kundb-meta-serv</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362518 </span>     0.00      3.88      0.00  java</span><br><span class="line">07:12:19 PM<span class="number"> 65534 </span>  <span class="number"> 363123 </span>     0.00      3.88      0.00  prometheus</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 372218 </span>     0.00      7.77      0.00  java</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 383196 </span>     0.00     19.42      0.00  dockerd</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 389626 </span>     0.00     23.30      0.00  kube-apiserver</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 389731 </span>     0.00     62.14      0.00  etcd</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 391157 </span>     0.00     11.65      0.00  kubelet</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 760300 </span>     0.00     11.65      0.00  kundb-meta-serv</span><br></pre></td></tr></table></figure><p>指标如下：</p><ul><li>用户 ID（UID）和进程 ID（PID）</li><li>每秒读取的数据大小（kB_rd/s），单位是 KB</li><li>每秒发出的写请求数据大小（kB_wr/s），单位是 KB</li><li>每秒取消的写请求数据大小（KB_ccwr/s），单位是 KB</li></ul>]]></content>
    
    
    <summary type="html">本文深入探讨Linux文件系统与磁盘I/O的工作原理，分析缓存I/O与直接I/O的差异，详解索引节点、虚拟文件系统及I/O调度算法，并提供df、iostat等工具的性能观测方法，助力系统性能调优。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何“快准狠”找到系统内存的问题</title>
    <link href="https://wu3227834.github.io/2025/05/30/2025-05-30-ru-he-kuai-zhun-hen-de-zhao-dao-xi-tong-nei-cun-wen-ti/"/>
    <id>https://wu3227834.github.io/2025/05/30/2025-05-30-ru-he-kuai-zhun-hen-de-zhao-dao-xi-tong-nei-cun-wen-ti/</id>
    <published>2025-05-30T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存性能指标"><a href="#内存性能指标" class="headerlink" title="内存性能指标"></a>内存性能指标</h2><p>系统调用内存分配请求后，并不会立刻为其分配物理内存，而是在请求首次访问时，通过缺页异常来分配</p><p>缺页异常又分为以下两种场景：</p><ul><li>可以直接从物理内存中分配时，被称为<strong>次缺页异常</strong></li><li>需要磁盘 I/O 介入（比如 Swap）时，被称为<strong>主缺页异常</strong></li></ul><p><img src="/img/2025-05-30-%E5%A6%82%E4%BD%95%E5%BF%AB%E5%87%86%E7%8B%A0%E7%9A%84%E6%89%BE%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/image.png" alt="内存性能指标"></p><h2 id="分析内存性能瓶颈"><a href="#分析内存性能瓶颈" class="headerlink" title="分析内存性能瓶颈"></a>分析内存性能瓶颈</h2><p>分析过程如下图</p><ul><li>先用 free 和 top，查看系统整体的内存使用情况</li><li>再用 vmstat 和 pidstat，查看一段时间的趋势，从而判断出内存问题的类型</li><li>最后进行详细分析，比如内存分配分析、缓存/缓冲区分析、具体进程的内存使用分析等</li></ul><p><img src="/img/2025-05-30-%E5%A6%82%E4%BD%95%E5%BF%AB%E5%87%86%E7%8B%A0%E7%9A%84%E6%89%BE%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/image2.png" alt="分析内存性能"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内存常见的优化思路有这么几种</p><ul><li>最好禁止 Swap。如果必须开启 Swap，降低 swappiness 的值，减少内存回收时 Swap 的使用倾向</li><li>减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等</li><li>尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问</li><li>使用 cgroups 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽</li><li>通过 /proc/pid/oom_adj，调整核心应用的 oom_score。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死</li></ul>]]></content>
    
    
    <summary type="html">本文介绍如何通过工具快速定位 Linux 系统内存瓶颈并提供优化建议</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：内存</title>
    <link href="https://wu3227834.github.io/2025/05/28/2025-05-28-linux-tracing-mem/"/>
    <id>https://wu3227834.github.io/2025/05/28/2025-05-28-linux-tracing-mem/</id>
    <published>2025-05-28T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux内存工作原理"><a href="#Linux内存工作原理" class="headerlink" title="Linux内存工作原理"></a>Linux内存工作原理</h2><h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。</p><p>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。</p><p>对大块内存（大于 128K），则使用内存映射 mmap() 来分配，也就是在文件映射找一块空闲内存分配出去。</p><p>各自的<strong>优缺点</strong>：</p><ul><li>brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率；不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片</li><li>mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大</li></ul><p>整体来说，Linux 使用<strong>伙伴系统</strong>来管理内存分配。前面我们提到过，这些内存在 MMU 中以页为单位进行管理，伙伴系统也一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如 brk 方法造成的内存碎片）。</p><p>在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 通过 slab 分配器来管理小内存，可以把 slab 堪称构建在<strong>伙伴系统上的一个缓存</strong>，主要作用就是分配并释放内核中的小对象。</p><p>系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统会通过一系列机制来回收内存：</p><ul><li>回收内存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面</li><li>回收不常访问的内存，把不常用的内存交换分区直接写到磁盘中（会用到交换分区）</li><li>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程</li></ul><p>OOM 是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：</p><ul><li>进程消耗的内存越大，oom_score 就越大</li><li>进程运行占用的 CPU 越多，oom_score 就越小</li></ul><p>可以手动设置进程的 oom_adj 来调整 oom_score。oom_adj 的范围是 [-17, 15]，数值越大，进程越容易被杀死；反之，越不容易被杀死。</p><h3 id="如何查看内存使用情况"><a href="#如何查看内存使用情况" class="headerlink" title="如何查看内存使用情况"></a>如何查看内存使用情况</h3><p>1、free 命令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:     <span class="number"> 262695500 </span> <span class="number"> 106731876 </span> <span class="number"> 141173212 </span>   <span class="number"> 4257008 </span>  <span class="number"> 14790412 </span>  149168720</span><br><span class="line">Swap:            <span class="number"> 0 </span>         <span class="number"> 0 </span>          0</span><br></pre></td></tr></table></figure><ul><li>total：总内存</li><li>used：已使用内存，包括共享内存</li><li>free：空闲内存</li><li>shared：共享内存</li><li>buff/cache：缓存内存，包括缓冲区和缓存</li><li>available：可用内存，包括空闲内存和缓存内存</li></ul><p><strong>注意</strong>：available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>2、top 命令</p><p>可以查看每个进程的内存使用情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top - 19:28:02 up<span class="number"> 201 </span>days,  2:48, <span class="number"> 2 </span>users,  load average: 134.36, 136.81, 111.38</span><br><span class="line">Tasks:<span class="number"> 1284 </span>total,  <span class="number"> 6 </span>running,<span class="number"> 1278 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s): 87.2 us,  8.9 sy,  0.0 ni,  0.9 id,  0.0 wa,  1.8 hi,  1.1 si,  0.0 st</span><br><span class="line">MiB Mem : 256538.6 total, 137892.3 free, 104201.3 used,  14445.0 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used. 145701.9 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number"> 607070 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> 266.3g  82.5g <span class="number"> 79228 </span>S <span class="number"> 4861 </span> 33.0  40025:32 tabletserver_ma</span><br><span class="line"><span class="number"> 835494 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>8557368<span class="number"> 207048 </span><span class="number"> 10872 </span>S 121.7   0.1 357:04.40 java</span><br><span class="line"><span class="number"> 842048 </span>1001     <span class="number"> 20 </span> <span class="number"> 0 </span>  32.8g <span class="number"> 31168 </span><span class="number"> 14888 </span>S 113.0   0.0   0:03.41 java</span><br><span class="line"><span class="number"> 840498 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 727932 </span><span class="number"> 31336 </span> <span class="number"> 7304 </span>R  91.3   0.0   2164:46 node_exporter</span><br><span class="line"><span class="number"> 653917 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>  12.3g<span class="number"> 997944 </span><span class="number"> 46948 </span>S  78.3   0.4  15877:42 kubelet</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>VIRT：虚拟内存，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内</li><li>RES：实际内存，也就是进程<strong>实际使用的物理内存</strong>大小，但<strong>不包括 Swap 和共享内存</strong></li><li>SHR：共享内存，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等</li><li>%MEM：进程占用的物理内存占系统总内存的百分比</li></ul><p><strong>注意</strong>：</p><ul><li>虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都大于实际内存，这是因为虚拟内存是进程申请的内存，即使进程没有真正分配物理内存，也会计算在内。</li><li>共享内存 SHR 并不一定是共享的，比方说，<strong>程序的代码段、非共享的动态内存链接库</strong>，也都在 SHR 里。SHR 也包括了<strong>进程间真正共享的内存</strong>。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果</li></ul><h2 id="内存的-Buffer-和-Cache"><a href="#内存的-Buffer-和-Cache" class="headerlink" title="内存的 Buffer 和 Cache"></a>内存的 Buffer 和 Cache</h2><h3 id="free-的数据来源"><a href="#free-的数据来源" class="headerlink" title="free 的数据来源"></a>free 的数据来源</h3><p>man free 查看</p><p><img src="/img/2025-05-28-linux_tracing_mem/image.png" alt="man free"></p><p>从手册看到：</p><ul><li>Buffers：Memory used by kernel buffers (Buffers in /proc/meminfo)</li><li>Cache：Memory used by the page cache and slabs (Cached and Slab in /proc/meminfo)</li></ul><h3 id="proc-文件系统"><a href="#proc-文件系统" class="headerlink" title="proc 文件系统"></a>proc 文件系统</h3><p>man proc 查看</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Buffers %lu</span><br><span class="line">       Relatively temporary storage <span class="keyword">for</span> raw disk blocks <span class="keyword">that</span> shouldn&#x27;t <span class="keyword">get</span> tremendously large (<span class="number">20</span>MB <span class="keyword">or</span> so).</span><br><span class="line"></span><br><span class="line">Cached %lu</span><br><span class="line">       In-memory cache <span class="keyword">for</span> files <span class="built_in">read</span> <span class="keyword">from</span> <span class="keyword">the</span> disk (<span class="keyword">the</span> page cache).  Doesn&#x27;t include SwapCached.</span><br><span class="line">...</span><br><span class="line">SReclaimable %lu (<span class="keyword">since</span> Linux <span class="number">2.6</span><span class="number">.19</span>)</span><br><span class="line">       Part <span class="keyword">of</span> Slab, <span class="keyword">that</span> might be reclaimed, such <span class="keyword">as</span> caches.</span><br><span class="line"></span><br><span class="line">SUnreclaim %lu (<span class="keyword">since</span> Linux <span class="number">2.6</span><span class="number">.19</span>)</span><br><span class="line">       Part <span class="keyword">of</span> Slab, <span class="keyword">that</span> cannot be reclaimed <span class="keyword">on</span> memory pressure.</span><br></pre></td></tr></table></figure><p>通过文档可以看到：</p><ul><li>Buffers 是对原始磁盘的临时存储，也就是用来缓存磁盘的数据，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写入合并成单次大的写等等。</li><li>Cached 是从单磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li><li>Slab 代表内核数据结构缓存，包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。</li></ul><h2 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h2><h3 id="场景一：磁盘和文件写"><a href="#场景一：磁盘和文件写" class="headerlink" title="场景一：磁盘和文件写"></a>场景一：磁盘和文件写</h3><p>运行 vmstat 命令</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16790772</span>     <span class="number">60 8758252</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218088</span> <span class="number">16779960</span>     <span class="number">60 8762060</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">159 15274</span> <span class="number">28820 16</span>  <span class="number">9</span> <span class="number">75</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">16779968</span>     <span class="number">60 8761840</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">154 13467</span> <span class="number">26984</span>  <span class="number">9</span>  <span class="number">4</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16778620</span>     <span class="number">60 8762068</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">212 13980</span> <span class="number">26715</span>  <span class="number">6</span>  <span class="number">5</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">0 1218088</span> <span class="number">16773376</span>     <span class="number">60 8762136</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">170 12838</span> <span class="number">25315</span>  <span class="number">4</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">16780544</span>     <span class="number">60 8762164</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">343 13195</span> <span class="number">25313</span>  <span class="number">5</span>  <span class="number">4</span> <span class="number">91</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16783260</span>     <span class="number">60 8762392</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">116 18099</span> <span class="number">33200 13 10</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16782896</span>     <span class="number">60 8762400</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">40 10645</span> <span class="number">21760</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16780616</span>     <span class="number">60 8762412</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">97 12603</span> <span class="number">24496</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16780708</span>     <span class="number">60 8762436</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">90 14724</span> <span class="number">27729</span>  <span class="number">9</span>  <span class="number">4</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16779376</span>     <span class="number">60 8762472</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">116 12702</span> <span class="number">25101</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16775968</span>     <span class="number">60 8765976</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">133 16290</span> <span class="number">29873 19 10</span> <span class="number">71</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16783224</span>     <span class="number">60 8765996</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">89 13359</span> <span class="number">25299</span>  <span class="number">4</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16782604</span>     <span class="number">60 8766016</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">73 10976</span> <span class="number">22399</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">16775272</span>     <span class="number">60 8766032</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">122 13109</span> <span class="number">26159</span>  <span class="number">4</span>  <span class="number">2</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>buff 和 cache 就是我们前面看到的 Buffers 和 Cache，单位是 KB</li><li>bi 和 bo 则分别表示块设备读取和写入的大小，单位为 块/秒。因为 Linux 中块的大小是 1KB，所以这个单位也就等价于 KB/s</li></ul><p>在另一中端执行 dd 命令通过读取随机设备，生成一个 500MB 大小的文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/urandom <span class="attribute">of</span>=/mnt/disk1/log <span class="attribute">bs</span>=1M <span class="attribute">count</span>=500</span><br></pre></td></tr></table></figure><p>继续观察 buff 和 cache 的变化如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu--<span class="language-yaml"><span class="meta">---</span></span></span><br><span class="line"><span class="language-yaml"> <span class="string">r</span>  <span class="string">b</span>   <span class="string">swpd</span>   <span class="string">free</span>   <span class="string">buff</span>  <span class="string">cache</span>   <span class="string">si</span>   <span class="string">so</span>    <span class="string">bi</span>    <span class="string">bo</span>   <span class="string">in</span>   <span class="string">cs</span> <span class="string">us</span> <span class="string">sy</span> <span class="string">id</span> <span class="string">wa</span> <span class="string">st</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">6</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16808024</span>     <span class="number">60</span> <span class="number">8706284</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">135</span> <span class="number">17194</span> <span class="number">30511</span> <span class="number">12</span>  <span class="number">5</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">2</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16812680</span>     <span class="number">60</span> <span class="number">8706316</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">108</span> <span class="number">14214</span> <span class="number">27386</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">0</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16822344</span>     <span class="number">60</span> <span class="number">8706268</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">82</span> <span class="number">12608</span> <span class="number">25281</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">0</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16828356</span>     <span class="number">60</span> <span class="number">8706284</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">65</span> <span class="number">16971</span> <span class="number">31578</span>  <span class="number">6</span>  <span class="number">5</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"><span class="string">...</span></span></span><br><span class="line"><span class="number"> 1 </span><span class="number"> 2 </span>1218088<span class="number"> 16438876 </span>   <span class="number"> 60 </span>9110220   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>264629<span class="number"> 19007 </span>27977 <span class="number"> 5 </span>20<span class="number"> 73 </span><span class="number"> 1 </span> 0</span><br><span class="line"><span class="number"> 8 </span><span class="number"> 1 </span>1218088<span class="number"> 16324916 </span>   <span class="number"> 60 </span>9227456   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>22966<span class="number"> 20049 </span>31235<span class="number"> 13 </span>21<span class="number"> 61 </span><span class="number"> 5 </span> 0</span><br><span class="line"><span class="number"> 2 </span><span class="number"> 0 </span>1218088<span class="number"> 16329904 </span>   <span class="number"> 60 </span>9227244   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 327 </span>11770<span class="number"> 24005 </span><span class="number"> 4 </span><span class="number"> 3 </span>87 <span class="number"> 7 </span> 0</span><br><span class="line"><span class="number"> 0 </span><span class="number"> 0 </span>1218088<span class="number"> 16329340 </span>   <span class="number"> 60 </span>9227248   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>  <span class="number"> 91 </span>11558<span class="number"> 22878 </span><span class="number"> 3 </span><span class="number"> 2 </span>95 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 5 </span><span class="number"> 0 </span>1218088<span class="number"> 16329532 </span>   <span class="number"> 60 </span>9227264   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>  <span class="number"> 88 </span>14350<span class="number"> 28661 </span>10 <span class="number"> 5 </span>85 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 1 </span><span class="number"> 0 </span>1218088<span class="number"> 16325480 </span>   <span class="number"> 60 </span>9227056   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 162 </span>16735<span class="number"> 30309 </span>11 <span class="number"> 8 </span>81 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 2 </span><span class="number"> 1 </span>1218088<span class="number"> 16325424 </span>   <span class="number"> 60 </span>9230360   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>225680<span class="number"> 15589 </span>31332<span class="number"> 15 </span>10<span class="number"> 72 </span><span class="number"> 2 </span> 1</span><br><span class="line"><span class="number"> 1 </span><span class="number"> 0 </span>1218088<span class="number"> 16325160 </span>   <span class="number"> 60 </span>9231060   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 124 </span>14815<span class="number"> 26517 </span>10 <span class="number"> 6 </span>79 <span class="number"> 5 </span> 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>在 dd 命令运行时，Cache 在不停地增长，而 Buffer 基本保持不变</li><li>在 dd 命令结束后，Cache 不再增长，但是块设备写还会持续一段时间，并且，多次 1/0 写的结果加起来，才是 dd 要写的 500M 的数据</li></ul><p>下面的命令对环境要求很高，需要你的系统配置多块磁盘，并且磁盘分区 /dev/sdb1 还要处于未使用状态。<strong>如果你只有一块磁盘，千万不要尝试，否则将会对你的磁盘分区造成损坏</strong>。</p><p>如果你的系统符合标准，就可以继续在第二个终端中，运行下面的命令。清理缓存后，向磁盘分区 /dev/sdb1 写入 2GB 的随机数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先清理缓存</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后运行 <span class="built_in">dd</span> 命令向磁盘分区 /dev/sdb1 写入 2G 数据$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=/dev/sdb1 bs=1M count=2048</span></span><br></pre></td></tr></table></figure><p>然后，再回到终端一，观察内存和 I/O 的变化情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">procs</span> -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> <span class="attribute">r</span> b swpd free buff cache si so bi bo in cs us sy id wa st</span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7584780</span> <span class="number">153592</span> <span class="number">97436</span> <span class="number">0</span> <span class="number">0</span> <span class="number">684</span> <span class="number">0</span> <span class="number">31</span> <span class="number">423</span> <span class="number">1</span> <span class="number">48</span> <span class="number">50</span> <span class="number">2</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7418580</span> <span class="number">315384</span> <span class="number">101668</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">32</span> <span class="number">144</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7253664</span> <span class="number">475844</span> <span class="number">106208</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">20</span> <span class="number">137</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7093352</span> <span class="number">631800</span> <span class="number">110520</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">23</span> <span class="number">223</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6930056</span> <span class="number">790520</span> <span class="number">114980</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12804</span> <span class="number">23</span> <span class="number">168</span> <span class="number">0</span> <span class="number">50</span> <span class="number">42</span> <span class="number">9</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6757204</span> <span class="number">949240</span> <span class="number">119396</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">183804</span> <span class="number">24</span> <span class="number">191</span> <span class="number">0</span> <span class="number">53</span> <span class="number">26</span> <span class="number">21</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6591516</span> <span class="number">1107960</span> <span class="number">123840</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">77316</span> <span class="number">22</span> <span class="number">232</span> <span class="number">0</span> <span class="number">52</span> <span class="number">16</span> <span class="number">33</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>从这里你会看到，虽然同是写数据，写磁盘跟写文件的现象还是不同的。写磁盘时（也就是 bo 大于 0 时），Buffer 和 Cache 都在增长，但显然 Buffer 的增长快得多。</p><h3 id="场景二：磁盘和文件读"><a href="#场景二：磁盘和文件读" class="headerlink" title="场景二：磁盘和文件读"></a>场景二：磁盘和文件读</h3><p>运行文件读的命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件读</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/mnt/disk1/log of=/dev/null</span></span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="number">3</span> &gt; /proc/sys/vm/drop_caches</span><br><span class="line">$ mstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">22631652</span>      <span class="number">0 3037032</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">792</span>   <span class="number">225 15443</span> <span class="number">29060 17</span>  <span class="number">8</span> <span class="number">75</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">22629780</span>      <span class="number">0 3037096</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">48</span>    <span class="number">33 13210</span> <span class="number">25184</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">22474456</span>      <span class="number">0 3192744</span>    <span class="number">0</span>    <span class="number">0 155593</span>   <span class="number">379 11851</span> <span class="number">21896</span>  <span class="number">4</span>  <span class="number">6</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">0 1218088</span> <span class="number">22184464</span>      <span class="number">0 3471364</span>    <span class="number">0</span>    <span class="number">0 282644</span>   <span class="number">181 13324</span> <span class="number">22371</span>  <span class="number">5</span> <span class="number">12</span> <span class="number">83</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">22119672</span>      <span class="number">0 3549248</span>    <span class="number">0</span>    <span class="number">0 73920</span>    <span class="number">82 14720</span> <span class="number">26164</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">84</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">22118224</span>      <span class="number">0 3549468</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">136</span>    <span class="number">29 17030</span> <span class="number">32835 13</span>  <span class="number">9</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">22116736</span>      <span class="number">0 3549488</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">80</span>   <span class="number">327 11854</span> <span class="number">23476</span>  <span class="number">4</span>  <span class="number">2</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>运行磁盘读的命令如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 磁盘读</span></span><br><span class="line">$ dd <span class="attribute">if</span>=/dev/vdc <span class="attribute">of</span>=/dev/null <span class="attribute">bs</span>=1M <span class="attribute">count</span>=1024</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ dvmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">6</span>  <span class="number">0 1218088</span> <span class="number">21827684</span>      <span class="number">0 3716568</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218088</span> <span class="number">21816680</span>      <span class="number">0 3721036</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">117 16130</span> <span class="number">30199 16 11</span> <span class="number">73</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">21819240</span>      <span class="number">0 3720212</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">9</span>   <span class="number">195 14200</span> <span class="number">26901</span>  <span class="number">6</span>  <span class="number">4</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">21818228</span>      <span class="number">0 3720252</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">4</span>   <span class="number">123 11836</span> <span class="number">23517</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">95</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">21802832</span>  <span class="number">14336</span> <span class="number">3720200</span>    <span class="number">0</span>    <span class="number">0 17369</span>   <span class="number">248 10953</span> <span class="number">21760</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">91</span>  <span class="number">4</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21740512</span>  <span class="number">75776</span> <span class="number">3720308</span>    <span class="number">0</span>    <span class="number">0 58416</span>    <span class="number">77 14897</span> <span class="number">27732</span>  <span class="number">4</span>  <span class="number">5</span> <span class="number">79</span> <span class="number">11</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">3</span>  <span class="number">1 1218088</span> <span class="number">21696460</span> <span class="number">133120</span> <span class="number">3720692</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">76 20717</span> <span class="number">40621 14 10</span> <span class="number">66</span>  <span class="number">9</span>  <span class="number">0</span></span><br><span class="line"><span class="number">10</span>  <span class="number">0 1218088</span> <span class="number">21639256</span> <span class="number">190464</span> <span class="number">3720328</span>    <span class="number">0</span>    <span class="number">0 57372</span>   <span class="number">349 18512</span> <span class="number">29321 11</span>  <span class="number">5</span> <span class="number">75</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21600056</span> <span class="number">247808</span> <span class="number">3720308</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">72 17332</span> <span class="number">28977 10</span>  <span class="number">5</span> <span class="number">74</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">1 1218088</span> <span class="number">21539120</span> <span class="number">296960</span> <span class="number">3720340</span>    <span class="number">0</span>    <span class="number">0 49152</span>   <span class="number">688 22618</span> <span class="number">37060 16</span>  <span class="number">8</span> <span class="number">66</span>  <span class="number">9</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">1 1218088</span> <span class="number">21473532</span> <span class="number">354304</span> <span class="number">3720184</span>    <span class="number">0</span>    <span class="number">0 57348</span>   <span class="number">109 18331</span> <span class="number">30615</span>  <span class="number">9</span>  <span class="number">5</span> <span class="number">74</span> <span class="number">11</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">1 1218088</span> <span class="number">21414276</span> <span class="number">407552</span> <span class="number">3723624</span>    <span class="number">0</span>    <span class="number">0 53248</span>   <span class="number">150 16057</span> <span class="number">29868 17</span>  <span class="number">9</span> <span class="number">64</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">1 1218088</span> <span class="number">21356020</span> <span class="number">464896</span> <span class="number">3723924</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">29 14159</span> <span class="number">25301 12</span>  <span class="number">4</span> <span class="number">74</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21302964</span> <span class="number">518144</span> <span class="number">3723736</span>    <span class="number">0</span>    <span class="number">0 53248</span>   <span class="number">147 10678</span> <span class="number">21725</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">84</span> <span class="number">12</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">21278632</span> <span class="number">542720</span> <span class="number">3724092</span>    <span class="number">0</span>    <span class="number">0 24576</span>   <span class="number">428 10163</span> <span class="number">21080</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">91</span>  <span class="number">5</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">21269044</span> <span class="number">542720</span> <span class="number">3724072</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">73 15601</span> <span class="number">29313</span>  <span class="number">7</span>  <span class="number">5</span> <span class="number">88</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">23</span>  <span class="number">0 1218088</span> <span class="number">21272568</span> <span class="number">542720</span> <span class="number">3724488</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">33 20061</span> <span class="number">36123 22 12</span> <span class="number">67</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到，读取文件时（也就是 bi 大于 0 时），Buffer 保持不变，而 Cache 则在不停增长；而读取磁盘时，Cache 保持不变，Buffer 不断增长。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。</p>]]></content>
    
    
    <summary type="html">深入剖析 Linux 内存管理机制，涵盖 malloc、brk、mmap、slab 分配器、OOM 杀手原理，并结合 free、top、vmstat 等命令，详解内存分析与调优实践，助你高效定位系统内存瓶颈。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>系统的Swap机制</title>
    <link href="https://wu3227834.github.io/2025/05/16/2025-05-16-xi-tong-de-swap-ji-zhi/"/>
    <id>https://wu3227834.github.io/2025/05/16/2025-05-16-xi-tong-de-swap-ji-zhi/</id>
    <published>2025-05-16T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文件页</strong>：代表可回收内存，文件页的大部分可以直接回收，以后有需要时，再从磁盘重新读取；而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放</p><p>脏页一般以两个方式写入磁盘：</p><ul><li>在应用程序中，通过系统调用 fync，把脏页同步到磁盘中</li><li>由内核线程 pdflush 负载这些脏页的刷新</li></ul><p><strong>匿名页</strong>：应用程序动态分配的<strong>堆空间</strong>，使用 swap 机制回收</p><h2 id="Swap-原理"><a href="#Swap-原理" class="headerlink" title="Swap 原理"></a>Swap 原理</h2><p>Swap 简单来说就是把一块磁盘空间或者一个本地文件夹，当成内存来使用。它包括换出和换入两个过程：</p><ul><li><strong>换出</strong>，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存</li><li><strong>换入</strong>，则是把进程再次访问这些内存的时候，把它们从磁盘读到内存中来</li></ul><p>常见的笔记本电脑的休眠和快速开机功能，也基于 Swap。休眠时，把系统的内存存入磁盘，这样等到再次开机时，只要从磁盘中加载内存就可以。这样省去了很多应用程序的初始化过程，加快了开机速度。</p><p>内存回收的时机：</p><p>1、<strong>直接内存回收</strong>：当有新的大块内存分配请求，但是剩余内存不足，这个时候系统就需要回收一部分内存</p><p>2、<strong>内核线程 kswapd0</strong>来定期回收内存，它定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页最低阈值（pages_low）和页最高阈值（pages_high）。剩余内存，则使用 pages_free 表示</p><p><img src="/img/2025-05-16-%E7%B3%BB%E7%BB%9F%E7%9A%84Swap%E6%9C%BA%E5%88%B6/image.png" alt="pages_free"></p><p>kswapd0 定期扫描内存的使用情况，并根据剩余内存落在这三个阈值的空间位置，进行内存的会后操作：</p><ul><li>剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配空间</li><li>剩余内存落在页最小阈值和页最低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止</li><li>剩余内存落在页最低阈值和页最高阈值中间，说明内存有一定压力，但还可以满足新压力请求</li><li>剩余内存大于页内存阈值，说明剩余内存比较多，没有内存压力</li></ul><p><strong>页低阈值</strong>是由内核选项 /proc/sys/vm/min_free_kbytes 设置，其他两个阈值，都是根据页最小阈值计算生成的</p><h2 id="NUMA-和-Swap"><a href="#NUMA-和-Swap" class="headerlink" title="NUMA 和 Swap"></a>NUMA 和 Swap</h2><p>在 NUMA 架构下，多个处理器被划分到不同 Node 上，且每个 Node 都拥有自己的本地内存空间。而同一个 Node 内部的内存空间，实际上又可以在进一步分为不同的内存域（Zone），比如直接内存访问区（DMA）、普通内存区（NORMAL）、伪内存区（MOVABLE）等，如下图所示：</p><p><img src="/img/2025-05-16-%E7%B3%BB%E7%BB%9F%E7%9A%84Swap%E6%9C%BA%E5%88%B6/image2.png" alt="Node 内部的内存空间"></p><p>使用 numactl 命令查看 Node 的分布情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --hardware</span><br><span class="line">available:<span class="number"> 2 </span>nodes (0-1)</span><br><span class="line">node<span class="number"> 0 </span>cpus:<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 20 </span>21<span class="number"> 22 </span>23<span class="number"> 24 </span>25<span class="number"> 26 </span>27<span class="number"> 28 </span>29</span><br><span class="line">node<span class="number"> 0 </span>size:<span class="number"> 130960 </span>MB</span><br><span class="line">node<span class="number"> 0 </span>free:<span class="number"> 7308 </span>MB</span><br><span class="line">node<span class="number"> 1 </span>cpus:<span class="number"> 10 </span>11<span class="number"> 12 </span>13<span class="number"> 14 </span>15<span class="number"> 16 </span>17<span class="number"> 18 </span>19<span class="number"> 30 </span>31<span class="number"> 32 </span>33<span class="number"> 34 </span>35<span class="number"> 36 </span>37<span class="number"> 38 </span>39</span><br><span class="line">node<span class="number"> 1 </span>size:<span class="number"> 131072 </span>MB</span><br><span class="line">node<span class="number"> 1 </span>free:<span class="number"> 17581 </span>MB</span><br><span class="line">node distances:</span><br><span class="line">node  <span class="number"> 0 </span>  1</span><br><span class="line">  0: <span class="number"> 10 </span> 21</span><br><span class="line">  1: <span class="number"> 21 </span> 10</span><br></pre></td></tr></table></figure><p>前面提到的三个内存阈值（页最小阈值、页低阈值和页高阈值），都可以通过内存域在 proc 文件系统中的接口 /proc/zoneinfo 来查看</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat /<span class="keyword">proc</span>/zoneinfo|<span class="title"> head</span> -n 20<span class="title"></span></span><br><span class="line"><span class="title">Node</span> 0,<span class="title"> zone</span> <span class="title">     DMA</span></span><br><span class="line"><span class="title">  pages</span> free     3957<span class="title"></span></span><br><span class="line"><span class="title">        min</span>      7<span class="title"></span></span><br><span class="line"><span class="title">        low</span>      8<span class="title"></span></span><br><span class="line"><span class="title">        high</span>     10<span class="title"></span></span><br><span class="line"><span class="title">        scanned</span>  0<span class="title"></span></span><br><span class="line"><span class="title">        spanned</span>  4095<span class="title"></span></span><br><span class="line"><span class="title">        present</span>  3992<span class="title"></span></span><br><span class="line"><span class="title">        managed</span>  3971<span class="title"></span></span><br><span class="line"><span class="title">    nr_free_pages</span> 3957<span class="title"></span></span><br><span class="line"><span class="title">    nr_alloc_batch</span> 2<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_anon</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_anon</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_file</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_file</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_unevictable</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mlock</span>     0<span class="title"></span></span><br><span class="line"><span class="title">    nr_anon_pages</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mapped</span>    0<span class="title"></span></span><br><span class="line"><span class="title">    nr_file_pages</span> 0</span><br></pre></td></tr></table></figure><p>主要指标包括：</p><ul><li>pages 处的 min、low、high，就是上面提到的三个内存阈值，而 free 是<strong>剩余内存页数</strong>，它跟后边的 nr_free_pages 相同</li><li>nr_zone_active_anon 和 nr_zone_inactive_anon，分别代表<strong>活跃匿名页</strong>和<strong>不活跃匿名页</strong>的数量</li><li>nr_zone_active_file 和 nr_zone_inactive_file，分别代表<strong>活跃文件页</strong>和<strong>不活跃文件页</strong>的数量</li></ul><p>某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存种回收内存。具体选哪种模式，你可以通过 /proc/sys/vm/zone_reclaim_mode 来调整。它支持以下几个选项：</p><ul><li>默认的是 0，也就是刚刚提到的模式，表示既可以从其他 Node 寻找空闲内存，也可以从本地内存中回收</li><li>1、2、4 都表示只回收本地内存，2 表示可以回写脏数据来回收内存，4 表示可以用 Swap 方式回收内存</li></ul><h2 id="swapness"><a href="#swapness" class="headerlink" title="swapness"></a>swapness</h2><p>内存回收包括文件页和匿名页：</p><ul><li>对文件页的回收，是直接回收缓存，或者把脏页写回磁盘后再回收</li><li>对匿名页的回收，是通过 Swap 机制，把它们写入磁盘后再释放内存</li></ul><p>Linux 提供了一个 /proc/sys/vm/swapiness 选项，用来调整使用 Swap 的积极程度；swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p><h2 id="系统-Swap-升高的原因"><a href="#系统-Swap-升高的原因" class="headerlink" title="系统 Swap 升高的原因"></a>系统 Swap 升高的原因</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>Linux 本身支持两种类型的 Swap，即 Swap 分区和 Swap 文件，以 Swap 文件为例子，例如如下命令开启 Swap 文件</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 创建swap文件</span></span><br><span class="line"><span class="title">fallocate</span> -l 500M /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 修改权限，仅root用户可读写</span></span><br><span class="line"><span class="title">chmod</span> <span class="number">600</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 配置swap文件</span></span><br><span class="line"><span class="title">mkswap</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 开启swap</span></span><br><span class="line"><span class="title">swapon</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br></pre></td></tr></table></figure><p>执行 free 看到 swap 添加成功</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      <span class="number"> 16092196 </span>    <span class="number"> 562160 </span>    <span class="number"> 613616 </span>    <span class="number"> 295992 </span>  <span class="number"> 14916420 </span>   15135272</span><br><span class="line">Swap:       <span class="number"> 511996 </span>         <span class="number"> 0 </span>     511996</span><br></pre></td></tr></table></figure><p>执行 dd 命令，模拟大文件的读取</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/vdb1 <span class="attribute">of</span>=/dev/null <span class="attribute">bs</span>=1G <span class="attribute">count</span>=400</span><br></pre></td></tr></table></figure><p>执行 sar 查看内存和 swap 指标</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ sar -rS 3</span><br><span class="line">Linux 3.10.107-1-tlinux2_kvm_guest-0051 (VM_194_74_centos)      07/05/20        _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">20:16:14    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:17    <span class="number"> 12016228 </span> <span class="number"> 4075968 </span>    25.33  <span class="number"> 1944876 </span>  <span class="number"> 394804 </span> <span class="number"> 3089884 </span>    18.61  <span class="number"> 2364636 </span> <span class="number"> 1364468 </span>       88</span><br><span class="line"></span><br><span class="line">20:16:14    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:17      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line"></span><br><span class="line">20:16:17    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:20    <span class="number"> 11542068 </span> <span class="number"> 4550128 </span>    28.28  <span class="number"> 2405684 </span>  <span class="number"> 394868 </span> <span class="number"> 3089856 </span>    18.61  <span class="number"> 2364984 </span> <span class="number"> 1825212 </span>      120</span><br><span class="line"></span><br><span class="line">20:16:17    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:20      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:16:50    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:53     <span class="number"> 6331744 </span> <span class="number"> 9760452 </span>    60.65  <span class="number"> 7474548 </span>  <span class="number"> 395052 </span> <span class="number"> 3089736 </span>    18.61  <span class="number"> 2364948 </span> <span class="number"> 6894124 </span>       84</span><br><span class="line"></span><br><span class="line">20:16:50    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:53      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:17:44    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:17:47       <span class="number"> 90140 </span><span class="number"> 16002056 </span>    99.44 <span class="number"> 13573540 </span>  <span class="number"> 392440 </span> <span class="number"> 3089728 </span>    18.61  <span class="number"> 2180308 </span><span class="number"> 13149900 </span>      164</span><br><span class="line"></span><br><span class="line">20:17:44    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:17:47      <span class="number"> 486836 </span>   <span class="number"> 25160 </span>     4.91      <span class="number"> 120 </span>     0.48</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:18:44    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:18:47       <span class="number"> 87988 </span><span class="number"> 16004208 </span>    99.45 <span class="number"> 13658536 </span>  <span class="number"> 354504 </span> <span class="number"> 3089760 </span>    18.61  <span class="number"> 2112144 </span><span class="number"> 13218932 </span>      140</span><br><span class="line"></span><br><span class="line">20:18:44    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:18:47      <span class="number"> 403652 </span>  <span class="number"> 108344 </span>    21.16      <span class="number"> 140 </span>     0.13</span><br></pre></td></tr></table></figure><p>可以看到，总的内存使用率（%memused）在不断增长，从开始的 25% 一直涨到了 99%，并且主要内存都被缓冲区（kbbuffers）占用，大致的变化过程为：</p><ul><li>刚开始，剩余内存（kbmemfree）不断减少，而缓冲区（kbbuffers）则不断增大，由此可知，剩余内存不断分配给了缓冲区</li><li>一段时间后，剩余内存已经很小了，而缓存区占用了大部分内存。此时，Swap 的使用开始逐渐增大，缓冲区和剩余内存则只在小范围内波动</li></ul><p>为什么 Swap 会升高呢？（按理来说，应该先回收缓冲区的内存，这属于可回收内存），观察 /proc/zoneinfo 指标如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d grep -A <span class="number">15</span> &#x27;Normal&#x27; /<span class="keyword">proc</span>/zoneinfo<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">Every</span> 2.0s:<span class="title"> grep</span> -A 15<span class="title"> Normal</span> /<span class="keyword">proc</span>/zoneinfo<span class="title">                                                             Sun</span> Jul  5 20:19:39 2020<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">Node</span> 0,<span class="title"> zone</span> <span class="title">  Normal</span></span><br><span class="line"><span class="title">  pages</span> free     5200<span class="title"></span></span><br><span class="line"><span class="title">        min</span>      3268<span class="title"></span></span><br><span class="line"><span class="title">        low</span>      4085<span class="title"></span></span><br><span class="line"><span class="title">        high</span>     4902<span class="title"></span></span><br><span class="line"><span class="title">        scanned</span>  24<span class="title"></span></span><br><span class="line"><span class="title">        spanned</span>  3407872<span class="title"></span></span><br><span class="line"><span class="title">        present</span>  3407872<span class="title"></span></span><br><span class="line"><span class="title">        managed</span>  3276302<span class="title"></span></span><br><span class="line"><span class="title">    nr_free_pages</span> 5200<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_anon</span> 134532<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_anon</span> 246943<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_file</span> 2466171<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_file</span> 280987<span class="title"></span></span><br><span class="line"><span class="title">    nr_unevictable</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mlock</span>     0</span><br></pre></td></tr></table></figure><p>可以看到，剩余内存（pages free）在一个很小范围内不停地波动。当它小于页低阈值（pages low）时，又会突然增大到一个大于页高阈值（pages high）的数值</p><ul><li>当剩余内存小于页低阈值时，系统会回收一些缓存和匿名内存，使剩余内存增大。其中，缓存的回收导致 sar 中的缓冲区减少，而匿名内存的回收导致了 Swap 的使用增大。其中，缓存的回收导致 sar 中的缓冲区减少，而匿名内存的回收导致了 Swap 的使用增大。</li><li>同事由于 dd 还在继续，剩余内存又会重新分配给缓存，导致剩余内存减少，缓冲区增大</li></ul><p>利用 proc 文件系统，可以查看 Swap 换出的虚拟内存大小，它保存在 /proc/pid/status 中 VmSwap</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ for file in /proc/*/status ; do awk &#x27;/VmSwap|Name|^Pid/&#123;printf $2 &quot; &quot; $3&#125;END&#123; print &quot;&quot;&#125;&#x27; $file; done | sort -k<span class="number"> 3 </span>-n -r | head</span><br><span class="line">systemd-journal<span class="number"> 3048 </span>86160 kB</span><br><span class="line">writeback<span class="number"> 50 </span></span><br><span class="line">watchdog/7<span class="number"> 41 </span></span><br><span class="line">watchdog/6<span class="number"> 36 </span></span><br><span class="line">watchdog/5<span class="number"> 31 </span></span><br><span class="line">watchdog/4<span class="number"> 26 </span></span><br><span class="line">watchdog/3<span class="number"> 21 </span></span><br><span class="line">watchdog/2<span class="number"> 16 </span></span><br><span class="line">watchdog/1<span class="number"> 11 </span></span><br><span class="line">watchdog/0<span class="number"> 10 </span></span><br></pre></td></tr></table></figure><p>可以看到，使用 swap 较多的是 systemd-journal</p><p>结束之后，需要关闭 swap</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>一般关闭 swap 并重新打开，可以这么执行（是一种常见的 swap 清理方法）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">swapoff</span> -a &amp;&amp; swapon /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在内存资源紧张时，Linux 会通过 Swap，把不常访问的匿名页换出到磁盘中，下次访问的时候再从磁盘换入到内存中来。你可以设置 /proc/sys/vm/min_free_kbytes，来调整系统定期回收内存的阈值；也可以设置 /proc/sys/vm/swappiness，来调整文件页和匿名页的回收倾向。</p><p>当 Swap 变高时，你可以用 sar、/proc/zoneinfo、/proc/pid/status 等方法，查看系统和进程的内存使用情况，进而找出 Swap 升高的根源和受影响的进程。</p><p>通常，降低 Swap 的使用，可以提高系统的整体性能。有几种常见的降低方法：</p><ul><li>禁用 Swap，现在服务器的内存走足够大，所有除非有必要，一般会<strong>禁用 Swap</strong>，大部分云平台中的虚拟机都默认禁用 Swap</li><li>如果实在需要用到 Swap，可以尝试<strong>降低 swappiness</strong>值，减少内存回收时 Swap 的使用倾向</li><li>响应延迟敏感的应用，如果它们可能在开启 Swap 的服务器中运行，你还可以使用库函数 mlock() 或者 mlockall() <strong>锁定内存</strong>，阻止它们的内存换出</li></ul><p>常见的三种清理缓存的方法：</p><p>1、清理 pagecache</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 1</span></span><br></pre></td></tr></table></figure><p>2、清理 dentries 和 inodes</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">2</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 2</span></span><br></pre></td></tr></table></figure><p>3、清理 pagecache、dentries 和 inodes</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 3</span></span><br></pre></td></tr></table></figure><p>4、使用 sync 命令来清理文件系统内存，还会清理僵尸（zombie）对象和它们占用的内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sync</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 的 Swap 机制通过将磁盘空间用作虚拟内存，缓解物理内存不足的问题。Swap 包括换出（将不常用内存数据存至磁盘，释放内存）和换入（再次访问时从磁盘读回内存）两个过程。内存回收分为文件页和匿名页：文件页可直接回收或写入磁盘后释放，匿名页则通过 Swap 回收。内核线程 kswapd0 根据页最小、最低和最高阈值定期回收内存，当剩余内存低于阈值时触发回收。NUMA 架构下，内存分为不同 Node 和 Zone，回收策略可通过 /proc/sys/vm/zone_reclaim_mode 调整。Swap 使用倾向由 /proc/sys/vm/swappiness 控制，值越大越倾向回收匿名页。Swap 升高可能因缓存占用或匿名页回收，需用 sar、/proc/zoneinfo 等工具分析。优化方法包括禁用 Swap、降低 swappiness、锁定内存，或清理缓存（如 pagecache、dentries）。合理配置 Swap 可提升性能，但需避免过度使用以降低延迟。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：cpu</title>
    <link href="https://wu3227834.github.io/2025/05/15/2025-05-15-linux-tracing-cpu/"/>
    <id>https://wu3227834.github.io/2025/05/15/2025-05-15-linux-tracing-cpu/</id>
    <published>2025-05-15T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="怎么理解“平均负载”"><a href="#怎么理解“平均负载”" class="headerlink" title="怎么理解“平均负载”"></a>怎么理解“平均负载”</h2><p>简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它和 CPU 使用率没有直接关系，因为 CPU 使用率是指单位时间内 CPU 繁忙程度的百分比。</p><blockquote><p>可运行状态：进程正在运行或准备运行。也就是我们常用 ps 命令看到的处于 R 状态的进程<br>不可中断状态：进程正在等待某个事件的完成，例如 I/O 操作、等待锁、等待信号量等。也就是我们常用 ps 命令看到的处于 D 状态的进程</p></blockquote><p>那么，在实际生产环境中，平均负载多高时，需要我们重点关注呢？</p><p>在我看来，当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但是平均负载本身，我们不能直接发现到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</p><ul><li>平均负载高可能是 CPU 密集型进程导致的</li><li>平均负载高不一定代表 CPU 利用率高，还有可能是 I/0 更繁忙了</li><li>当发现负载高的时候，你可看到使用 mpstat、pidstat 等工具，辅助分析负载的来源</li></ul><h2 id="CPU-上下文切换（上）"><a href="#CPU-上下文切换（上）" class="headerlink" title="CPU 上下文切换（上）"></a>CPU 上下文切换（上）</h2><ul><li>CPU 上下文：包括 CPU 寄存器和程序计数器</li><li>CPU 寄存器：是 CPU 内置的容量小、但速度极快的内存</li><li>程序计数器：是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置的寄存器</li></ul><p><img src="/img/2025-05-15-linux_tracing_cpu/image.png" alt="cpu 架构"></p><ul><li>CPU 上下文切换：是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载到新任务的上下文到这些寄存器和程序计数器，然后再跳转到程序计数器指向的新位置，运行新任务</li><li>这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载出来</li></ul><p>根据任务的不同，CPU 的上下文切换可分为进程上下文切换、线程上下文切换和中断上下文切换。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，对应着下图，CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源</li></ul><p><img src="/img/2025-05-15-linux_tracing_cpu/image2.png" alt="运行空间"></p><p>从进程用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，系统调用的过程中会发生<strong>两次 CPU 上下文切换</strong>。CPU 里原本用户态指令的执行位置需要先保存起来，然后更新为内核态的指令位置，最后跳转到内核态运行内核任务；在系统调用结束后，CPU 寄存器需要恢复原本保存的用户态，然后再切换到用户空间，继续执行进程。</p><p><strong>注意：</strong></p><ol><li>系统调用的过程中，不会涉及到虚拟内存等进程态的资源，不会切换进程，系统调用过程和进程上下文切换不一样，整个过程都是同一个进程</li><li>系统调用称为特权模式切换，不是上下文切换</li></ol><p>进程上下文切换和系统调用的区别是，进程的上下文切换比系统调用多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p><img src="/img/2025-05-15-linux_tracing_cpu/image3.png" alt="进程上下文切换"></p><p><strong>保存上下文和恢复上下文的过程需要内核在 CPU 上运行才能完成</strong>（上下文切换过程是 CPU 密集型），每次上下文切换都需要几十纳秒到数微妙的 CPU 时间。</p><p>在进程上下文切换次数过多的情况下，很容易导致 CPU 将大量时间耗费在<strong>寄存器、内核栈以及虚拟内存</strong>等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，从而导致系统平均负载升高。</p><p>Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在<strong>多处理器系统</strong>上，缓存是被多个处理器<strong>共享</strong>的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选在最需要 CPU 的进程，也就是<strong>优先级最高和等待 CPU 时间最长</strong>的进程来运行。</p><p>进程被 CPU 重新调度的时机：</p><ol><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其它进程运行</li><li>进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度</li><li>有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序</li></ol><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程和进程的区别：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p><p>所谓内核中的任务调度，实际上的调度对象是<strong>线程</strong>；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul><p>因此，线程的上下文切换分为两种情况：</p><ul><li>前后两个进程属于不同进程。此时，因为资源部共享，所以切换过程就跟进程上下文切换是一样的</li><li>前后两个线程属于用一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<strong>私有数据、寄存器</strong>等不共享的资源</li></ul><p><strong>注意：</strong>同进程的线程切换要比进程间的切换消耗更少的资源，更加轻量级</p><h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>为了响应硬件事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p><p>中断上下文切换不会涉及进程的用户态，它其实只包括内核态中断服务程序执行所必需的状态，包括 <strong>CPU 寄存器、内核堆栈、硬件中断参数</strong>等</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以<strong>中断上下文切换不会与进程上下文切换同步发生</strong></p><p>大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>中断上下文切换也需要消耗 CPU，切换次数过多也会消耗大量的 CPU，甚至严重降低系统的整体性能</p><h2 id="CPU上下文切换（下）"><a href="#CPU上下文切换（下）" class="headerlink" title="CPU上下文切换（下）"></a>CPU上下文切换（下）</h2><h3 id="查看上下文切换"><a href="#查看上下文切换" class="headerlink" title="查看上下文切换"></a>查看上下文切换</h3><p>1、查看系统的总体情况</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">5</span> <span class="number">5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218196</span> <span class="number">17324820</span>     <span class="number">60 8417344</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">25</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218196</span> <span class="number">17311424</span>     <span class="number">60 8426964</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">900</span>    <span class="number">97 15273</span> <span class="number">28505 11</span>  <span class="number">6</span> <span class="number">83</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218196</span> <span class="number">17399080</span>     <span class="number">60 8343224</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">410</span>   <span class="number">310 15800</span> <span class="number">29604</span>  <span class="number">8</span>  <span class="number">6</span> <span class="number">86</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">0 1218196</span> <span class="number">17385124</span>     <span class="number">60 8350312</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">787</span>   <span class="number">300 13754</span> <span class="number">26351</span>  <span class="number">7</span>  <span class="number">4</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218196</span> <span class="number">17415052</span>     <span class="number">60 8336488</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">276</span>   <span class="number">132 15567</span> <span class="number">29585</span>  <span class="number">8</span>  <span class="number">5</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cs：context switch，每秒上下文切换的次数</li><li>in：interrupt，每秒中断的次数</li><li>r：运行队列的长度（正在运行和等待CPU的进程数）</li><li>b：处于阻塞状态的进程数</li></ul><p>2、查看进程的详细信息</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -w 5</span><br><span class="line">Linux 3.10.0-957.el7.x86_64 (xxx)       05/27/2025      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">07:35:35 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 1 </span>     3.77      0.40  systemd</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 3 </span>     2.58      0.00  ksoftirqd/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 7 </span>     7.34      0.00  migration/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 9 </span>   218.45      0.00  rcu_sched</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 11 </span>     0.40      0.00  watchdog/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 12 </span>     0.40      0.00  watchdog/1</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 13 </span>     3.57      0.00  migration/1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cswch/s：每秒自愿上下文切换的次数</li><li>nvcswch/s：每秒非自愿上下文切换的次数</li></ul><blockquote><p>自愿上下文切换：进程无法获取所需资源导致的上下文切换，比如 I/O，内存等系统资源不足时发生的上下文切换<br>非自愿上下文切换：进程因时间片已到等原因，被系统强制调度发生的上下文切换，比如多个进程竞争 CPU 是发生的上下文切换</p></blockquote><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>sysbench 模拟多线程调度切换</p><p>1、运行 sysbench</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line">$ sysbench <span class="attribute">--threads</span>=10 <span class="attribute">--max-time</span>=300 threads run</span><br></pre></td></tr></table></figure><p>2、运行 vmstat</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">9</span>  <span class="number">0</span>      <span class="number">0 107736672</span>     <span class="number">64 88038080</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>   <span class="number">199</span>    <span class="number">0</span>    <span class="number">1</span>  <span class="number">2</span>  <span class="number">1</span> <span class="number">97</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0</span>      <span class="number">0 107731792</span>     <span class="number">64 88045280</span>    <span class="number">0</span>    <span class="number">0 16384</span>    <span class="number">40 105267</span> <span class="number">1167081 12</span> <span class="number">15</span> <span class="number">72</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">0</span>      <span class="number">0 107733720</span>     <span class="number">64 88038080</span>    <span class="number">0</span>    <span class="number">0</span>  <span class="number">4192</span>    <span class="number">20 100233</span> <span class="number">1237404</span>  <span class="number">6</span> <span class="number">16</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">0</span>      <span class="number">0 107726368</span>     <span class="number">64 88045280</span>    <span class="number">0</span>    <span class="number">0 14464</span>    <span class="number">68 128551</span> <span class="number">1548455</span>  <span class="number">6</span> <span class="number">17</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">10</span>  <span class="number">0</span>      <span class="number">0 107735168</span>     <span class="number">64 88039216</span>    <span class="number">0</span>    <span class="number">0</span>  <span class="number">4096</span>    <span class="number">64 111126</span> <span class="number">1468157</span>  <span class="number">6</span> <span class="number">16</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>指标观察：</p><ul><li>cs 列：上升到 100w</li><li>r 列：就绪队列长度上升到 10</li><li>in 列：终端次数上升到 10w</li><li>us（user）和sy（system）列：使用率加起来接近 100%，sy 为 78%，主要被内核占用</li></ul><p>3、查看进程情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line">$ pidstat -w -u 1</span><br><span class="line">19时34分55秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 561077 </span>   0.00    1.00    0.00    1.00    <span class="number"> 2 </span> sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 562599 </span> 100.00  100.00    0.00  100.00   <span class="number"> 13 </span> sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 566600 </span>   0.00    2.00    0.00    2.00   <span class="number"> 32 </span> pidstat</span><br><span class="line"></span><br><span class="line">19时34分55秒   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 256312 </span>     1.00      0.00  kworker/37:31</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 263655 </span>     1.00      0.00  kworker/33:2</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 299865 </span>     1.00      0.00  kworker/21:2</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 562931 </span>     1.00      2.00  vmstat</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 560904 </span>     1.00      0.00  sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 561077 </span>    78.00      0.00  sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 566600 </span>     1.00    671.00  pidstat</span><br></pre></td></tr></table></figure><p>分析：CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd</p><p><strong>注意：</strong>pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 100 万明显小了太多？</p><table><thead><tr><th>工具</th><th>统计粒度</th><th>上下文切换数据来源</th><th>显示内容</th></tr></thead><tbody><tr><td>pidstat</td><td>按进程/线程级别</td><td>/proc/[pid]/sched 或 /proc/[pid]/status</td><td>显示某些（非全部）PID 的上下文切换次数</td></tr><tr><td>vmstat</td><td>系统全局级别</td><td>内核调度器</td><td>显示全系统每秒上下文切换总数</td></tr></tbody></table><p>4、查看线程情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">$ pidstat -wt 1</span><br><span class="line">19时34分55秒  UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 616348 </span>        -      0.00      0.00  sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616348 </span>     0.00      0.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616349 </span> 67080.00      6.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616350 </span> 63009.00      3.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616351 </span> 68060.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616352 </span> 69808.00      4.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616353 </span> 68806.00      5.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616354 </span> 73688.00      6.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616355 </span> 72296.00      4.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616356 </span> 63978.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616357 </span> 67409.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616358 </span> 67859.00      2.00  |__sysbench</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。上下文切换罪魁祸首，还是过多的 sysbench 线程</p><p>5、查看中断升高的原因</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d cat /<span class="keyword">proc</span>/interrupts<span class="title"></span></span><br><span class="line"><span class="title">           CPU0</span> <span class="title">      CPU1</span> <span class="title">      CPU2</span></span><br><span class="line">...<span class="title"></span></span><br><span class="line"><span class="title"> RES:</span>  117962220   27310354   17986708<span class="title">   Rescheduling</span> interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察发现，变化速度最快的是重调度中断（RES），它代表唤醒空闲状态的 CPU 来调度新的任务运行，这是在多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）</p><p><strong>分析：</strong>过多任务导致了重调度中断的升高，和前面分析结果一致</p><h2 id="每秒上下文切换多少次正常"><a href="#每秒上下文切换多少次正常" class="headerlink" title="每秒上下文切换多少次正常"></a>每秒上下文切换多少次正常</h2><p><strong>上下文切换次数取决于系统本身的CPU性能。</strong>如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级增长时，就很有可能出现了性能问题，这时根据具体上下文切换的类型具体分析：</p><ul><li>资源上下文切换变多了，说明进程在等在资源，可能发生了 I/O 等其他问题</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还序号通过查看 /proc/interrupts 文件来分析具体的中断类型</li></ul>]]></content>
    
    
    <summary type="html">本文深入讲解 Linux 系统性能调优中的 CPU 相关知识，重点解析平均负载的含义及其与 CPU 使用率的关系，探讨 CPU 上下文切换（进程、线程、中断）的机制与影响，并通过 sysbench 案例分析高负载场景下的诊断方法，指导如何使用 vmstat、pidstat 等工具定位性能瓶颈。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何迅速分析出CPU的瓶颈</title>
    <link href="https://wu3227834.github.io/2025/05/15/2025-05-15-ru-he-xun-su-fen-xi-chu-cpu-de-ping-jing/"/>
    <id>https://wu3227834.github.io/2025/05/15/2025-05-15-ru-he-xun-su-fen-xi-chu-cpu-de-ping-jing/</id>
    <published>2025-05-15T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h2><p>性能指标总览</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image.png" alt="性能指标总览"></p><h3 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h3><p>CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/0 CPU、软中断和硬中断等。用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态：</p><ul><li>CPU 使用率（nice），表示 CPU 在<strong>用户态</strong>运行的时间百分比。用户 CPU 使用率高，通常说明有<strong>应用程序</strong>比较繁忙</li><li>系统 CPU 使用率，表示 CPU 在内核状态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明<strong>内核</strong>比较繁忙</li><li>等待 I/O 的 CPU 使用率，通常为 iowait，表示<strong>等待 I/O</strong> 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互比较长</li><li>软中断和硬中断的 CPU 利用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断</li><li>除了上述这些，还有在虚拟化环境中会用到的<strong>窃取 CPU 利用率（steal）和客户 CPU 使用率（guest）</strong>，分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比</li></ul><h3 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h3><p>系统的活跃进程数。反映了系统的整体负载情况，主要包括三个数值，分别表示过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。理想情况下，平均负载等于逻辑 CPU 个数，这个代表每个 CPU 都恰好被充分利用。如果负载大于逻辑 CPU 个数，就表示负载比较重了。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>进程上下文切换分为：自愿上下文切换和非自愿上下文切换</p><p>注意：过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在<strong>寄存器、内核栈以及虚拟内存等数据的保存和恢复上</strong>，缩短进程真正进行的时间，成为性能瓶颈。</p><h3 id="CPU-缓存命中率"><a href="#CPU-缓存命中率" class="headerlink" title="CPU 缓存命中率"></a>CPU 缓存命中率</h3><p>CPU 缓存的速度介于 CPU 和内存之间，缓存的是<strong>热点的内存数据</strong>。</p><p>如下图，根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常在单核中，L3 则在多核中。从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次减少（当然内存还是好得多）。而它们的命中率，衡量的是 <strong>CPU 缓存的复用情况</strong>，命中率越高，则表示性能越好。</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image2.png" alt="CPU 缓存"></p><h2 id="CPU-性能工具"><a href="#CPU-性能工具" class="headerlink" title="CPU 性能工具"></a>CPU 性能工具</h2><p>平均负载案例：使用 uptime 查看平均负载，在平均负载升高时，使用 mpstat 和 pidstat 分别观察每个 CPU 和每个进程 CPU 的使用情况，找到导致平均负载升高的 stress 进程</p><p>上下文切换的案例：先使用 vmstat，查看系统上下文切换次数和中断次数；然后使用 pidstat（-w 参数）观察进程的自愿上下文切换和非自愿上下文切换；最后通过 vmstat（-wt参数）查看线程的上下文切换情况，从而找到了线程上下文切换增多的原因是 sysbench 工具</p><p>进程 CPU 使用率升高的案例：先使用 top 找出系统和进程 CPU 的使用情况，发现了 CPU 使用率很高的进程 php-fpm，再使用 perf top 找出热点函数 sqrt()；如果是 Python 应用，可以使用 profiler 工具 pyflame 对指定进程分析（pyflame -p pid –threads -s 检测时间 -r 取样间隔 -o &lt;file.txt&gt;），再通过 flamegraph.pl 将输出的 txt 文件转换为 *.svg 格式的火焰图（./flamegraph.pl prof.txt &gt; prof.svg）</p><p>不可中断进程和僵尸进程的案例：</p><ul><li>不可中断进程分析过程：先使用 top 查看，发现存在 D 状态（不可中断休眠进程）和 Z 状态（僵尸进程），并且 iowait 较高；使用 dstat 分析磁盘 I/O，发现 app 进程有大量的磁盘读请求；使用 pidstat（-d -p 参数）分析 app 进程的 I/O 操作，发现没有大量的 I/O 操作，再用 pidstat -d 分析系统的 I/O 情况，发现还是 app 进程在进行磁盘读；再使用 strace 跟踪 D 状态进程对应进程号的系统调用，发现没有权限；ps 查看发现对应进程号的进程已经变成僵尸进程；之后，通过 perf record -g 和 perf report 生成报告，查看 app 进程的调用栈，发现 CPU 使用主要是在 sys_read() 函数，定位到是在对磁盘进行直接读（direct_IO）；查看代码发现 open() 系统调用使用了 O_DIRECT 参数</li><li>僵尸进程分析：使用 pstree 命令找出僵尸进程的父进程是 app 进程，然后查看 app.c 文件，发现 wait() 使用位置不当导致不能回收子进程</li></ul><p>软中断的案例：先使用 top 查看系统指标，发现系统 CPU 使用率很低，但是主要是在软中断 si 上，然后查看 /proc/softirqs 查看系统软中断变化情况，发现 NET_RX 变化率很快，再使用 sar 工具查看系统的网络收发情况，发现 eth0 网卡接收到了大量的小包；在通过抓包工具 tcpdump，发现 eth0 接受到了大量的 SYN 包，最终确定了是 SYN FLOOD 攻击</p><h3 id="性能指标找工具"><a href="#性能指标找工具" class="headerlink" title="性能指标找工具"></a>性能指标找工具</h3><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image3.png" alt="性能指标找工具"></p><h3 id="工具找指标"><a href="#工具找指标" class="headerlink" title="工具找指标"></a>工具找指标</h3><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image4.png" alt="工具对应指标"></p><h2 id="如何分析-CPU-的性能瓶颈"><a href="#如何分析-CPU-的性能瓶颈" class="headerlink" title="如何分析 CPU 的性能瓶颈"></a>如何分析 CPU 的性能瓶颈</h2><p>重点：弄清楚性能指标之间的关联性</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image5.png" alt="指标关联性"></p><h2 id="CPU-性能优化的几个思路"><a href="#CPU-性能优化的几个思路" class="headerlink" title="CPU 性能优化的几个思路"></a>CPU 性能优化的几个思路</h2><h3 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h3><p>确定三个问题：</p><ul><li>判断所做的性能优化是否有效？优化后，能提升多少性能，有多少收益？</li><li>如果有多个性能问题同时存在，应该先优先哪一个？</li><li>当有多个优化方法，应该选择哪一种</li></ul><p><strong>怎么评估性能优化结果：</strong></p><p>三步走原则：</p><ol><li>确定优化的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ol><p>第一步，性能的量化指标包括 CPU 使用率、应用的吞吐量，响应时间等等，<strong>不要局限在单一维度的指标上</strong>。例如，以 web 应用为例：</p><ul><li>应用程序的维度，使用<strong>吞吐量和请求延时</strong>来评估</li><li>系统资源的维度，使用<strong>CPU 使用率</strong>来评估</li></ul><p>好的应用程序是性能优化的最终结果和目的，要使用应用程序的指标，来评估性能优化的整体效果；而系统资源的使用情况是影响应用程序的根源，需要用资源的指标，来分析应用性能的瓶颈来源。</p><p>第二三步，对比第一部确定的<strong>量化指标</strong>在优化前后的差距，拿数据说话。例如，使用 ab 工具测试 Web 应用的并发请求数和响应延时，同时使用 vmstat，pidstat 等工具，观察系统和进程的 CPU 使用率，同时获得了应用和系统两个维度的性能指标</p><p><strong>进行性能测试需要注意的是：</strong></p><ul><li>要避免性能测试工具干扰应用程序的性能</li><li>避免外部环境的变化影响性能指标的评估。在优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致</li></ul><p><strong>多个性能问题同时存在，怎么选择？</strong></p><p>遵循<strong>二八原则</strong>，80% 的性能问题都是由于 20% 的代码导致的，<strong>并不是所有的性能问题都值得优化</strong></p><p>分析的步骤：</p><ul><li>挨个分析出所有的性能瓶颈，排除掉有因果关系的性能问题</li><li>在剩下的几个性能问题中，选择能明显提升应用性能的问题进行修复，有两种方法：<ul><li>如果系统资源出现瓶颈，首先优化系统资源使用的问题</li><li>针对不同类型的指标，首先优化导致<strong>性能指标变化幅度最大</strong>的那些瓶颈问题</li></ul></li></ul><p><strong>有多种优化方法时，如何选择？</strong></p><p>性能优化并非没有成本。</p><p>一个很典型的例子网络中的 DPDK（Data Plane Development Kit）。DPDK 是一种优化网络处理速度的方法，它通过绕开内核网络协议栈的方法，提升网络的处理能力。不过它有一个很典型的要求，就是要独占一个 CPU 以及一定数量的内存大页，并且总是以 100% 的 CPU 使用率运行。所以，如果你的 CPU 核数很少，就有点得不偿失了。</p><p>因此，在考虑性能优化方法时，要结合实际情况，考虑多方面的因素，进行权衡在做选择</p><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>常见的几种应用程序方法：</strong></p><ul><li><strong>编译器优化</strong>：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如，gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化</li><li><strong>算法优化</strong>：使用复杂度更低的算法，显著加快处理速度</li><li><strong>异步处理</strong>：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题</li><li><strong>多线程代替多进程</strong>：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本</li><li><strong>善用缓存</strong>：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度</li></ul><p><strong>常见的系统优化方法：</strong></p><ul><li><strong>CPU 绑定</strong>：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题</li><li><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU</li><li><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。可以适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理</li><li><strong>为进程设置资源限制</strong>：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源</li><li><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会将内存划分为多个 node，每个 node 关联到系统的一个处理器。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存</li><li><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把<strong>中断处理过程自动负载均衡到多个 CPU 上</strong></li></ul><p><strong>避免过早优化：</strong></p><p>性能优化最好是<strong>逐步完善，动态进行</strong>，不追求一步到位，而要<strong>首先保证能满足当前的性能要求</strong>。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>要忍住“把 CPU 性能优化到极致”的冲动</strong>，因为 CPU 并不是唯一的性能因素，还会有其他的性能问题，比如内存、网络、I/O 甚至是架构设计的问题。</p><p>如果不做全方位的分析和测试，只是单纯地把某个指标提升到极致，并不一定能带来整体的收益。</p>]]></content>
    
    
    <summary type="html">分析 CPU 性能瓶颈是优化 Linux 系统性能的关键。CPU 使用率反映非空闲时间占比，分为用户态、系统态、I/O 等待、软硬中断等，分别指示应用程序、内核、I/O 交互或中断的繁忙程度。平均负载表示活跃进程数，理想值等于逻辑 CPU 数量，超载提示系统压力。上下文切换包括自愿和非自愿切换，过多切换会消耗 CPU 时间，降低进程运行效率。CPU 缓存命中率衡量热点数据复用，高命中率提升性能。分析工具如 uptime、mpstat、pidstat 监测负载与 CPU 使用，vmstat 观察上下文切换，perf 定位热点函数，strace 跟踪系统调用。优化方法包括编译器优化、算法改进、异步处理、多线程替换多进程、善用缓存等系统层面优化，如 CPU 绑定、独占、优先级调整及中断负载均衡。性能优化需遵循二八原则，优先解决主要瓶颈，避免过早优化，确保量化指标（如吞吐量、响应时间）提升，结合多维度分析以实现整体性能收益。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Python 传参机制与对象传递</title>
    <link href="https://wu3227834.github.io/2025/02/24/2025-02-24-qian-tan-python-chuan-can-ji-zhi-yu-dui-xiang-chuan-di/"/>
    <id>https://wu3227834.github.io/2025/02/24/2025-02-24-qian-tan-python-chuan-can-ji-zhi-yu-dui-xiang-chuan-di/</id>
    <published>2025-02-24T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.082Z</updated>
    
    <content type="html"><![CDATA[<p>Python 的传参机制是其内存管理和函数设计的重要组成部分，尤其在处理可变和不可变对象时，可能会导致意想不到的行为。本报告将详细探讨 Python 的传参方式（按值还是按引用），并深入分析如何理解“传对象”，涵盖对象引用的概念、可变性对传参的影响，以及开发者如何在实践中管理这些行为。</p><h2 id="背景与问题概述"><a href="#背景与问题概述" class="headerlink" title="背景与问题概述"></a>背景与问题概述</h2><p>在编程语言中，传参通常分为按值传递（pass by value）和按引用传递（pass by reference）。按值传递意味着函数接收的是参数的副本，修改不会影响原始变量；按引用传递意味着函数接收的是原始变量的引用，修改会影响原始变量。Python 的传参机制与这些传统概念有所不同，官方文档和社区讨论中常提到“按对象引用传递”（call by object reference）或“按赋值传递”（pass by assignment）。</p><h2 id="Python-传参的本质：按对象引用传递"><a href="#Python-传参的本质：按对象引用传递" class="headerlink" title="Python 传参的本质：按对象引用传递"></a>Python 传参的本质：按对象引用传递</h2><p>根据官方文档和权威资源，Python 的传参方式是按对象引用传递。这意味着当你将参数传递给函数时，函数接收的是指向同一个对象的引用，而不是对象的副本。具体来说：</p><ul><li>函数的参数成为函数局部命名空间中的一个新变量，这个变量绑定到与调用者传递的对象相同的对象。</li><li>这种绑定是通过赋值完成的，因此也被称为按赋值传递。</li></ul><p>为了理解这一点，我们需要回顾 Python 的对象模型：</p><ul><li>Python 中一切都是对象，变量只是指向对象的引用（reference）。 </li><li>当你执行 <code>x = 5</code>，<code>x</code> 是一个名称，绑定到整数对象 5。</li><li>当你调用 <code>func(x)</code>，函数 <code>func</code> 的参数绑定到同一个对象 5。</li></ul><h2 id="可变与不可变对象的影响"><a href="#可变与不可变对象的影响" class="headerlink" title="可变与不可变对象的影响"></a>可变与不可变对象的影响</h2><p>Python 对象的可变性（mutability）对传参行为有显著影响：</p><ol><li><strong>不可变对象</strong>（immutable objects）：如整数（int）、字符串（str）、元组（tuple）。这些对象一旦创建就不能修改。<ul><li>如果函数尝试修改不可变对象的参数（例如重新赋值），实际上是创建了一个新对象，并绑定到参数名称上，但这不会影响调用者的原始变量。</li><li>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_num</span>(<span class="params">num</span>):</span><br><span class="line">    num = <span class="number">10</span>  <span class="comment"># 创建新整数对象 10，绑定到 num</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">modify_num(x)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出 5，原始变量未变</span></span><br></pre></td></tr></table></figure></li><li>在这种情况下，行为类似于按值传递，因为无法修改原始对象。</li></ul></li><li><strong>可变对象</strong>（mutable objects）：如列表（list）、字典（dict）、集合（set）。这些对象可以被修改。<ul><li>如果函数修改可变对象的状态（例如追加列表元素），这些修改会反映到调用者的原始对象上，因为两者引用的是同一个对象。</li><li>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_list</span>(<span class="params">lst</span>):</span><br><span class="line">    lst.append(<span class="number">4</span>)  <span class="comment"># 修改列表，影响原始对象</span></span><br><span class="line"></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">modify_list(y)</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出 [1, 2, 3, 4]，原始列表已改变</span></span><br></pre></td></tr></table></figure></li><li>在这种情况下，行为类似于按引用传递，因为可以修改原始对象。</li></ul></li></ol><p>然而，需要注意的是，如果函数内重新赋值参数（而不是修改对象内容），这不会影响原始变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reassign_list</span>(<span class="params">lst</span>):</span><br><span class="line">    lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]  <span class="comment"># 重新绑定 lst 到新列表，原始对象不变</span></span><br><span class="line"></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">reassign_list(y)</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出 [1, 2, 3]，原始列表未变</span></span><br></pre></td></tr></table></figure><p>这表明，参数的重新赋值只影响函数内的局部命名空间，不会改变调用者的绑定。</p><h2 id="如何理解“传对象”"><a href="#如何理解“传对象”" class="headerlink" title="如何理解“传对象”"></a>如何理解“传对象”</h2><p>“传对象”意味着函数接收的是对象的引用，而不是对象本身的副本。以下是关键点：</p><ul><li>Python 中的变量是对象的引用，传递参数时，函数的参数绑定到与调用者相同的对象。</li><li>函数可以通过这个引用访问对象的内容，并根据对象的可变性决定是否能修改它。</li><li>如果对象是可变的，函数可以修改其状态，影响原始对象；如果对象是不可变的，函数只能创建新对象，原始对象不受影响。</li></ul><p>为了更直观地理解，可以将变量想象为指向对象的标签（label）。传递参数时，函数得到的是同一个标签的副本，但标签指向的对象是共享的：</p><ul><li>对于可变对象，修改对象内容相当于在同一个对象上操作，所有标签都会看到变化。</li><li>对于不可变对象，试图修改会创建新对象，函数内的标签指向新对象，而原始标签仍指向旧对象。</li></ul><h2 id="按值、引用、对象传递对比与总结"><a href="#按值、引用、对象传递对比与总结" class="headerlink" title="按值、引用、对象传递对比与总结"></a>按值、引用、对象传递对比与总结</h2><p>以下表格对比了按值传递、按引用传递与 Python 传参的差异：</p><table><thead><tr><th>机制</th><th>描述</th><th>Python 示例</th><th>影响原始变量</th></tr></thead><tbody><tr><td>按值传递（Pass by Value）</td><td>函数接收参数的副本，修改不影响原变量</td><td>num = 10，函数内赋值新值</td><td>否</td></tr><tr><td>按引用传递（Pass by Reference）</td><td>函数接收变量的引用，修改影响原变量</td><td>C++ 中的指针或引用传递</td><td>是</td></tr><tr><td>Python 按对象引用传递</td><td>函数接收对象的引用，可变对象可修改</td><td>列表追加元素，字典修改键值</td><td>是（可变对象，修改内容）</td></tr></tbody></table><p>Python 的传参机制结合了按值和按引用的特性，具体行为取决于对象的可变性。这种灵活性适合大多数场景，但需要开发者理解对象模型以避免误用。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad_append</span>(<span class="params">new_item, a_list=[]</span>):</span><br><span class="line">    a_list.append(new_item)</span><br><span class="line">    <span class="keyword">return</span> a_list</span><br></pre></td></tr></table></figure><p>执行两次 <code>print bad_append(&#39;one&#39;)</code> 的结果是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad_append</span>(<span class="params">new_item, a_list=<span class="literal">None</span></span>):</span><br><span class="line">    a_list.append(new_item)</span><br><span class="line">    <span class="keyword">return</span> a_list</span><br></pre></td></tr></table></figure><p>执行两次 <code>print bad_append(&#39;one&#39;)</code> 的结果是什么？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://foofish.net/python-function-args.html">Python 函数中，参数是传值，还是传引用？</a></li><li><a href="https://realpython.com/python-pass-by-reference/">Pass by Reference in Python: Background and Best Practices</a></li><li><a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions">8.7. Function definitions</a></li><li><a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">How do I pass a variable by reference?</a></li></ul>]]></content>
    
    
    <summary type="html">Python 的传参机制是按对象引用传递（call by object reference），结合了按值和按引用的特性，行为取决于对象的可变性。在 Python 中，所有变量都是对象的引用，传递参数时，函数接收的是指向同一对象的引用，而非副本。不可变对象（如整数、字符串）无法修改，函数内重新赋值会创建新对象，不影响原始变量，行为类似按值传递。可变对象（如列表、字典）允许修改内容，函数内的更改会反映到原始对象，类似按引用传递。然而，重新赋值参数仅影响函数局部命名空间，不改变调用者的绑定。这种机制源于 Python 的对象模型，变量是对象的标签，传递时共享对象引用。开发者需注意可变对象的默认参数陷阱，如使用列表作为默认参数可能导致意外共享。理解 Python 传参机制有助于避免误用，提高代码可预测性。通过合理管理对象引用和可变性，开发者可以在函数设计中实现高效、清晰的逻辑。</summary>
    
    
    
    
    <category term="Python" scheme="https://wu3227834.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>容器 overlay 文件系统简述</title>
    <link href="https://wu3227834.github.io/2024/08/28/2024-08-28-rong-qi-overlay-wen-jian-xi-tong-jian-shu/"/>
    <id>https://wu3227834.github.io/2024/08/28/2024-08-28-rong-qi-overlay-wen-jian-xi-tong-jian-shu/</id>
    <published>2024-08-28T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.082Z</updated>
    
    <content type="html"><![CDATA[<p>💡 转载自</p><ul><li><a href="https://www.zsythink.net/archives/4345">https://www.zsythink.net/archives/4345</a></li><li><a href="https://blog.csdn.net/qq_24433609/article/details/130430322">https://blog.csdn.net/qq_24433609/article/details/130430322</a></li><li><a href="https://blog.csdn.net/m0_49023005/article/details/121583100">https://blog.csdn.net/m0_49023005/article/details/121583100</a></li></ul><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>有个问题困惑着我：容器删除 docker rm 后，docker cp 到容器内的文件，在 /var/lib/docker/overlay2 目录中是否还会存在</p><p>答案：容器删除后 docker rm 后，会自动删除 /var/lib/docker/overlay2 中的对应文件</p><p>实验步骤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run --name test-container -it busybox:latest sh</span><br><span class="line"><span class="comment">## 主机拷贝文件到容器</span></span><br><span class="line">docker <span class="built_in">cp</span> test-file.txt  test-container:/tmp</span><br><span class="line"><span class="comment">## 去  /var/lib/docker/overlay2  查看是否有此文件</span></span><br><span class="line"><span class="built_in">cd</span>  /var/lib/docker/overlay2 </span><br><span class="line">find ./ -name test-file.txt</span><br><span class="line"><span class="comment">## 发现在容器运行时，该文件存在与 diff 和 merged 目录</span></span><br><span class="line"><span class="comment">## 容器内执行 exit 退出容器，容器会处于 exited 状态，或者 docker stop </span></span><br><span class="line"><span class="comment">## 发现在容器停止或 exited 状态，此时该文件会存在于 diff 文件中</span></span><br><span class="line"><span class="comment">## 删除容器后，此文件就不存在了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 因此就好奇这几个目录的意义</span></span><br><span class="line"><span class="comment">## 同时发现 /var/lib/docker/overlay2  中的 hash id 与容器 id 并不对应，因此考虑就和 overlay 文件系统有关了</span></span><br></pre></td></tr></table></figure><p>简单解释，例如下边容器的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## docker inspect 0fcfdcf1b5ff |jq &#x27;.[].GraphDriver&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/3cc96d59abc8c7653b124c39277c4da2830640a1a7b0939175ab3b41b1983303-init/diff:/var/lib/docker/overlay2/27ac3a1da2eea77dd8ecfcbb10dda293196408630099796c77bbf71840163759/diff:/var/lib/docker/overlay2/0ca615083cdc29e27697c00bd1ab6ce548760a3101f83bb6f697cb6c63ffcc55/diff:/var/lib/docker/overlay2/d11260c6a8a656e6c689417a2eabf2a097e65935da20b979b3f143ff5b0e7d92/diff:/var/lib/docker/overlay2/ff38b128d890e22b98851afcd608d4e70980d5e2a67a074e65fc68d40fb11f9b/diff:/var/lib/docker/overlay2/c1764658c479cfb45edac77699a4da0d2e481e6999db23854a40d54369fb132c/diff:/var/lib/docker/overlay2/b853ec37273e73902d6e9d3aa9fcc5aa4215b2ef8d56e7076d5673c699c34820/diff:/var/lib/docker/overlay2/e8d350b0980d01b145a7ce8dcf68f66d66c89d1f8b043a73e1d073896c20cdac/diff:/var/lib/docker/overlay2/2f69b30f1e7f26b4dfcaf483306b66bff6d2a9f301f49f02c0847bddc413caaa/diff:/var/lib/docker/overlay2/fbc7a7f9c03dbcd7fd507b802186a563c10d70718c019138d0f04389b9acf2bb/diff:/var/lib/docker/overlay2/1902c5596c2e232ecd2f74c1485e9742b8aa36cffb17abca756efb5020fba82c/diff:/var/lib/docker/overlay2/fdacc494a2fc86b92a1b6fdcec7074f985e0ff07b94be74baeb86399dd7187e1/diff:/var/lib/docker/overlay2/ad913d5690c729d32aef928345f8f84dc5fe9df3fb8d6b1eaf38ecb541408a82/diff:/var/lib/docker/overlay2/3f9061393985ee37edb071aac649af44bc7d19fa71861517d83000f69ba0a889/diff:/var/lib/docker/overlay2/0160cfc728093c0d737eeee1ce87ee7dbb36c27f41fa8301e6a966dee3205fe7/diff:/var/lib/docker/overlay2/d56448445573eb1d2236fd855c13a322b817ceb8482e9a64a8afa1423fbe859d/diff:/var/lib/docker/overlay2/2c8c22223361f41b06da49379023c8be1812dad70acbd0fff4b98508d813a343/diff:/var/lib/docker/overlay2/eb90ded5e398c49c6127187b68d7cf6a878f686cb4475bfd427ada9521905191/diff:/var/lib/docker/overlay2/aa4b8e69ae8ba46ddf2cbaa1db9bb63dc630471f829360f540a774533249c060/diff:/var/lib/docker/overlay2/acfea1fe0ce15416c5efac6bab4b52a27aec7205f7fa899e568e1d9dda9fc03c/diff:/var/lib/docker/overlay2/f843b96cc41cb5948dd88233fa961ad2433889bb2765c8737cd0408e999bacf9/diff:/var/lib/docker/overlay2/45f0eafde0438ec844886856ed68e07b2eb65fe8133353aa4240489d074e6e74/diff:/var/lib/docker/overlay2/3bbb18f0ad656534f45b20e6c8a3a869f3a4f177c2859e39121244737b5bd4cb/diff:/var/lib/docker/overlay2/7de504f0fd3c6aa359ec06ded02d3153405f1c4f7fac29d1b88e351d166364bc/diff:/var/lib/docker/overlay2/bb25f883772fc8502362a124574b3a741090502eaed6268e869843087f98cbe4/diff:/var/lib/docker/overlay2/b93a3576a6fa85ad54890c6163ad26b5c6fda0f403a8e8768a6c052cfad39c93/diff:/var/lib/docker/overlay2/023afc8e2f044ac2d55a804d577b4b5a9f93ff67c5e041f02dc45636ae66d949/diff:/var/lib/docker/overlay2/15573352d289785a83a1ecaa3b65168e68185125e395478e66ca4d71dc5c8e34/diff:/var/lib/docker/overlay2/5d149bcd3163486f89923e9dbc7d067909fd4c2328b3693ee9b4cd2bacb7b5d3/diff:/var/lib/docker/overlay2/9a6e123d5b2659c82fa6955cfd3e689ec0b43cedf8cce3586d11f5b9de31377d/diff:/var/lib/docker/overlay2/ab95d820e29c009efc444c6a3caff6b0cdb7c56bdd18c3fefeac35fdc2048074/diff:/var/lib/docker/overlay2/1ae1804931b744310f3410ce5dedcc3910839fb9e5b55f0483a6bd4abef51521/diff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/3cc96d59abc8c7653b124c39277c4da2830640a1a7b0939175ab3b41b1983303/merged&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/3cc96d59abc8c7653b124c39277c4da2830640a1a7b0939175ab3b41b1983303/diff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/3cc96d59abc8c7653b124c39277c4da2830640a1a7b0939175ab3b41b1983303/work&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Docker  中，一个很重要的概念就是 GraphDriver，它主要用于管理和维护镜像，包括把镜像从仓库下载下来，到运行时把镜像挂载起来可以被容器访问等，都是 GraphDriver 去完成的。</p><ul><li>“Name”: “overlay2”：docker存储驱动是overlay2</li><li>LowerDir：包含容器内所有层的文件系统，最后一层除外<ul><li>基础镜像，可以看到有很多 init，这是对应 From 的基础镜像（所有只读层）</li></ul></li><li>UpperDir：容器最上层的文件系统。这也是反映任何运行时修改的地方<ul><li>容器读写层</li></ul></li><li>MergedDir：文件系统所有层的组合视图<ul><li>联合挂载层 ：将 基础层和容器读写层  挂载在一起 ，展示一个统一的视图</li></ul></li><li>WorkDir：用于管理文件系统的内部工作目录</li></ul><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Untitled.png" alt="GraphDriver 示意图"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>通过上述实验，我们已经对 overlay2 有了一定认识了，现在，我们来看看 overlay2 是怎样和 docker 中的镜像层以及容器层结合在一起的。</p><p>当我们通过 docker pull 命令拉去第一个镜像时，可以看到镜像每一层被拉取的过程，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## docker pull 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1</span><br><span class="line">20240712_68ba1e1: Pulling from hippo/runtime/x86/faiss_benchmark</span><br><span class="line">648c0ccfae96: Pull complete</span><br><span class="line">d77e7370c4fa: Pull complete</span><br><span class="line">00701f0aa522: Pull complete</span><br><span class="line">d4516580db57: Pull complete</span><br><span class="line">fca65a19a3bf: Pull complete</span><br><span class="line">Digest: sha256:e9b215174cd7a01eafd1913d2bd1c59aafd797649de906dea53eda3582dfdc6b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1</span><br></pre></td></tr></table></figure><p>如上所见，此处拉取的 <code>faiss_benchmark:20240712_68ba1e1</code> 镜像一共有 5 层，每一层拉取完毕后，都会显示 Pull complete（Already exists 则表示本地目录已经有该层的文件）；每一层都有一个 ID 号，比如上列中的 648c0ccfae96 就是层的哈希值前 12 位。</p><p>下载镜像后，我们可以通过 docker inspect 命令查看镜像的详细信息，在镜像的详细信息中找到 RootFS 段，可以查看当前镜像包含的层，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## docker inspect 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1 | jq <span class="string">&#x27;.[].RootFS&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Layers&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;sha256:4f118a86fef9debde65113068bd2b85f9c5fd65250ac6af2e8281a502cc0a724&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sha256:004114a8d0e34895acdd9c1c370b1184b239d538e3951887d04d1bda771bd441&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sha256:0d5cae34765c1f89a17e5e8e7e6f6f9ddc541151e3efab2487b013faeecac3a6&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sha256:fbc981c1f97f7139dd25bc0924272ae4f8f9e07d8c57a1ca4b0c9344266a93ff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sha256:457b93dcc46ca598ce9378e015aae678218bb9a699c4e373250e4021b60c0566&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，faiss_benchmark 镜像的 RootFS 段中一共有 5 层，这 5 个层就是刚才 docker pull 拉取下来的层，RootFS 中的每个层也是用一个哈希值表示，RootFS 中的层的哈希值的前 12 位和刚才 docker pull 命令中的 ID 根本对应不上，这是因为 dcoker pull 中显示的 ID 是层在压缩状态下计算出的哈希值，当层被下载到本地，会自动解压，而 RootFS 中的层哈希值不是在压缩状态下计算的，显然它们两个的值不会一样。如果想要确定它们之间的对应关系，可以通过 <code>diffid-by-digest或者v2metadata-by-diffid/sha256/</code>目录中的文件来查看它们之间的对应关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 distribution]## <span class="built_in">pwd</span></span><br><span class="line">/var/lib/docker/image/overlay2/distribution</span><br><span class="line">[root@pudding-160 distribution]## tree -L 2</span><br><span class="line">.</span><br><span class="line">├── diffid-by-digest</span><br><span class="line">│   └── sha256</span><br><span class="line">└── v2metadata-by-diffid</span><br><span class="line">    └── sha256</span><br><span class="line"></span><br><span class="line">4 directories, 0 files</span><br></pre></td></tr></table></figure><ul><li><code>diffid-by-digest/sha256</code>：<ul><li>这个目录存储了按镜像层的 Digest (SHA256) 计算的映射到 DiffID 的信息。</li><li>Digest 是一个唯一标识符，用于识别镜像层的内容。</li><li>DiffID 是镜像层的一个变化 ID，表示这一层和它下面一层之间的差异。</li><li>这个映射文件可以帮助 Docker 快速查找特定层的变化信息。</li></ul></li><li><code>v2metadata-by-diffid/sha256</code>：<ul><li>这个目录存储了按 DiffID (SHA256) 计算的映射到 v2 元数据的文件。</li><li>这些元数据包括关于镜像层的各种信息，如创建时间、大小、标签等。</li><li>这个目录有助于 Docker 管理和检索与特定层相关的元数据。</li></ul></li></ul><p>例如 289ce7e41289 的对应关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 sha256]## find . -name <span class="string">&quot;648c0ccfae96*&quot;</span></span><br><span class="line">./648c0ccfae963a8b0d71c267d8cb5bb4fc6f26f5e9bd05ab7a6f82db8e95332e</span><br><span class="line">[root@pudding-160 sha256]## <span class="built_in">cat</span> ./648c0ccfae963a8b0d71c267d8cb5bb4fc6f26f5e9bd05ab7a6f82db8e95332e</span><br><span class="line">sha256:4f118a86fef9debde65113068bd2b85f9c5fd65250ac6af2e8281a502cc0a724</span><br><span class="line"></span><br><span class="line">这是我们可以看到 docker pull 中的 648c0ccfae96 和 docker insepct 中的 648c0ccfae96 联系了起来</span><br></pre></td></tr></table></figure><p>在 RootFS 所显示的层中，第一层是最底层，最后一行是最上层，RootFS 显示的层顺序和在镜像中的实际顺序是相反的，在上例中 4f118a86fef9d 是镜像最底层，457b93dcc46 是镜像的最上层。</p><p>既然这些层已经下载到本地，那么这些层对应的文件到底存放到那里呢？我们可以通过如下命令，可以查看这些层的实际存放位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 sha256]## docker inspect 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1 -f <span class="string">&#x27;&#123;&#123;.GraphDriver.Data&#125;&#125;&#x27;</span> | awk -v RS=<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print&#125;&#x27;</span> | <span class="built_in">nl</span> | <span class="built_in">sort</span> -nr | <span class="built_in">cut</span> -f2 | awk -v RS=<span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;&#123;print&#125;&#x27;</span> | grep diff</span><br><span class="line">/var/lib/docker/overlay2/43722a4a12628179c70d588fcc7f64b86aa92cbd30c8599035d0433059423dcf/diff</span><br><span class="line">/var/lib/docker/overlay2/0fed41f6f307ef92b1b1d475108575f0130d224eb008dfa3ff4383c8fa506de6/diff</span><br><span class="line">/var/lib/docker/overlay2/cd5c2d405030b7ed966d1b78c3b038c1c6b313b8be7d0033835bf9ae20c34c37/diff</span><br><span class="line">/var/lib/docker/overlay2/784dc7dce7d8625dc10a4fa065f2a1f27ff65e19def543c9f491f32575ec09dd/diff</span><br><span class="line">/var/lib/docker/overlay2/0fee07bf5795a78e666b18059a4f64eb84d184d07eb6a5d1118ed487338e9edf/diff</span><br></pre></td></tr></table></figure><p>如上所示，这些层实际存放在 <code>/var/lib/docker/overlay2/层哈希值/diff</code>目录中，很明显，上述命令查询出的路径中的层哈希值和之前<code>docker pull</code>或者<code>RootFS</code>中显示的哈希值都不一样，上述路径中的哈希值是根据一定的规律，层层递进计算出来的，如果对这些哈希值之间的关系和计算方法感兴趣，可以去搜索“docker layerID diffID chainID cacheID”这些关键字，这并不是此处要关注的重点，所以不用纠结这些细节，我们只要知道，这些查出来路径就是镜像层实际的存放路径即可。</p><p>由于上述命令已经完成了排序，所以我们看到的层的顺序就是对应层在镜像中的位置，也就是说，上例中查询出来的 43722a4a12628 是最上层，对应 RootFS 中的 457b93dcc46 ，上例中的 0fee07bf5795a7 是最下层，对应 RootFS 中的 4f118a86fef9d ，总之，镜像的层对应的文件实际存放在 diff 目录中。</p><p>其实聊了半天，无非都是在说镜像的层而已，现在咱们基于镜像，创建一个容器，看看容器层是怎么和镜像层结合的。</p><p>此处基于 faiss_benchmark 镜像创建一个 faiss-demo1 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name faiss-demo1 -dit 172.16.1.99/hippo/runtime/x86/faiss_benchmark:20240712_68ba1e1 bash</span><br></pre></td></tr></table></figure><p>使用 docker inspect 命令查看容器的详细信息，在详细信息的 GraphDriver 段可以看到容器的层信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## docker inspect faiss-demo1 | jq <span class="string">&#x27;.[].GraphDriver&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Data&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;LowerDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4-init/diff:/var/lib/docker/overlay2/0fee07bf5795a78e666b18059a4f64eb84d184d07eb6a5d1118ed487338e9edf/diff:/var/lib/docker/overlay2/43722a4a12628179c70d588fcc7f64b86aa92cbd30c8599035d0433059423dcf/diff:/var/lib/docker/overlay2/0fed41f6f307ef92b1b1d475108575f0130d224eb008dfa3ff4383c8fa506de6/diff:/var/lib/docker/overlay2/cd5c2d405030b7ed966d1b78c3b038c1c6b313b8be7d0033835bf9ae20c34c37/diff:/var/lib/docker/overlay2/784dc7dce7d8625dc10a4fa065f2a1f27ff65e19def543c9f491f32575ec09dd/diff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;MergedDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/merged&quot;</span>,</span><br><span class="line">    <span class="string">&quot;UpperDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/diff&quot;</span>,</span><br><span class="line">    <span class="string">&quot;WorkDir&quot;</span>: <span class="string">&quot;/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/work&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;overlay2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察上列的返回信息，你会发现，faiss-demo1 容器其实就是使用了 overlay2 文件系统，将 faiss_benchmark 镜像各个层的 diff 目录作为 LowerDir 只读层（在这个基础上添加了一层 init 只读层，之后再聊它），将容器的 diff 目录（c156d03c1532 文件夹中的 diff 目录）作为 UpperDir 可读写层，叠加后呈现在了 MergedDir 层（MergedDir 是 c156d03c1532 文件夹中的 merged 目录），而我们在容器中看到的、操作的文件，其实就是 MergedDir 中的内容。</p><p>我们从宿主机的挂载信息中，也可以侧面验证这一点，在容器启动的情况下，执行如下命令，查看对应的 overlay2挂载点信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## mount | grep overlay | grep c156d03c1532</span><br><span class="line">overlay on /var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/merged <span class="built_in">type</span> overlay (rw,relatime,lowerdir=/var/lib/docker/overlay2/l/62APW7R2QAZIKL2JBXGDL2SZFX:/var/lib/docker/overlay2/l/VHFAUXFFYMW7NZ5S3SKLFYMS6R:/var/lib/docker/overlay2/l/FUWWJ73CD3TWQY4ESCXJSQD3Y7:/var/lib/docker/overlay2/l/V2E4YYCC3PEBB4VYHJ3P2E7JMA:/var/lib/docker/overlay2/l/5FRUEQSAL6URPMBZ4V5VHEOJDR:/var/lib/docker/overlay2/l/54MNMNIOUGOPX7SLOTKFTZHE5R,upperdir=/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/diff,workdir=/var/lib/docker/overlay2/c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4/work)</span><br><span class="line"></span><br><span class="line"><span class="comment">#上述挂载点中的有很多/var/lib/docker/overlay2/l/下的路径，查看这些路径，会发现这些路径都是软链接，软连接指向的路径就是那些diff目录</span></span><br><span class="line">[root@pudding-160 ~]## ll /var/lib/docker/overlay2/l/62APW7R2QAZIKL2JBXGDL2SZFX</span><br><span class="line">lrwxrwxrwx 1 root root 77 Jul 29 15:47 /var/lib/docker/overlay2/l/62APW7R2QAZIKL2JBXGDL2SZFX -&gt; ../c156d03c1532a2efce8670b7d665e0d4840e1b798c47998b8f746c3aaf8d82b4-init/diff</span><br><span class="line">[root@pudding-160 ~]#</span><br><span class="line">[root@pudding-160 ~]## ll /var/lib/docker/overlay2/l/VHFAUXFFYMW7NZ5S3SKLFYMS6R</span><br><span class="line">lrwxrwxrwx 1 root root 72 Jul 29 15:38 /var/lib/docker/overlay2/l/VHFAUXFFYMW7NZ5S3SKLFYMS6R -&gt; ../0fee07bf5795a78e666b18059a4f64eb84d184d07eb6a5d1118ed487338e9edf/diff</span><br></pre></td></tr></table></figure><p>看到这里，我们应该能够完全理解镜像层、容器层、overlay2 文件系统时怎么融合在一起的了。首先，镜像下载到本地后，各个镜像层的文件存放在对应的 diff 目录中，当我们基于镜像创建容器时，docekr 引擎会为容器创建对应的各个目录，比如 diff、work、merged 目录，然后把镜像层的 diff 目录作为 overlay 中的 lowerDir，将容器的 diff 目录作为 overlay 中 upperDir，将折叠后的结果挂载到了 merge 目录中，最后，docekr 通过 <code>mount namespace</code> 技术，将 merged 目录隔离挂载到容器中。</p><p>现在，再看下图是不是一目了然了</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Untitled1.png" alt="镜像层、容器层之间的关系"></p><p>你可以做一些实验，比如，在容器中创建一些文件，修改一些文件，看看容器的 diff 目录中的变化情况，因为容器的 diff 目录就是读写层，当在容器中进行写操作时，最直接的变化会体现到容器的 diff 目录中，但是，你可能会遇到一些“意外情况”，比如，你在容器中修改了/etc/hosts 文件，发现容器的 diff 目录中并没有对应的 /etc/hosts 文件出现，这是因为有一个特殊的层存在，这个层就是我们刚才看到的”-init层”。当我们创建一个容器时，docker 会为容器进行一些初始化工作，其中就包括生成 hosts 信息、生成 hostname 等，你会发现，即使你在容器中修改了 /etc/host 文件，重启容器后，hosts 文件也会变成原来的样子（通过其他方法可以永久修改），因为 /etc/hosts、/etc/hostname、/etc/resolv.conf 文件中的信息都是 docker 生成的，docker 认为这些信息应该是针对容器当前的状态而存在的，以 hosts 文件为例来说，如果容器没有固定的 IP 地址，那么重启容器后，容器的 IP 可能会发生变化，所以每次重启容器时 docker 都会重新生成 hosts 内容，避免之前生成的 hosts 与当前状态所需要的 hosts 不符，当我们在容器中修改  /etc/hosts 文件时，会发现宿主机中的<code>/var/lib/docker/containers/容器ID/</code>目录下的 hosts 文件内容也发生了同样的变化，其实，docker 就是将宿主机中的<code>/var/lib/docker/containers/容器ID/hosts</code>文件挂载到了容器中的，既然这些状态应该属于容器，那么当我们基于容器创建镜像时，就不应该把容器中的这些信息带入到新创建的镜像中，当我们使用<code>docker commit</code>命令基于容器创建镜像时，会把容器的可读写层变成新创建出的镜像的最上层，所以，如果容器的可读写层中包含 hosts 文件，新镜像中就会带入容器的 hosts 信息，而容器因为 init 层和挂载操作的存在，避免了这些信息进入到容器的可读写层，所以可以保障我们基于容器创建镜像时，得到的镜像是“纯净”的。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="rootfs"><a href="#rootfs" class="headerlink" title="rootfs"></a>rootfs</h3><p>在讲 overlay2 之前，我们需要先简单了解一下什么是 rootfs：</p><p>rootfs 也叫 <strong>根文件系统</strong>，是 Linux 使用的最基本的文件系统，是内核启动时挂载的第一个文件系统，提供了根目录 <code>/</code> ，根文件系统的各个目录，例如 /bin、/etc、/mnt 等，再将其他分区挂载到 /mnt，/mnt 目录下就有了这个分区的各个目录和文件。</p><p>docker 容器中使用的同样也是 rootfs 这种文件系统，当我们通过 <code>dockr exec</code> 命令进入到容器内部时也可以看到在根目录下有 /bin、/etc、/tmp 等目录，但是在 docker 容器中与 Linux 不同的是，在挂载 rootfs 后，docker deamon 会利用<strong>联合挂载技术</strong>在已有的 rootfs 上再挂载一个读写层，容器在运行过程中文件系统发生的变化只会在读写层进行修改，并通过 whiteout 文件隐藏只读层中的旧版本文件。</p><blockquote><p>whiteout 文件：<br>whiteout 概念存在于联合文件系统（UnionFS）中，代表某一类占位符形态的特殊文件，当用户文件夹的共通部分联合到一个目录时（例如 bin）目录，用户可以删除归属于自己的某些系统文件副本，但归属于系统级的原件仍存留于同一个联合目录，此时系统将产生一份 whiteout 文件，表示该文件在当前用户目录中已删除，但系统目录中仍然保留。</p></blockquote><h3 id="联合挂载文件"><a href="#联合挂载文件" class="headerlink" title="联合挂载文件"></a>联合挂载文件</h3><p>所谓联合挂载文件（Union Mount），就是将原有的文件系统中的不同目录进行<strong>合并（merge）</strong>，最后向我们呈现出一个合并后文件系统。在 overlay2 文件结构中，联合挂载技术通过联合三个不同的目录来实现：lower 目录、upper 目录和 work 目录，这三个目录联合挂载后得到 merged 目录：</p><ul><li>lower 目录：<strong>只读层</strong>，可以有多个，处于最底层目录</li><li>upper 目录：<strong>读写层</strong>，只有一个</li><li>work 目录：工作基础目录，挂载后内容被清空，且在使用过程中其内容不可见</li><li>merged 目录：联合挂载后得到的<strong>视图</strong>，其中本身并没有实体文件，实际文件都在 upper 目录和 lower 目录中。在 merged 目录中对文件进行编辑，实际会修改 upper 目录中文件；而在 upper 目录与 lower 目录中修改文件，都会影响我们在 merged 目录看到的结果。</li></ul><h2 id="overlayFS"><a href="#overlayFS" class="headerlink" title="overlayFS"></a><strong>overlayFS</strong></h2><p>在介绍 docker 中使用的 overlay2 文件结构前，我们先通过对 overlay 文件系统进行简单的操作演示以便更深入理解不同层不同目录之间的关系</p><p>先创建几个文件夹和文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">mkdir</span> A B C worker</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From A&quot;</span> &gt;&gt; A/b.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From A&quot;</span> &gt;&gt; A/c.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From B&quot;</span> &gt;&gt; B/a.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From B&quot;</span> &gt;&gt; B/d.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From C&quot;</span> &gt;&gt; C/b.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> <span class="built_in">echo</span> <span class="string">&quot;From C&quot;</span> &gt;&gt; C/e.txt</span><br><span class="line">pudding@DESKTOP-1QCHCU4:~$ tree</span><br></pre></td></tr></table></figure><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image.png" alt="目录 tree"></p><p>使用 mount 命令挂载成 overlayFS 文件系统，格式如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t overlay overlay -o lowerdir=lower1:lower2:lower3,upperdir=upper,workdir=work merged_dir</span><br></pre></td></tr></table></figure><p>在这个例子中，我们用 A 和 B 两个文件夹作为 lower 目录，用 C 作为 upper 目录，worker 作为 work 目录，挂载到 /home/pudding/merged 目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> merged</span><br><span class="line"><span class="built_in">sudo</span> mount -t overlay overlay -o lowerdir=A:B,upperdir=C,workdir=worker /home/pudding/merged</span><br></pre></td></tr></table></figure><p>挂载后我们可以查看一下 merged 目录下的文件</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image1.png" alt="merged tree"></p><p>可以看到我们原本的 A B C 三个目录下的文件已经合并，相同的文件名的文件将会选择性的显示，在 merged 中显示里 merged 层更近的文件，upper 层比 lower 层更近，同样 lower 层中，排序靠前的比排序靠后的更近（取决于mount 脚本中 lowerdir=A:B ），在这个例子中就是 A 比 B 更靠近 merged 层</p><p>根据这个规律，我们可以先分析下 merge 层中的文件来源，a.txt 在 A、B 中都有，但是 A 比 B 更靠近 merged 层，所以 merged 层的 a.txt 应该来自 A 目录，b.txt 在 A 和 C 中都有，但是 C 是 upper 层，所以 b.txt 应该来自 C 目录，我们可以核实一下</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image2.png" alt="cat files"></p><p>接下来我们可以看下 upper 层、lower 曾和 merged 层之间的关系，上文已经提到了 upper 层是<strong>读写层</strong>而 lower 层是<strong>只读层</strong>，merged 层是联合挂载后的视图，那如果我们在 merged 层中对文件进行操作会生什么</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image3.png" alt="change merged file"></p><p>我们修改 merge 层的 a.txt 文件，可以看到 merged 层的 a.txt 内容虽然改变，但是 A 目录（只读层）下的 a.txt 内容并没有发生变化，而在 C 目录（读写层）下多了一个 a.txt 文件，内容就是我们修改过的 a.txt 的内容，这就是只读层和读写层的关系，<strong>在 merged 目录对文件进行修改并不会影响到只读层的源文件，只会对读写层进行编辑</strong>。</p><p>如果我们在 merged 层删除文件会发生什么</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image4.png" alt="delete file"></p><p>可以看到在 merged 目录中已经没有 c.txt 文件了，但是 c 目录下却多了一个 c.txt，这个文件就是我们在一开始提到的 <strong>whiteout 文件</strong>，它是主/次设备号都为 0 的字符设备，overlay 文件结构通过使用这种特殊文件来实现文件删除功能，在 merged 目录下使用 ls 命令查看文件时，overlay 会自动过滤掉 upper 目录下的 whiteout 文件以及在 lower 目录下的同名文件，以此实现文件删除效果</p><p>还有一个值得提到的点：overlay 在文件进行操作时用到了<strong>写时复制（Copy on Write）技术</strong>，在没有对文件进行修改时，merged 目录直接使用 lower 目录下的文件，只有当我们在 merged 目录对文件进行修改时，才会把修改的文件复制到 upper 目录</p><h2 id="Docker-overlay2"><a href="#Docker-overlay2" class="headerlink" title="Docker overlay2"></a><strong>Docker overlay2</strong></h2><p>有了对 overlayFS 的基本了解，我们接下来就可以着手分析 Docker 的 overlay2 文件结构了，实际上 Docker 支持的存储驱动有很多种：overlay、overlay2、aufs、vfs 等，在 Ubuntu 较新版本中的 Docker 中普遍采用了 overlay2 这种文件结构，其具有更优越的驱动性能，而 overlay 和 overlay2 的本质区别就是二者在镜像层之间的共享数据方法不同：</p><ul><li>overlay 通过 硬链接 的方式共享数据，只支持，增加磁盘 inode 负担</li><li>overlay2 通过 将多层的 lower 文件联合在一起</li></ul><p>简而言之，overlay2 就是 overlay 的改进版本，我们可以通过 docker info 命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:~$ <span class="built_in">sudo</span> docker info | grep -i <span class="string">&quot;storage driver&quot;</span></span><br><span class="line"> Storage Driver: overlay2</span><br></pre></td></tr></table></figure><p>在 Docker 中，我们日常操作主要涉及两个方面：镜像层与容器层，镜像层就是我们通过 <strong>docker pull</strong> 等命令下载到本机中的镜像，而容器层则是我们通过 <strong>docker exec</strong> 等命令进入的交互式终端，如果你使用过 Docker，你会发现我们只用一个镜像，通过 <strong>docker run</strong> 可以产生很多个容器，这就可以类比 upper 与 lower 两层，镜像作为 lower 层，只读提供文件系统基础，而容器作为 upper 层，我们可以在其中进行任意文件操作，只用同一个镜像就可以申引出不同的容器，这也是一种节约空间资源的方式吧（我的推测</p><p>接下来我们稍微详细地探讨下镜像层与容器层，还有他们的元数据</p><h3 id="镜像层"><a href="#镜像层" class="headerlink" title="镜像层"></a>镜像层</h3><p>我们可以通过 <code>docker inspect [IMAGE ID]</code> 来查看镜像配置</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image5.png" alt="image GraphDriver"></p><p>其中的 GraphDriver 字段中关于 overlay2 文件结构的目录信息</p><p>每一层的对应都在配置信息中体现的非常清楚，但是有一点问题，我们在实际查看文件夹的时候，可以发现镜像层其实并没有 /merged 目录，<strong>我的理解</strong> /merged 目录只在运行容器时存在；这个目录是 Docker 为容器提供的一个视图，它将 lowerdir 和 upperdir 层合并为一个统一的文件系统供容器访问；虽然 merged 目录不存在于镜像层，但 Docker 在 GraphDriver 字段中提供了这些信息，以确保我们能够理解整个 overlay2 文件系统的结构。（不一定对</p><p>可以看到镜像的目录是在 <code>/var/lib/docker/overlay2</code> 下，我们打开一个镜像层看一看其中都有哪些文件</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image6.png" alt="image overlay2"></p><p>其中我们关注一下 diff 目录、link 和 lower 文件</p><h4 id="diff-目录"><a href="#diff-目录" class="headerlink" title="diff 目录"></a>diff 目录</h4><p><strong>在这个目录中存放的是当前镜像层的文件，</strong>刚刚在介绍 overlay2 与 overlay 区别的时候提到了 overlay2 是将多个 lower 层联合到一起，在上面的图中也可以看到，多个 lower 层之间用<code>:</code>分割，在这些层中每一层都有一部分文件，把他们联合到一起就得到了完整的 rootfs</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image7.png" alt="image diff"></p><h4 id="link-文件"><a href="#link-文件" class="headerlink" title="link 文件"></a>link 文件</h4><p>link 文件中的内容是<strong>当前层的软链接名称</strong></p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image8.png" alt="image link"></p><p>这些链接都在 <code>/var/lib/docker/overlay2/l</code> 目录下</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image9.png" alt="image link"></p><p>使用软链接的目的是<strong>为了避免受到 mount 命令参数的长度限制</strong></p><blockquote><p><code>getconf ARG_MAX</code><br>该值决定了一个进程的命令行参数和环境变量的总长度<br>通常在 Linux 系统上为 2MB（2097152 字节）</p></blockquote><h4 id="lower-文件"><a href="#lower-文件" class="headerlink" title="lower 文件"></a>lower 文件</h4><p>lower 文件中的内容是<strong>在此层之下的所有层的软连接名称</strong>，最底层不存在该文件，我们知道 upper 层在 lower 层之上，而 lower 层中越靠后的则越在底层</p><p>我们查看 upper 层对应目录下 lower 文件，可以看到其中有 4 个软链接</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image10.png" alt="image lower"></p><p>恰好 lower 目录中有 4 个镜像层</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image11.png" alt="image GraphDriver lower"></p><p>在 lower 层中，处于最底层的则是应该在 <code>:</code> 最后的目录，即，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/overlay2/784dc7dce7d8625dc10a4fa065f2a1f27ff65e19def543c9f491f32575ec09dd</span><br></pre></td></tr></table></figure><p>查看这一目录下的文件，可以发现它并没有 lower 文件</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image12.png" alt="image lowest"></p><p>这一层对应的软链接即 link 文件内容为 <code>54MNMNIOUGOPX7SLOTKFTZHE5R</code>，我们查看其上一层的 lower 文件内容</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image13.png" alt="image one floor up"></p><p>可以发现确实对应了最底层目录的软链接</p><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><p>Docker 的元数据存储目录为 <code>/var/lib/docker/image/overlay2</code> </p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image14.png" alt="image overlay2"></p><p>我们主要看 imagedb 和 layerdb 这两个文件夹</p><h4 id="imagedb"><a href="#imagedb" class="headerlink" title="imagedb"></a>imagedb</h4><p>这个文件夹中存储了镜像相关的元数据，具体位置是在 <code>/imagedb/content/sha256</code>  目录下，这个目录下的文件以 <strong>IMAGE ID</strong> 来命令</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image15.png" alt="image imagedb"></p><p>这个文件的内容就是我们通过 <code>docker inspect [IMAGE ID]</code> 命令查看到的信息，其中我们关注 <code>RootFS</code> 字段</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/Untitled2.png" alt="image RootFS"></p><p>可以看出这个字段中有很多 sha256 值，这些哈希值称为 <strong>diff_id</strong>，其从上至下的顺序就表示镜像层最底层到最顶层，也就是说每个 diff_id 对应了一个镜像层，实际上，对应每一个镜像层的还有另外两个 id：<strong>cache_id</strong> 和 <strong>chain_id</strong></p><ul><li><strong>cache_id</strong> 就是在 <code>docker/overlay2</code> 目录下看到的文件夹名称，也是我们通过 <code>docker inspect [IMAGE ID]</code> 命令查看 GraphDriver 字段对应不同的 Dir，其本质是宿主机随机生成的 uuid  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image16.png" alt="image cache_id"></li><li>chain_id 是通过 diff_id 计算出来的，是 Docker 内容寻址机制采用的索引 ID<ul><li>chain_id 在目录 <code>/var/lib/docker/image/overlay2/layerdb/sha256</code> 查看</li><li>如果当前镜像层为最底层，则其 chain_id 与 diff_id 相同</li><li>如果当前镜像层不是最底层，则其 chain_id 计算方式为：<code>sha256(上层chain_id + &quot; &quot; + 本层diff_id)</code></li></ul></li></ul><p>这三个 id 之间存在一一对应的关系，我们可以通过 diff_id 计算得到 chain_id，又可以通过 chain_id 找到对应的 cache_id，下面我们举个栗子说明一下：</p><p>我们刚刚提到了 diff_id 从上至下是最底层到最顶层</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image17.png" alt="image RootFS"></p><p>查看 chain_id</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image18.png" alt="image chain_id"></p><p>可以看到其中确实有一个 chain_id 与 最底层的 diff_id 相同，有了最底层的 chain_id 我们就可以计算出下一层的 chain_id，至于具体如何计算，以及如何通过 chain_id 找到对应的 cache_id，我们需要先了解 layerdb 目录下的内容</p><h4 id="layerdb"><a href="#layerdb" class="headerlink" title="layerdb"></a>layerdb</h4><p>我们现在已知 Docker 的镜像层作为只读层，容器曾作为读写层，而 Docekr 实际上定义了 roLayer 接口与 mountLayer 接口，分别用来描述（只读）镜像层与（读写）容器层，这两个接口的元数据就在目录 <code>/var/lib/docker/image/overlay2/layerdb</code> 下</p><ul><li><strong>roLayer</strong>  rolayer 接口用来描述镜像层，元数据的具体目录在 <code>layerdb/sha256/</code> 下，在此目录下每个文件夹都以每个镜像层的 chain_id 命名  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image19.png" alt="image roLayer">  在文件夹中主要有这 5 个文件，我们简单介绍一下：<ul><li>cache-id：当前 chain_id 对应的 cache_id，用来索引镜像层</li><li>diff：当前 chain_id 对应的 diff_id</li><li>parent：当前 chain_id 对应的镜像层的下一层（父层）镜像 chain_id，最底层不存在该文件</li><li>size：当前 chain_id 对应的镜像层物理大小，单位是字节</li><li>tar-split.json.gz：当前 chain_id 对应镜像层压缩包的 split 文件，可以用来还原镜像层的 tar 包，通过 <code>docker save</code> 命令导出镜像时会用到</li></ul>  我们在上一节中已经判断出了最底层对应的 chain_id，不妨查看一下对应目录下的文件  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image20.png" alt="image lowest chain_id">  可以看到该目录下确实没有 parent 文件，那么我们再查看其下一层，通过 diff_id 的顺序我们可以得知其下一层的 diff_id 为 <code>0d5cae34765c1f89a17e5e8e7e6f6f9ddc541151e3efab2487b013faeecac3a6</code> （上文提到的 inspect 的 RootFS 里 Layers 的 sha256 信息），通过计算 sha256，我们可以得出下一层的 chain_id  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image21.png" alt="image one floor up chain_id">  计算得到最底层的下一层镜像 chain_id 为 <code>696245322de78f67f7f15ab9ade64bf0c35cf1f280a66d763230d9e99a3a6d39</code>  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image22.png" alt="image diff">  确实存在该目录，可以看到：<ul><li>diff 文件内容是 <code>004114a8d0e34895acdd9c1c370b1184b239d538e3951887d04d1bda771bd441</code></li><li>parent 文件内容是 <code>4f118a86fef9debde65113068bd2b85f9c5fd65250ac6af2e8281a502cc0a724</code></li></ul>  可以看到与我们计算用到的两个值也完全相同</li><li><strong>mountLayer</strong>  mountLayer 接口用来描述容器层，元数据的具体目录在 <code>layerdb/mounts/</code> ，在此目录下的文件夹以每个容器的容器 ID（CONTAINER ID）命名  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image23.png" alt="image contain">  在这个文件夹下只有 3 个文件，内容如下：  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image24.png" alt="image mountLayer">  简单介绍一下这3个文件：<ul><li>init-id：对应容器 init 层目录名，源文件在 <code>/var/lib/docker/overlay2</code> 目录下</li><li>mount-id：容器层存储在 <code>/var/lib/docker/overlay2</code> 目录下的名称</li><li>parent：容器的镜像层<strong>最顶层</strong>镜像的 chain_id</li></ul>  我们可以查看 parent 文件中 chain_id 对应目录下的 diff 文件  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image25.png" alt="image diff">  根据 diff_id 从上至下的顺序，我们可以确定这个 diff_id 的确是镜像层的最顶层  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image26.png" alt="image rootfs">  在这里我们引入了一个叫做 <strong>init 层</strong> 的概念，实际上，一个完善的容器分为 3 层：镜像层、init 层和容器层，镜像层提供完整的文件系统基础（rootfs），容器层提供给用户进行交互操作与读写权限，而 init 层则是对应每个容器自己的一些系统配置文件，我们可以看一下 ini 层的内容  <img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image27.png" alt="image init">  可以看到在 diff 目录中有一些 /etc/hosts、/etc/resolv.conf 等配置文件，需要这一层的原因是当容器启动的时候，会有一些每个容器特定的配置文件（例如 hostname），但由于镜像层是只读层无法进行修改，所以就在镜像层之上单独挂载一层 init 层，用户通过修改每个容器对应的 init 层中的一些配置文件从而达到修改镜像配置文件的目的，而在 init 层中的配置文件也仅对当前容器生效，通过 docker commit 命令创建镜像时也不会提交 init 层。</li></ul><h3 id="容器层"><a href="#容器层" class="headerlink" title="容器层"></a>容器层</h3><p>最后我们来看一下容器层的构造，刚刚我们在 <strong>mountLayer</strong> 一节的讲述中提到了 <strong>mount-id</strong> 这个文件，而这个文件的内容就是容器目录的名称，我们可以通过 <code>docker inspect [CONTAINER ID]</code> 命令也可以判断</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image28.png" alt="image mount-id"></p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image29.png" alt="image graphdriver"></p><p>可以看到其实容器层的目录与镜像层、init层都在同一目录下，其实也就说明了他们在文件结构上都是相同的</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image30.png" alt="image overlay2"></p><p>同样都是这几个文件，但不同的是，我们可以看到在容器层确实有了 merge 这个目录，与我们在文章一开始实现的 overlayFS 是相同的</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image31.png" alt="image merged"></p><p>在 merge 目录下展现了完整的 rootfs 文件系统，这就是 overlay2 通过联合挂载技术，将镜像层、init 层与容器层挂载到一起呈现的结果，这也是我们通过 <code>docker exec</code> 命令进入容器的交互式终端看到的结果，也就是所谓的<strong>视图</strong></p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image32.png" alt="image contain"></p><h4 id="link-amp-lower-文件"><a href="#link-amp-lower-文件" class="headerlink" title="link &amp; lower 文件"></a><strong>link &amp; lower 文件</strong></h4><p>我们在镜像层的时候已经讲过这两个文件了，在容器层中这两个文件与镜像层作用是相同的，不过我们可以看一下 lower 文件的内容</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image33.png" alt="image lower"></p><p>前面讲过，lower 文件的内容是在此层之下的所有层的软链接名称，我们已知此镜像的镜像层共 4 层（lower 层 3 个，upper 层 1 个），但是我们从上图可以看到在容器层之下有 5 个其他层，那多出来的一个就是我们在上一节中提到的 init 层，init 层也有其对应的软链接（看上一节中的图），所以在 <code>docker/overlay2/l</code> 目录下实际上有 6 个软连接（4个镜像层，1个 init 层，1 个容器层）</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image34.png" alt="image link"></p><p>而通过 <code>docker inspect [CONTAINER ID]</code> 命令我们也可以判断出容器层是最顶层，其次是 init 层，最下面是镜像层，也对应了 lower 文件中软链接的顺序</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image35.png" alt="image graphdriver"></p><h4 id="diff-目录-1"><a href="#diff-目录-1" class="headerlink" title="diff 目录"></a><strong>diff 目录</strong></h4><p>这个目录实际上就是 overlayFS 文件结构中的 upper 层（上图中也能看到），所以它的用途就是保存用户在容器中（merged 层）对文件进行的编辑</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image36.png" alt="image diff"></p><p>我们在容器内的 /root/A 目录下创建了一个 a.txt 文件，可以看到在 diff 目录下也体现了出来，我们再尝试在容器中删除原本镜像自带的文件看一看效果</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image37.png" alt="image contain"></p><p>我们在容器中删除 /etc 目录下的 shadow 文件，可以看到在 diff 目录下的 /etc 中多了一个 shadow 文件，而这个文件实际上就是我们在文章一开始讲到的 whiteout 文件，用来隐藏我们已经删掉的 shadow 文件，而实际上镜像层的 shadow 文件并没有被删除</p><p><img src="/img/2024-08-28-%E4%BA%86%E8%A7%A3%E5%AE%B9%E5%99%A8overlay%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/image38.png" alt="image diff"></p><p>至此，我们对于 Docker 使用的 overlay2 文件结构分析结束。</p>]]></content>
    
    
    <summary type="html">Docker 的 overlay2 存储驱动基于 OverlayFS 文件系统，高效管理容器和镜像层。通过 docker run 创建容器时，Docker 将多个只读镜像层（LowerDir）与可读写的容器层（UpperDir）及初始化层（init）结合，形成 MergedDir 中的统一文件系统视图。通过 docker cp 复制到容器的文件存储在 /var/lib/docker/overlay2 的 UpperDir 中。使用 docker rm 删除容器后，UpperDir 及其相关文件会被移除，确保 overlay2 目录中无残留数据。LowerDir 保存不可变的镜像层，UpperDir 捕获运行时修改，采用写时复制技术提升效率。init 层处理容器特定配置，如 /etc/hosts，这些配置不会在通过 docker commit 创建新镜像时保留。元数据存储在 /var/lib/docker/image/overlay2 中，通过 diff_id、chain_id 和 cache_id 映射层关系。/var/lib/docker/overlay2/l 中的软链接避免命令行长度限制，提升性能。这种结构确保隔离、资源高效利用和干净删除，使 overlay2 成为 Docker 存储的可靠选择。</summary>
    
    
    
    
    <category term="Docker" scheme="https://wu3227834.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>github 国内代理访问下载</title>
    <link href="https://wu3227834.github.io/2024/08/20/2024-08-20-github-guo-nei-dai-li-fang-wen-xia-zai/"/>
    <id>https://wu3227834.github.io/2024/08/20/2024-08-20-github-guo-nei-dai-li-fang-wen-xia-zai/</id>
    <published>2024-08-20T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="演示代理"><a href="#演示代理" class="headerlink" title="演示代理"></a><strong>演示代理</strong></h2><ol><li>前缀</li></ol><blockquote><p><a href="https://github.jobcher.com/gh/">https://github.jobcher.com/gh/</a></p></blockquote><ol><li>下载仓库</li></ol><blockquote><p>git clone <a href="https://github.jobcher.com/gh/">https://github.jobcher.com/gh/</a>&lt;你要下载的GitHub地址&gt;</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.jobcher.com/gh/https://github.com/wu3227834/ann-filtering-benchmark-datasets.git</span><br></pre></td></tr></table></figure><h2 id="另外一种方法"><a href="#另外一种方法" class="headerlink" title="另外一种方法"></a><strong>另外一种方法</strong></h2><p>在你有科学上网的前提下使用代理方式来连接github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line"><span class="comment">#取消设置</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure><p><a href="http://127.0.0.1:1080/">http://127.0.0.1:1080</a> 是你的代理服务地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;演示代理&quot;&gt;&lt;a href=&quot;#演示代理&quot; class=&quot;headerlink&quot; title=&quot;演示代理&quot;&gt;&lt;/a&gt;&lt;strong&gt;演示代理&lt;/strong&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;前缀&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="Git" scheme="https://wu3227834.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>python 并发函数</title>
    <link href="https://wu3227834.github.io/2024/08/20/2024-08-20-python-bing-fa-han-shu/"/>
    <id>https://wu3227834.github.io/2024/08/20/2024-08-20-python-bing-fa-han-shu/</id>
    <published>2024-08-20T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工作需要向几十万表写入亿级别数据，想使用 pyhon 的并发执行。才开始使用 ThreadPoolExecutor 发现奇慢无比，大佬说这其实是串行，并发得用  multiprocessing，立帖研究。</p><p>本文以 python3.10 为例，学习一下 python 的并发执行。</p><h2 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h2><p>python 并发执行分三个方面：多线程（threading）、多进程（multiprocessing）、多协程（asynico）</p><p>适当的工具选择主要取决于要执行的任务（CPU 密集型或 IO 密集型）：</p><ul><li>CPU 密集型（CPU-bound）：也叫做计算密集型，是指 I/O 在很短时间内就可以完成，CPU  需要大量的计算和处理，特点是 CPU 占用率相当高；例如：<strong>压缩/解压缩、加密解密、正则表达式搜索、计算</strong>；</li><li>IO 密集型（I/O bound）：是指系统运作大部分的状况是 CPU 在等 I/O（硬盘，内存）的读写操作，CPU 占用率较低，例如：<strong>文件处理，网络爬虫，读写数据库；</strong></li></ul><p>在对比这三种方式之前，让我们先了解两个概念：<strong>并行和并发</strong></p><h3 id="并行和并发的区别"><a href="#并行和并发的区别" class="headerlink" title="并行和并发的区别"></a>并行和并发的区别</h3><p>在 Python 中，”并发”和”并行”是两个相关但不同的概念。</p><blockquote><p>并发 （Concurrency）是指程序的设计方式，允许多个任务在重叠的时间段内执行。虽然在同一时刻只能执行一个任务，但任务之间可以通过切换上下文来实现交替执行。这种交替执行的方式可以提高程序的响应性和效率，尤其是在处理 I/O 密集型任务时。在并发编程中，任务之间通常是独立的，它们可以通过多线程、多进程、协程或异步编程等方式来实现。</p><p>并行（Parallelism）是指多个任务同时执行的能力。在并行编程中，多个任务真正地同时执行，通常需要多个物理或逻辑处理单元（例如多核 CPU）。并行执行任务可以显著提高计算密集型任务的性能，但对于I/O密集型任务则没有明显的优势。</p></blockquote><p>简单来说，<strong>并发是指多个任务在重叠的时间段内交替执行，通过切换上下文实现任务之间的交替执行，以提高程序的响应性和效率；而并行是指多个任务真正地同时执行，通常需要多个物理或逻辑处理单元，用于同时处理不同任务，以提高计算密集型任务的性能。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发执行任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Task <span class="subst">&#123;name&#125;</span> started&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Task <span class="subst">&#123;name&#125;</span> completed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行执行任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parallel_task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Task <span class="subst">&#123;name&#125;</span> started&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Task <span class="subst">&#123;name&#125;</span> completed&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并发示例</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    tasks = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]</span><br><span class="line">    executor.<span class="built_in">map</span>(task, tasks)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 并行示例</span></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">    tasks = [<span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>]</span><br><span class="line">    executor.<span class="built_in">map</span>(parallel_task, tasks)</span><br></pre></td></tr></table></figure><p>在上面的示例中，’task’ 函数模拟了一个耗时 2 秒的任务，并使用线程池实现了并发执行。’parallel_task’ 函数也是一个耗时 2 秒的任务，但使用了进程池实现了并行执行。我们可以运行这段代码，观察任务启动时 python 进程的数目、执行的顺序和时间，以更好地理解并发和并行的区别。</p><p>然后，我们来聊 多进程、多线程、多协程的不同、关系以及怎么选择。</p><h3 id="进程、线程、协程的对比"><a href="#进程、线程、协程的对比" class="headerlink" title="进程、线程、协程的对比"></a>进程、线程、协程的对比</h3><ul><li>多进程：<ul><li>优点：可以实现并行，且只有多进程可以实现并行</li><li>缺点：占用资源多，可启动数目最少</li></ul></li><li>多线程：<ul><li>占用资源少，轻量级</li><li>python 的线程是无法并行的（占用多个 cpu），只能进行并发</li><li>切换线程也是有开销的。</li><li>适合 IO 密集型运算、同时运行任务不多（线程可启动数量也是有限制的）</li></ul></li><li>多协程：<ul><li>优点：内存开销最小，可启动数量最多</li><li>缺点：支持的库比较少，代码复杂，例如爬虫不支持，所以想用多协程爬取的话，可以用 aiohttp，不能用 requests</li><li>适用于：IO 密集型、超多任务运行</li></ul></li></ul><h3 id="进程、线程、协程的关系"><a href="#进程、线程、协程的关系" class="headerlink" title="进程、线程、协程的关系"></a>进程、线程、协程的关系</h3><ul><li>一个进程中可以启动很多线程</li><li>一个线程中可以启动很多协程</li></ul><h3 id="python-慢的原因"><a href="#python-慢的原因" class="headerlink" title="python 慢的原因"></a><strong>python 慢的原因</strong></h3><p>两个原因：</p><ul><li>是解释型语言，边解释边执行</li><li>GIL，无法利用多核 CPU</li></ul><p>GIL 是什么，为什么有 GIL？</p><p>全局解释器锁（Global interpreter lock），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。</p><p>python 设计初期为了解决线程并发的问题引入了 GIL，但是现在很难去除，本质是一种锁，它的好处在于简化了 python 对共享资源的管理，但是导致 python 无法实现真正的多线程执行。</p><p>怎样规避 GIL 带来的限制：</p><ul><li>IO 期间线程会释放 GIL，实现 CPU 和 IO 的并发，因此 GIL 的存在对于 IO 密集型计算是有好的，但是对 CPU 密集型则会拖累速度</li><li>利用 multiprocessing，可以利用多核 CPU 的优势</li></ul><h3 id="怎样选择"><a href="#怎样选择" class="headerlink" title="怎样选择"></a><strong>怎样选择</strong></h3><ul><li>IO 密集型运算优先选择多进程</li><li>若满足三点：需要超多任务量、有现成协程库支持 、代码复杂度可以接受，则选择协程，否则选择线程</li></ul><h2 id="threading-—-基于线程的并行"><a href="#threading-—-基于线程的并行" class="headerlink" title="threading — 基于线程的并行"></a><strong>threading — 基于线程的并行</strong></h2><p><a href="https://docs.python.org/zh-cn/3.10/library/threading.html">3.10.13 Documentation » Python 标准库 » 并发执行 » threading — 基于线程的并行</a></p><h2 id="multiprocessing-—-基于进程的并行"><a href="#multiprocessing-—-基于进程的并行" class="headerlink" title="multiprocessing — 基于进程的并行"></a>multiprocessing — 基于进程的并行</h2><p><a href="https://docs.python.org/zh-cn/3.10/library/multiprocessing.html">3.10.13 Documentation » Python 标准库 » 并发执行 » multiprocessing — 基于进程的并行</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://docs.python.org/zh-cn/3.10/library/concurrency.html">3.10.13 Documentation » Python 标准库 » 并发执行</a></li><li><a href="https://blog.csdn.net/weixin_52906070/article/details/132317118">python并发编程这一篇就够了</a></li><li><a href="https://xz.aliyun.com/t/12766?time__1311=GqGxu7G=oYqWqGN4eeqBKIh4Rh=9kFda4D">python并发从0到1</a></li><li><a href="https://www.itheima.com/news/20230710/103420.html">Python中的并发和并行是什么意思?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;工作需要向几十万表写入亿级别数据，想使用 pyhon 的并发执行。才开始使用 ThreadPoolExecutor 发现奇慢无比，大佬说这其</summary>
      
    
    
    
    
    <category term="Python" scheme="https://wu3227834.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java命令学习系列—Jmap</title>
    <link href="https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jmap/"/>
    <id>https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jmap/</id>
    <published>2024-06-30T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jmap 是 JDK 自带的工具软件，主要用于打印指定 Java 进程（或核心文件、远程调试服务器）的共享对象内存映射或堆内存细节。可以使用 jmap 生成 Heap Dump。</p></blockquote><h2 id="什么是堆-dump"><a href="#什么是堆-dump" class="headerlink" title="什么是堆 dump"></a>什么是堆 dump</h2><p>堆 dump 是反应 Java 堆使用情况的内存镜像，其中主要包括<strong>系统信息、虚拟机信息、完整的线程 dump、所有类和对象的状态</strong>等。一般，在内存不足、GC 异常等情况下，我们怀疑有内存泄漏。这个时候我们就可以制作堆 Dump 来查看具体情况，分析原因。</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>《Java虚拟机的内存组成以及堆内存介绍》《Java GC工作原理》常见内存错误：</p><blockquote><p>outOfMemoryError：年老代内存不足</p><p>outOfMemoryError:PermGen Space：永久代内存不足</p><p>outOfMemoryError:GC overhead limit exceed：垃圾回收时间占用系统运行时间的 98% 或以上</p></blockquote><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><h3 id="用法摘要"><a href="#用法摘要" class="headerlink" title="用法摘要"></a>用法摘要</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jmap [option] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jmap [option] &lt;executable &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jmap [option] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to remote debug server)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    &lt;none&gt;               to print same info as Solaris pmap</span><br><span class="line">    -heap                to print java heap summary</span><br><span class="line">    -histo[:live]        to print histogram of java object heap; <span class="keyword">if</span> the <span class="string">&quot;live&quot;</span></span><br><span class="line">                         suboption is specified, only count live objects</span><br><span class="line">    -permstat            to print permanent generation statistics</span><br><span class="line">    -finalizerinfo       to print information on objects awaiting finalization</span><br><span class="line">    -dump:&lt;dump-options&gt; to dump java heap in hprof binary format</span><br><span class="line">                         dump-options:</span><br><span class="line">                           live         dump only live objects; <span class="keyword">if</span> not specified,</span><br><span class="line">                                        all objects in the heap are dumped.</span><br><span class="line">                           format=b     binary format</span><br><span class="line">                           file=&lt;file&gt;  dump heap to &lt;file&gt;</span><br><span class="line">                         Example: jmap -dump:live,format=b,file=heap.bin &lt;pid&gt;</span><br><span class="line">    -F                   force. Use with -dump:&lt;dump-options&gt; &lt;pid&gt; or -histo</span><br><span class="line">                         to force a heap dump or histogram <span class="keyword">when</span> &lt;pid&gt; does not</span><br><span class="line">                         respond. The <span class="string">&quot;live&quot;</span> suboption is not supported</span><br><span class="line">                         in <span class="built_in">this</span> mode.</span><br><span class="line">    -h | -help           to print <span class="built_in">this</span> help message</span><br><span class="line">    -J&lt;flag&gt;             to pass &lt;flag&gt; directly to the runtime system</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>option</strong>：选项参数是互斥的(不可同时使用)。想要使用选项参数，直接跟在命令名称后即可。</p><p><strong>pid</strong>：需要打印配置信息的进程 ID。该进程必须是一个 Java 进程。想要获取运行的 Java 进程列表，你可以使用 jps。</p><p><strong>executable</strong>：产生核心 dump 的 Java 可执行文件。</p><p><strong>core</strong>：需要打印配置信息的核心文件。</p><p><strong>remote-hostname-or-IP</strong>：远程调试服务器的（请查看jsadebugd）主机名或 IP 地址。</p><p><strong>server-id</strong>：可选的唯一 id，如果相同的远程主机上运行了多台调试服务器，用此选项参数标识服务器。</p><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>**&lt;no option&gt;**：如果使用不带选项参数的 jmap 打印共享对象映射，将会打印目标虚拟机中加载的每个共享对象的起始地址、映射大小以及共享对象文件的路径全称。这与 Solaris 的 pmap 工具比较相似。</p><ul><li>**dump:[live,]format=b,file=<filename>**：以 hprof 二进制格式转储 Java 堆到指定 filename 的文件中。live 子选项是可选的。如果指定了 live 子选项，堆中只有活动的对象会被转储。想要浏览 heap dump，你可以使用 jhat（Java 堆分析工具）读取生成的文件。</li><li><strong>finalizerinfo</strong>：打印等待终结的对象信息。</li><li><strong>heap</strong>：打印一个堆的摘要信息，包括使用的 GC 算法、堆配置信息和 generation wise heap usage。</li><li>**histo[:live]*<em>：打印堆的柱状图。其中包括每个 Java 类、对象数量、内存大小（单位：字节）、完全限定的类名。打印的虚拟机内部的类名称将会带有一个’</em>’前缀。如果指定了live子选项，则只计算活动的对象。</li><li><strong>permstat</strong>：打印 Java 堆内存的永久保存区域的类加载器的智能统计信息。对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。</li><li><strong>F</strong>：强制模式。如果指定的 pid 没有响应，请使用 jmap -dump 或 jmap -histo 选项。此模式下，不支持 live 子选项。</li><li><strong>h</strong>：打印帮助信息。</li><li><strong>help</strong>：打印帮助信息。</li><li>**J<flag> **：指定传递给运行jmap的JVM的参数。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>查看 java 堆（heap）使用情况</strong>，执行命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 31846</span><br><span class="line"></span><br><span class="line">Attaching to process ID 31846, please <span class="built_in">wait</span>...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.71-b01</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s) //GC 方式</span><br><span class="line"></span><br><span class="line">Heap Configuration: //堆内存初始化配置</span><br><span class="line">   MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)</span><br><span class="line">   MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)</span><br><span class="line">   MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小</span><br><span class="line">   NewSize          = 1310720 (1.25MB) //对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小</span><br><span class="line">   MaxNewSize       = 17592186044415 MB //对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小</span><br><span class="line">   OldSize          = 5439488 (5.1875MB) //对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小</span><br><span class="line">   NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率</span><br><span class="line">   SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值 </span><br><span class="line">   PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小</span><br><span class="line">   MaxPermSize      = 85983232 (82.0MB) //对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小</span><br><span class="line">   G1HeapRegionSize = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage: //堆内存使用情况</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space: //Eden区内存分布</span><br><span class="line">   capacity = 33030144 (31.5MB) //Eden区总容量</span><br><span class="line">   used     = 1524040 (1.4534378051757812MB) //Eden区已使用</span><br><span class="line">   free     = 31506104 (30.04656219482422MB) //Eden区剩余容量</span><br><span class="line">   4.614088270399305% used //Eden区使用比率</span><br><span class="line">From Space:  //其中一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:  //另一个Survivor区的内存分布</span><br><span class="line">   capacity = 5242880 (5.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 5242880 (5.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation //当前的Old区内存分布</span><br><span class="line">   capacity = 86507520 (82.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 86507520 (82.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Perm Generation//当前的 “永生代” 内存分布</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 2496528 (2.3808746337890625MB)</span><br><span class="line">   free     = 19523568 (18.619125366210938MB)</span><br><span class="line">   11.337498256138392% used</span><br><span class="line"></span><br><span class="line">670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure><p><strong>查看堆内存（histogram）中的对象数量及大小</strong>。执行命令： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo 3331</span><br><span class="line"></span><br><span class="line">num     <span class="comment">#instances         #bytes  class name</span></span><br><span class="line">编号     个数                字节     类名</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:             7        1322080  [I</span><br><span class="line">   2:          5603         722368  &lt;methodKlass&gt;</span><br><span class="line">   3:          5603         641944  &lt;constMethodKlass&gt;</span><br><span class="line">   4:         34022         544352  java.lang.Integer</span><br><span class="line">   5:           371         437208  &lt;constantPoolKlass&gt;</span><br><span class="line">   6:           336         270624  &lt;constantPoolCacheKlass&gt;</span><br><span class="line">   7:           371         253816  &lt;instanceKlassKlass&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>jmap -histo:live 这个命令执行，JVM会先触发gc，然后再统计信息。</strong></p></blockquote><p><strong>将内存使用的详细情况输出到文件</strong>，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapDump 6900</span><br></pre></td></tr></table></figure><p>然后用 <code>jhat</code> 命令可以参看 <code>jhat -port 5000 heapDump</code> 在浏览器中访问：<code>http://localhost:5000/</code> 查看详细信息</p><blockquote><p>这个命令执行，JVM 会将整个 heap 的信息 dump 写入到一个文件，heap 如果比较大的话，就会导致这个过程比较耗时，并且执行的过程中为了保证 dump 的信息是可靠的，所以会暂停应用。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>如果程序内存不足或者频繁GC，很有可能存在内存泄露情况，这时候就要借助 Java 堆 Dump 查看对象的情况。</li><li>要制作堆 Dump 可以直接使用 jvm 自带的 jmap 命令</li><li>可以先使用 <code>jmap -heap</code> 命令查看堆的使用情况，看一下各个堆空间的占用情况。</li><li>使用 <code>jmap -histo:[live]</code> 查看堆内存中的对象的情况。如果有大量对象在持续被引用，并没有被释放掉，那就产生了内存泄露，就要结合代码，把不用的对象释放掉。</li><li>也可以使用 <code>jmap -dump:format=b,file=&lt;fileName&gt;</code>命令将堆信息保存到一个文件中，再借助jhat命令查看详细内容</li><li>在内存出现泄露、溢出或者其它前提条件下，建议多 dump 几次内存，把内存文件进行编号归档，便于后续内存整理分析。</li></ol><p><strong>Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can’t attach to the process</strong></p><p>在ubuntu中第一次使用 jmap 会报错：<code>Error attaching to process: sun.jvm.hotspot.debugger.DebuggerException: Can&#39;t attach to the process</code>，这是oracla文档中提到的一个bug：<a href="http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7050524,%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A">http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7050524,解决方式如下：</a></p><ol><li>echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope 该方法在下次重启前有效。</li><li>永久有效方法 sudo vi /etc/sysctl.d/10-ptrace.conf 编辑下面这行 <code>kernel.yama.ptrace_scope = 1</code> 修改为 <code>kernel.yama.ptrace_scope = 0</code> 重启系统，使修改生效。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jmap 是 JDK 自带的工具软件，主要用于打印指定 Java 进程（或核心文件、远程调试服务器）的共享对象内存映射或堆内存细节。可以使用 jmap 生成 Heap Dump。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是堆-dum</summary>
      
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java命令学习系列—Jps</title>
    <link href="https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jps/"/>
    <id>https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jps/</id>
    <published>2024-06-30T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jps 位于 jdk 的 bin 目录下，其作用是显示当前系统的 java 进程情况，及其 id 号。 jps 相当于 Solaris 进程工具 ps。不像 ”pgrep java” 或 ”ps -ef grep java” ，jps 并不使用应用程序名来查找 JVM 实例。因此，它查找所有的 Java 应用程序，包括即使没有使用 java 执行体的那种（例如，定制的启动 器）。另外，jps 仅查找当前用户的 Java 进程，而不是当前系统中的所有进程。</p></blockquote><h2 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h2><p>我们知道，很多 JAVA 命令都在 jdk 的 JAVA_HOME/bin/ 目录下面，jps 也不例外，它就在 bin 目录下，它是 java 自带的一个命令。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>jps（Java Virtual Machine Process Status Tool）是 JDK 1.5 提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前 java 进程的一些简单情况。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>jdk 中的 jps 命令可以显示当前运行的 java 进程以及相关参数，它的实现机制如下：</p><p>java 程序在启动以后，会在 <code>java.io.tmpdir</code> 指定的目录下，就是临时文件夹里，生成一个类似于</p><p><code>hsperfdata_User</code> 的文件夹，这个文件夹里（在 Linux 中为 /tmp/hsperfdata_{userName}/），有几个文件，名字就是 java 进程的 pid，因此列出当前运行的 java 进程，只是把这个目录里的文件名列一下而已。 至于系统的参数什么，就可以解析这几个文件获得。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 hsperfdata_root]## ll</span><br><span class="line">total 96</span><br><span class="line">-rw------- 1 root root 32768 Jun 25 21:28 372997</span><br><span class="line">-rw------- 1 root root 32768 Jun 25 21:27 49553</span><br><span class="line">-rw------- 1 root root 32768 Jun 25 21:27 5032</span><br><span class="line">[root@pudding-160 hsperfdata_root]## <span class="built_in">pwd</span></span><br><span class="line">/tmp/hsperfdata_root</span><br><span class="line">[root@pudding-160 hsperfdata_root]## jps</span><br><span class="line">372997 ManagerMaster</span><br><span class="line">49553 RunJar</span><br><span class="line">5032 ManagerAgent</span><br><span class="line">433884 Jps</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>想要学习一个命令，先来看看帮助，使用 <code>jps -help</code> 查看帮助：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]## jps -<span class="built_in">help</span></span><br><span class="line">usage: jps [-<span class="built_in">help</span>]</span><br><span class="line">       jps [-q] [-mlvV] [&lt;<span class="built_in">hostid</span>&gt;]</span><br><span class="line"></span><br><span class="line">Definitions:</span><br><span class="line">    &lt;<span class="built_in">hostid</span>&gt;:      &lt;hostname&gt;[:&lt;port&gt;]</span><br></pre></td></tr></table></figure><p>接下来，为了详细介绍这些参数，我们编写几个类，在 main 方法里写一个 while(true) 的循环，查看 java 进程情况。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.JavaCommand;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pudding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JpsDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>-q 只显示 pid，不显示 class 名称、jar 文件名和传递给 main 方法的参数</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:/mnt/wsl/demo$ jps -q</span><br><span class="line">4167</span><br><span class="line">4312</span><br></pre></td></tr></table></figure><p><strong>-m 输出传递给 main 方法的参数，在嵌入式 jvm 上可能是null，</strong>在这里，在启动 main 方法的时候，我给 String[] args 传递一个参数：pudding，执行<code>jsp -m</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:/mnt/wsl/demo$ jps -m</span><br><span class="line">7760 Jps -m</span><br><span class="line">7674 JpsDemo pudding</span><br></pre></td></tr></table></figure><p><strong>-l 输出应用程序 main class 的完整 package 名或者应用程序的 jar 文件完整路径名：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:/mnt/wsl/demo$ jps -l</span><br><span class="line">4517 sun.tools.jps.Jps</span><br><span class="line">4167 com.JavaCommand.JpsDemo</span><br></pre></td></tr></table></figure><p><strong>-v 输出传递给 JVM 的参数；</strong>在这里，在启动 main 方法的时候，我给 jvm 传递一个参数：-Dfile.encoding=UTF-8，执行<code>jps -v</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pudding@DESKTOP-1QCHCU4:/mnt/wsl/demo$ jps -v</span><br><span class="line">9317 JpsDemo -Dfile.encoding=UTF-8</span><br><span class="line">9391 Jps -Dapplication.home=/usr/lib/jvm/java-8-openjdk-amd64 -Xms8m</span><br></pre></td></tr></table></figure><p>PS：jps 命令有个地方很不好，似乎只能显示当前用户的 java 进程，要显示其他用户的还是只能用 unix/linux 的 ps 命令。</p><blockquote><p>jps 是我最常用的 java 命令。使用 jps 可以查看当前有哪些 Java 进程处于运行状态。如果我运行了一个 web 应用（使用 tomcat、jboss、jetty 等启动）的时候，我就可以使用 jps 查看启动情况。有的时候我想知道这个应用的日志会输出到哪里，或者启动的时候使用了哪些 javaagent，那么我可以使用 jps -v 查看进程的 jvm 参数情况。</p></blockquote><h2 id="jps-失效处理"><a href="#jps-失效处理" class="headerlink" title="jps 失效处理"></a>jps 失效处理</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>用 <code>ps -ef|grep java</code> 能看到启动的 java 进程，但是用 jps 查看却不存在该进程的 id。待会儿解释过之后就能知道在该情况下，jconsole、jvisualvm 可能无法监控该进程，其他 java 自带工具也可能无法使用。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>jps、jconsole、jvisualvm 等工具的数据来源就是这个文件（/tmp/hsperfdata_${userName}/pid)。所以当该文件不存在或是无法读取时就会出现 jps 无法查看该进程号，jconsole 无法监控等问题</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ol><li><strong>磁盘读写、目录权限问题</strong>：若该用户没有权限写/tmp目录或是磁盘已满，则无法创建 /tmp/hsperfdata_${userName}/pid 文件。或该文件已经生成，但用户没有读权限</li><li><strong>临时文件丢失，被删除或是定期清理</strong>：对于 linux 机器，一般都会存在定时任务对临时文件夹进行清理，导致 /tmp 目录被清空。这也是我第一次碰到该现象的原因。常用的可能定时删除临时目录的工具为 crontab、redhat 的 tmpwatch、ubuntu 的 tmpreaper 等等<blockquote><p>这个导致的现象可能会是这样，用 jconsole 监控进程，发现在某一时段后进程仍然存在，但是却没有监控信息了。</p></blockquote></li><li><strong>java 进程信息文件存储地址被设置，不在 /tmp 目录下</strong>：上面我们在介绍时说默认会在 /tmp/hsperfdata_${userName} 目录保存进程信息，但由于以上 1、2 所述原因，可能导致该文件无法生成或是丢失，所以 java 启动时提供了参数（-Djava.io.tmpdir），可以对这个文件的位置进行设置，而 jps、jconsole 都只会从 /tmp 目录读取，而无法从设置后的目录读物信息，这是我第二次碰到该现象的原因</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jps 位于 jdk 的 bin 目录下，其作用是显示当前系统的 java 进程情况，及其 id 号。 jps 相当于 Solaris 进程工具 ps。不像 ”pgrep java” 或 ”ps -ef grep java” ，jps 并不使用应用</summary>
      
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java命令学习系列—Jstack</title>
    <link href="https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jstack/"/>
    <id>https://wu3227834.github.io/2024/06/30/2024-06-30-java-ming-ling-xue-xi-xi-lie-jstack/</id>
    <published>2024-06-30T00:00:00.000Z</published>
    <updated>2025-09-07T13:28:04.082Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>jstack 是 java 虚拟机自带的一种堆栈跟踪工具</p></blockquote><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>jstack 用于生成 java 虚拟机当前时刻的线程快照。线程快照是当前 java 虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是<strong>定位线程出现长时间停顿的原因</strong>，如<strong>线程间死锁、死循环、请求外部资源导致的长时间</strong>等待等。 线程出现停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果 java 程序崩溃生成 core 文件，jstack 工具可以用来获得 core 文件的 java stac k和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外，jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息, 如果现在运行的 java 程序呈现 hung 的状态，jstack 是非常有用的。</p><blockquote><p>So，<strong>jstack命令主要用来查看Java线程的调用堆栈的，可以用来分析线程问题（如死锁）。</strong></p></blockquote><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a><strong>线程状态</strong></h2><p>想要通过 jstack 命令来分析线程的情况的话，首先要知道线程都有哪些状态，下面这些状态是我们使用 jstack 命令查看线程堆栈信息时可能会看到的<strong>线程的几种状态</strong>：</p><ol><li>NEW，未启动的。不会出现在 Dump 中。</li><li>RUNNABLE，在虚拟机内执行的。</li><li>BLOCKED，受阻塞并等待监视器锁。</li><li>WATING，无限期等待另一个线程执行特定操作。</li><li>TIMED_WATING，有时限的等待另一个线程的特定操作。</li><li>TERMINATED，已退出的。</li></ol><h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><p>在多线程的 JAVA 程序中，实现线程之间的同步，就要说说 Monitor。Monitor 是 Java 中用来实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 class 的锁。每一个对象都有，也仅有一个 monitor。下图，描述了线程和 Monitor 之间的关系，以及线程的状态转换图：</p><p><img src="/img/2024-06-30-Jstack/Untitled.png" alt="monitor"></p><p><strong>进入区（Entrt Set）</strong>：表示线程通过 synchronized 要求获取对象的锁。如果对象未被锁住，则进入拥有者；否则则在进入区等待。一旦对象锁被其他线程释放,立即参与竞争。</p><p><strong>拥有者（The Owner）</strong>：表示某一线程成功竞争到对象锁。</p><p><strong>等待区（Wait Set）</strong>：表示线程通过对象的 wait 方法，释放对象的锁，并在等待区等待被唤醒。</p><p>从图中可以看出，一个 Monitor 在某个时刻，只能被一个线程拥有，该线程就是 <code>“Active Thread”</code>，而其它线程都是 <code>“Waiting Thread”</code>，分别在两个队列 <code>“Entry Set”</code> 和 <code>“Wait Set”</code> 里面等候。在 <code>“Entry Set”</code> 中等待的线程状态是 <code>“Waiting for monitor entry”</code>，而在 <code>“Wait Set”</code> 中等待的线程状态是 <code>“in Object.wait()”</code>。 先看  <code>“Entry Set”</code> 里面的线程。我们称被 synchronized 保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 <code>“Entry Set”</code> 队列。对应的 code 就像：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用修饰"><a href="#调用修饰" class="headerlink" title="调用修饰"></a>调用修饰</h2><p>表示线程在方法调用时，额外的重要的操作。线程 Dump 分析的重要信息。修饰上方的方法调用。</p><blockquote><p>locked &lt;地址&gt; 目标：使用 synchronized 申请对象锁成功，监视器的拥有者。<br>waiting to lock &lt;地址&gt; 目标：使用 synchronized 申请对象锁未成功，在迚入区等待。<br>waiting on &lt;地址&gt; 目标：使用 synchronized 申请对象锁成功后，释放锁幵在等待区等待。<br>parking to wait for &lt;地址&gt; 目标</p></blockquote><h3 id="locked"><a href="#locked" class="headerlink" title="locked"></a><strong>locked</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at oracle.jdbc.driver.PhysicalConnection.prepareStatement</span><br><span class="line">- locked &lt;<span class="number">0x00002aab63bf7f58</span>&gt; (a oracle.jdbc.driver.T4CConnection)</span><br><span class="line">at oracle.jdbc.driver.PhysicalConnection.prepareStatement</span><br><span class="line">- locked &lt;<span class="number">0x00002aab63bf7f58</span>&gt; (a oracle.jdbc.driver.T4CConnection)</span><br><span class="line">at com.jiuqi.dna.core.internal.db.datasource.PooledConnection.prepareStatement</span><br></pre></td></tr></table></figure><p>通过 synchronized 关键字，成功获取到了对象的锁,成为监视器的拥有者，在临界区内操作。对象锁是可以线程重入的。</p><h3 id="waiting-to-lock"><a href="#waiting-to-lock" class="headerlink" title="waiting to lock"></a><strong>waiting to lock</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at com.jiuqi.dna.core.impl.CacheHolder.isVisibleIn(CacheHolder.java:<span class="number">165</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0x0000000097ba9aa8</span>&gt; (a CacheHolder)</span><br><span class="line">at com.jiuqi.dna.core.impl.CacheGroup$Index.findHolder</span><br><span class="line">at com.jiuqi.dna.core.impl.ContextImpl.find</span><br><span class="line">at com.jiuqi.dna.bap.basedata.common.util.BaseDataCenter.findInfo</span><br></pre></td></tr></table></figure><p>通过 synchronized 关键字，没有获取到了对象的锁，线程在监视器的进入区等待。在调用栈顶出现，线程状态为 Blocked。</p><h3 id="waiting-on"><a href="#waiting-on" class="headerlink" title="waiting on"></a><strong>waiting on</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">- waiting on &lt;<span class="number">0x00000000da2defb0</span>&gt; (a WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingManager.getWorkToDo</span><br><span class="line">- locked &lt;<span class="number">0x00000000da2defb0</span>&gt; (a WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingThread.run</span><br></pre></td></tr></table></figure><p>通过 synchronized 关键字，成功获取到了对象的锁后，调用了 wait 方法，进入对象的等待区等待。在调用栈顶出现，线程状态为 WAITING 或 TIMED_WATING 。</p><h3 id="parking-to-wait-for"><a href="#parking-to-wait-for" class="headerlink" title="parking to wait for"></a><strong>parking to wait for</strong></h3><p>park 是基本的线程阻塞原语，不通过监视器在对象上阻塞。随 concurrent 包会出现的新的机制，synchronized 体系不同。</p><h2 id="线程动作"><a href="#线程动作" class="headerlink" title="线程动作"></a>线程动作</h2><p>线程状态产生的原因：</p><blockquote><p>runnable：状态一般为RUNNABLE。</p><p>in Object.wait()：等待区等待，状态为 WAITING 或 TIMED_WAITING。</p><p>waiting for monitor entry：进入区等待，状态为 BLOCKED。</p><p>waiting on condition：等待区等待、被 park。</p><p>sleeping：休眠的线程，调用了 Thread.sleep()。</p></blockquote><p><strong>Wait on condition</strong> 该状态出现在线程等待某个条件的发生。具体是什么原因，可以结合 stacktrace 来分析。</p><ul><li>最常见的情况就是线程处于 sleep 状态，等待被唤醒。</li><li>常见的情况还有等待网络 IO：在 java 引入 nio 之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在  NewIO 里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。<ul><li>一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；</li><li>另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。</li></ul></li></ul><p>所以要结合系统的一些性能观察工具来综合分析，比如 netstat 统计单位时间的发送包的数目，如果很明显超过了所在网络带宽的限制；观察 cpu 的利用率，如果系统态的 CPU 时间，相对于用户态的 CPU 时间比例较高；如果程序运行在 Solaris 10 平台上，可以用 dtrace 工具看系统调用的情况，如果观察到  read/write 的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。</p><h2 id="线程-Dump-的分析"><a href="#线程-Dump-的分析" class="headerlink" title="线程 Dump 的分析"></a>线程 Dump 的分析</h2><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>结合代码阅读的推理。需要线程 Dump 和源码的相互推到和印证。</p><p>造成 Bug 的根源往往会在调用栈上直接体现，一定要格外注意线程当前调用之前的所有调用。</p><h3 id="入手点"><a href="#入手点" class="headerlink" title="入手点"></a>入手点</h3><p><strong>进入区等待</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;d&amp;a-3588&quot;</span> daemon waiting <span class="keyword">for</span> monitor entry [<span class="number">0x000000006e5d5000</span>]</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()</span><br><span class="line">- waiting to lock &lt;<span class="number">0x0000000602f38e90</span>&gt; (a java.lang.Object)</span><br><span class="line">at com.jiuqi.dna.bap.authority.service.UserService$LoginHandler.handle()</span><br></pre></td></tr></table></figure><p>线程状态 BLOCKED，线程动作 wait on monitor entry，调用修饰 waiting to lock 总是一起出现。表示在代码级别已经存在冲突的调用。必然有问题的代码，需要尽可能减少其发生。</p><p><strong>同步块阻塞</strong></p><p>一个线程锁住某对象,大量其他线程在该对象上等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;blocker&quot;</span> runnable</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$<span class="number">1.</span>run(Blocker.java:<span class="number">23</span>)</span><br><span class="line">- locked &lt;<span class="number">0x00000000eb8eff68</span>&gt; (a java.lang.Object)</span><br><span class="line"><span class="string">&quot;blockee-11&quot;</span> waiting <span class="keyword">for</span> monitor entry</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$<span class="number">2.</span>run(Blocker.java:<span class="number">41</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0x00000000eb8eff68</span>&gt; (a java.lang.Object)</span><br><span class="line"><span class="string">&quot;blockee-86&quot;</span> waiting <span class="keyword">for</span> monitor entry</span><br><span class="line">java.lang.Thread.State: BLOCKED (on object monitor)</span><br><span class="line">at com.jiuqi.hcl.javadump.Blocker$<span class="number">2.</span>run(Blocker.java:<span class="number">41</span>)</span><br><span class="line">- waiting to lock &lt;<span class="number">0x00000000eb8eff68</span>&gt; (a java.lang.Object)</span><br></pre></td></tr></table></figure><p><strong>持续运行的IO</strong> </p><p>IO操作是会以 RUNNABLE 状态达成阻塞。例如：数据库死锁、网络读写。 格外注意对 IO 线程的真实状态的分析。一般来说，被捕捉到 RUNNABLE 的 IO 调用，都是有问题的。</p><p>以下堆栈显示： 线程状态为 RUNNABLE。 调用栈在 SocketInputStream 或 SocketImpl 上，socketRead0 等方法。 调用栈包含了 jdbc 相关的包。很可能发生了数据库死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;d&amp;a-614&quot;</span> daemon prio=<span class="number">6</span> tid=<span class="number">0x0000000022f1f000</span> nid=<span class="number">0x37c8</span> runnable</span><br><span class="line">[<span class="number">0x0000000027cbd000</span>]</span><br><span class="line">java.lang.Thread.State: RUNNABLE</span><br><span class="line">at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">at java.net.SocketInputStream.read(Unknown Source)</span><br><span class="line">at oracle.net.ns.Packet.receive(Packet.java:<span class="number">240</span>)</span><br><span class="line">at oracle.net.ns.DataPacket.receive(DataPacket.java:<span class="number">92</span>)</span><br><span class="line">at oracle.net.ns.NetInputStream.getNextPacket(NetInputStream.java:<span class="number">172</span>)</span><br><span class="line">at oracle.net.ns.NetInputStream.read(NetInputStream.java:<span class="number">117</span>)</span><br><span class="line">at oracle.jdbc.driver.T4CMAREngine.unmarshalUB1(T4CMAREngine.java:<span class="number">1034</span>)</span><br><span class="line">at oracle.jdbc.driver.T4C8Oall.receive(T4C8Oall.java:<span class="number">588</span>)</span><br></pre></td></tr></table></figure><p><strong>分线程调度的休眠</strong></p><p>正常的线程池等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;d&amp;a-131&quot;</span> in Object.wait()</span><br><span class="line">java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingManager.getWorkToDo(WorkingManager.java:<span class="number">322</span>)</span><br><span class="line">- locked &lt;<span class="number">0x0000000313f656f8</span>&gt; (a com.jiuqi.dna.core.impl.WorkingThread)</span><br><span class="line">at com.jiuqi.dna.core.impl.WorkingThread.run(WorkingThread.java:<span class="number">40</span>)</span><br></pre></td></tr></table></figure><p>可疑的线程等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;d&amp;a-121&quot;</span> in Object.wait()</span><br><span class="line">java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">at java.lang.Object.wait(Native Method)</span><br><span class="line">at java.lang.Object.wait(Object.java:<span class="number">485</span>)</span><br><span class="line">at com.jiuqi.dna.core.impl.AcquirableAccessor.exclusive()</span><br><span class="line">- locked &lt;<span class="number">0x00000003011678d8</span>&gt; (a com.jiuqi.dna.core.impl.CacheGroup)</span><br><span class="line">at com.jiuqi.dna.core.impl.Transaction.lock()</span><br></pre></td></tr></table></figure><h3 id="入手点总结"><a href="#入手点总结" class="headerlink" title="入手点总结"></a><strong>入手点总结</strong></h3><p><strong>wait on monitor entry</strong>： 被阻塞的，肯定有问题</p><p><strong>runnable</strong>： 注意 IO 线程</p><p>**in Object.wait()**： 注意非线程池等待</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>想要学习一个命令，先来看看帮助，使用 <code>jstack -help</code> 查看帮助：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pudding<span class="meta">@DESKTOP</span>-1QCHCU4:~$ jstack -help</span><br><span class="line">Usage:</span><br><span class="line">    jstack [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to running process)</span><br><span class="line">    jstack -F [-m] [-l] &lt;pid&gt;</span><br><span class="line">        (to connect to a hung process)</span><br><span class="line">    jstack [-m] [-l] &lt;executable&gt; &lt;core&gt;</span><br><span class="line">        (to connect to a core file)</span><br><span class="line">    jstack [-m] [-l] [server_id@]&lt;remote server IP or hostname&gt;</span><br><span class="line">        (to connect to a remote debug server)</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">    -F  to force a thread dump. Use <span class="keyword">when</span> jstack &lt;pid&gt; does not <span class="title function_">respond</span> <span class="params">(process is hung)</span></span><br><span class="line">    -m  to print both java and <span class="keyword">native</span> <span class="title function_">frames</span> <span class="params">(mixed mode)</span></span><br><span class="line">    -l  <span class="type">long</span> listing. Prints additional information about locks</span><br><span class="line">    -h or -help to print <span class="built_in">this</span> help message</span><br></pre></td></tr></table></figure><ul><li>-F：当 ’jstack [-l] pid’ 没有相应的时候强制打印栈信息</li><li>-l：长列表。打印关于锁的附加信息，例如属于 java.util.concurrent 的 ownable synchronizers 列表</li><li>-m：打印 java 和 native c/c++ 框架的所有栈信息</li><li>-h：-help 打印帮助信息</li><li>pid：需要被打印配置信息的 java 进程 id，可以用 jps 查询</li></ul><p>首先，我们分析这么一段程序的线程情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pudding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JStackDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">//Do Nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先是有 jps 查看进程号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pudding<span class="meta">@DESKTOP</span>-1QCHCU4:/mnt/wsl$ jps</span><br><span class="line"><span class="number">929</span> org.eclipse.equinox.launcher_1<span class="number">.6</span><span class="number">.800</span>.v20240513-<span class="number">1750.</span>jar</span><br><span class="line"><span class="number">1477</span> sun.tools.jcmd.JCmd</span><br><span class="line"><span class="number">1499</span> Jps</span><br><span class="line"><span class="number">1372</span> JStackDemo1</span><br></pre></td></tr></table></figure><p>然后使用 jstack 查看堆栈信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pudding<span class="meta">@DESKTOP</span>-1QCHCU4:/mnt/wsl$ jstack <span class="number">1372</span></span><br><span class="line"><span class="number">2024</span>-<span class="number">06</span>-<span class="number">26</span> <span class="number">21</span>:<span class="number">41</span>:<span class="number">40</span></span><br><span class="line">Full thread dump OpenJDK <span class="number">64</span>-Bit Server <span class="title function_">VM</span> <span class="params">(<span class="number">25.412</span>-b08 mixed mode)</span>:</span><br><span class="line">...此处省略若干内容...</span><br><span class="line"><span class="string">&quot;main&quot;</span> #<span class="number">1</span> prio=<span class="number">5</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007fc86c00a800</span> nid=<span class="number">0x55d</span> runnable [<span class="number">0x00007fc873672000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at JStackDemo1.main(JStackDemo1.java:<span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>我们可以从这段堆栈信息中看出什么来呢？我们可以看到，当前一共有一条用户级别线程，线程处于 runnable 状态，执行到 <a href="/img/2024-06-30-Jstack/http://JStackDemo1.java">JStackDemo1.java</a> 的第七行。 看下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pudding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JStackDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程堆栈信息如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Reference Handler&quot;</span> daemon prio=<span class="number">10</span> tid=<span class="number">0x00007fbbcc06e000</span> nid=<span class="number">0x286c</span> in Object.wait() [<span class="number">0x00007fbbc8dfc000</span>]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">    at java.lang.Object.wait(Native Method)</span><br><span class="line">    - waiting on &lt;<span class="number">0x0000000783e066e0</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">    at java.lang.Object.wait(Object.java:<span class="number">503</span>)</span><br><span class="line">    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">133</span>)</span><br><span class="line">    - locked &lt;<span class="number">0x0000000783e066e0</span>&gt; (a java.lang.ref.Reference$Lock)</span><br></pre></td></tr></table></figure><p>我们能看到：</p><blockquote><p>线程的状态： WAITING 线程的调用栈<br>线程的当前锁住的资源： &lt;0x0000000783e066e0&gt;<br>线程当前等待的资源：&lt;0x0000000783e066e0&gt;</p></blockquote><p>为什么同时锁住的等待同一个资源：</p><blockquote><p>线程的执行中，先获得了这个对象的 Monitor（对应于 locked &lt;0x0000000783e066e0&gt;）。当执行到 obj.wait()，线程即放弃了 Monitor 的所有权，进入 “wait set” 队列（对应于 waiting on &lt;0x0000000783e066e0&gt; ）。</p></blockquote><h3 id="死锁分析"><a href="#死锁分析" class="headerlink" title="死锁分析"></a><strong>死锁分析</strong></h3><p>学会了怎么使用 jstack 命令之后，我们就可以看看，如何使用 jstack 分析死锁了，这也是我们一定要掌握的内容。 <strong>啥叫死锁？</strong> 所谓<a href="/img/2024-06-30-Jstack/http://zh.wikipedia.org/wiki/%E6%AD%BB%E9%94%81">死锁</a>： 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 </p><p>说白了，我现在想吃鸡蛋灌饼，桌子上放着鸡蛋和饼，但是我和我的朋友同时分别拿起了鸡蛋和病，我手里拿着鸡蛋，但是我需要他手里的饼。他手里拿着饼，但是他想要我手里的鸡蛋。就这样，如果不能同时拿到鸡蛋和饼，那我们就不能继续做后面的工作（做鸡蛋灌饼）。所以，这就造成了死锁。 <strong>看一段死锁的程序：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> pudding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JStackDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLockclass</span>(<span class="literal">true</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DeadLockclass</span>(<span class="literal">false</span>));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeadLockclass</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> falg;</span><br><span class="line">    DeadLockclass(<span class="type">boolean</span> falg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.falg = falg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果falg的值为true则调用t1线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (falg) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Suo.o1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;o1 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">synchronized</span> (Suo.o2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;o2 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果falg的值为false则调用t2线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Suo.o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;o2 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    <span class="keyword">synchronized</span> (Suo.o1) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;o1 &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Suo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">o2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我启动该程序时，我们看一下控制台：</p><p><img src="/img/2024-06-30-Jstack/Untitled1.png" alt="控制台"></p><p>我们发现，程序只输出了两行内容，然后程序就不再打印其它的东西了，但是程序并没有停止。这样就产生了死锁。 当线程 1 使用 <code>synchronized</code> 锁住了 o1 的同时，线程 2 也是用 <code>synchronized</code> 锁住了 o2。当两个线程都执行完第一个打印任务的时候，线程 1 想锁住 o2，线程 2 想锁住 o1。但是，线程 1 当前锁着 o1，线程 2 锁着 o2。所以两个想成都无法继续执行下去，就造成了死锁。<br>然后，我们使用 <strong>jstack 来看一下线程堆栈信息</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f6274003ac8</span> (object <span class="number">0x000000077e004ec0</span>, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">&quot;Thread-0&quot;</span></span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">  waiting to lock monitor <span class="number">0x00007f62740050c8</span> (object <span class="number">0x000000077e004ed0</span>, a java.lang.Object),</span><br><span class="line">  which is held by <span class="string">&quot;Thread-1&quot;</span></span><br><span class="line"></span><br><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">&quot;Thread-1&quot;</span>:</span><br><span class="line">        at DeadLockclass.run(JStackDemo.java:<span class="number">40</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x000000077e004ec0</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x000000077e004ed0</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br><span class="line"><span class="string">&quot;Thread-0&quot;</span>:</span><br><span class="line">        at DeadLockclass.run(JStackDemo.java:<span class="number">27</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x000000077e004ed0</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x000000077e004ec0</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">750</span>)</span><br><span class="line"></span><br><span class="line">Found <span class="number">1</span> deadlock.</span><br></pre></td></tr></table></figure><p>哈哈，堆栈写的很明显，它告诉我们 <code>Found one Java-level deadlock</code>，然后指出造成死锁的两个线程的内容。然后，又通过 <code>Java stack information for the threads listed above</code>来显示更详细的死锁的信息。 他说</p><blockquote><p>Thread-1 在想要执行第 40 行的时候，当前锁住了资源 <code>&lt;0x00000007d6aa2ca8&gt;</code>，但是他在等待资源 <code>&lt;0x00000007d6aa2c98&gt;</code> ；<br>Thread-0 在想要执行第 27 行的时候，当前锁住了资源 <code>&lt;0x00000007d6aa2c98&gt;</code>，但是他在等待资源<code>&lt;0x00000007d6aa2ca8&gt;</code> ；<br>由于这两个线程都持有资源，并且都需要对方的资源，所以造成了死锁。 原因我们找到了，就可以具体问题具体分析，解决这个死锁了。</p></blockquote><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><p><strong>虚拟机执行 Full GC 时，会阻塞所有的用户线程。因此，即时获取到同步锁的线程也有可能被阻塞。</strong> 在查看线程 Dump 时，首先查看内存使用情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;jstack 是 java 虚拟机自带的一种堆栈跟踪工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h2&gt;&lt;p&gt;jstack </summary>
      
    
    
    
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
