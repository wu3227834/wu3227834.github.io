<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pudding 日常</title>
  <icon>https://www.gravatar.com/avatar/00dc32454135c01a0b80be2cbf59b5ab</icon>
  <subtitle>a week is 2% of the year</subtitle>
  <link href="https://wu3227834.github.io/atom.xml" rel="self"/>
  
  <link href="https://wu3227834.github.io/"/>
  <updated>2025-11-13T10:05:49.052Z</updated>
  <id>https://wu3227834.github.io/</id>
  
  <author>
    <name>Pudding</name>
    <email>wu3227834@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技术分析指标-量化回测</title>
    <link href="https://wu3227834.github.io/2025/11/13/2025-11-13-liang-hua-hui-ce/"/>
    <id>https://wu3227834.github.io/2025/11/13/2025-11-13-liang-hua-hui-ce/</id>
    <published>2025-11-13T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.052Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cgws.com/upload/20160530/201605301464570725914.pdf">量化择时之技术分析指标择时初探——金融工程深度报告</a></p><p>技术分析进行择时回测：</p><ul><li>趋势型: MA, MACD</li><li>超买超卖型: KDJ(随机指标), BIAS(乖离率), RSI(强弱指标)、BOLL</li></ul><hr><p>MACD:<br>实证做法：当日收盘后，MACD 指标为正，即 DIF 上穿 DEA 时，以当日收盘价买入并持有。反之卖出空仓。<br>实证结果：从总体上看，MACD 指标对于各指数收益率的优化是有效的，但回撤偏大。可优化的空间很大。</p><p>KDJ：<br>实证做法：以当日收盘价计算，K 上穿 D 即 KD 指标呈现多头排列时，以当日收盘价买入并持有。反之卖出空仓。<br>实证结果：从各指数收益率看，KDJ 指标的这种 KD 指标多头的用法是无效的。回撤过大，造成总体收益不理想。验证了 KDJ 指标应与其它指标结合使用的说法。</p><p>RSI：<br>实证做法：以当日收盘价计算，短、中、长三个周期的RSI指标线呈现多头排列，买入持有；反之卖出空仓。<br>实证结果：从各指数收益率看，RSI 指标的这种用法有一定的有效性，也可以称为弱有效，只有中证500的总收益率超越了指数。回撤较 MACD 和 KDJ 幅度小，但回撤的持续周期仍然偏长。造成总体收益不理想。</p><p>BIAS:<br>实证做法：以当日收盘价计算，短、中周期的 BIAS 指标线呈现多头排列，以当日收盘价买入并持有；反之卖出空仓。<br>实证结果：从各指数收益率看，BIAS 指标的这种用法完全无效，累积收益亏损严重。回撤巨大，净值到统计周期末仍未创出新高。验证了BIAS指标应与其它指标，如移动平均线一并使用的说法。</p><p>BOLL：<br>实证做法：以当日收盘价计算，布林线中轨值大于上个交易日，布林线上轨的值大于上个交易日，以当日收盘价买入并持有。反之卖出空仓。<br>实证结果：从各指数收益率看，BOLL 指标的这种择时方法是明显有效的，收益率好于上述单指标择时收益率。回撤在 30% 左右，仍然不十分理想，有进一步优化的空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cgws.com/upload/20160530/201605301464570725914.pdf&quot;&gt;量化择时之技术分析指标择时初探——金融工程深度报告&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;技术分析进行择时回测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;趋势</summary>
      
    
    
    
    
    <category term="股票" scheme="https://wu3227834.github.io/tags/%E8%82%A1%E7%A5%A8/"/>
    
  </entry>
  
  <entry>
    <title>股票分析常用指标</title>
    <link href="https://wu3227834.github.io/2025/11/12/2025-11-12-gu-piao-fen-xi-chang-yong-zhi-biao/"/>
    <id>https://wu3227834.github.io/2025/11/12/2025-11-12-gu-piao-fen-xi-chang-yong-zhi-biao/</id>
    <published>2025-11-12T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.052Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.futunn.com/learn/detail-introduction-of-k-line-1172-1901400024">投资课程 &gt; 股票 &gt; 速学21个技术分析利器</a></p><p>MACD、KDJ、RSI、BIAS在量化中的实际效果：<a href="https://beefyheisenberg.github.io/52.Financing/F41b.%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E6%8C%87%E6%A0%87-%E9%87%8F%E5%8C%96%E5%9B%9E%E6%B5%8B/">技术分析指标-量化回测</a></p><h2 id="成交量"><a href="#成交量" class="headerlink" title="成交量"></a>成交量</h2><ul><li>放量（成交量增加）所表明的是买卖双方对目前的价格分歧特别大</li><li>缩量（成交量减少）所表明的是买卖双方对市场非常的一致，无论是一致的看涨也好还是看跌也罢，核心点是一致<ul><li>缩量上涨：有些股票拉升状态后呈现缩量上涨的格局，很多投资者并不认可这种走势，认为是上升乏力的表现，因为缺乏持续资金进场。事实上这种看法比较片面，缩量上涨虽然表明增量进场比较少，但也反过来说明卖盘不多。成交量缩小还能保持上升态势，说明主力不用多少资金就能拉升股价，实质就是浮筹比较少，即该股已经高度控盘，后市很可能有超强的表现</li><li>缩量下跌：如果在很低的价格位置，有可能形成底部；如果在价格高位出现，突然放量下跌后，继续缩量下跌，这样的股票比较危险，因为很有可能主力已经出货完毕，缩量下跌只是散户的行为</li></ul></li></ul><h2 id="换手率"><a href="#换手率" class="headerlink" title="换手率"></a>换手率</h2><center>换手率 = 单位时间成交量 / 总股数</center><ul><li>按时间参数的不同，在使用上又划分日换手率、周换手率</li><li>除新股外，大多数股票的换手率在 1%~25%</li><li>70% 的股票换手率低于 3%（分界线），过高的换手率也意味着风险（买卖方分歧大）</li><li>A 股散户多，所以 A 股平均换手率稳居世界前列，为券商共享巨量手续费</li></ul><h2 id="量比-amp-委比"><a href="#量比-amp-委比" class="headerlink" title="量比 &amp; 委比"></a>量比 &amp; 委比</h2><ul><li>量比：<strong>1分钟成交量/过去5日分钟平均交易量</strong>，大于 1 表示交易活跃</li><li>委比：<strong>委托买入量/委托卖出量</strong>，委比反应的是买:卖的意愿，但是委托是可以撤单的，所以可能不那么准确</li></ul><h2 id="总结：均线系统"><a href="#总结：均线系统" class="headerlink" title="总结：均线系统"></a>总结：均线系统</h2><p>常见的均线系统（MACD/MA/EMA/KDJ/DKX等…）的使用方法：</p><ul><li>均线排列：多头/空头排列、收敛/发散趋势</li><li>均线交叉：金叉、死叉</li><li>不同均线系统的背离情况</li></ul><p><strong>基于价格</strong>的均线系统（MACD/MA/EMA/KDJ/DKX等）都有滞后性的问题，如果增加短期的权重可以使其变灵敏，但灵敏的上限=K 线的变化，过于频繁发出信号，比较几种均线系统：</p><ul><li>MACD（12，26）：约等于“K 线上站 5MA”</li><li>DK 点：<ul><li>D 点 ≈ “K 线上站 5MA”</li><li>K 点 ≈ “D 线跌破 5MA”</li></ul></li><li>DKX：约等于双均线 MA（5，20），但加上了成交量</li><li>EMA（5，20）：MA 的平滑版本</li><li>20MA+60MA（ETF 之家提供的双均线策略）：明显滞后，能躲过一大部分大跌，但是由于滞后性也没机会吃到涨幅</li><li>KDJ：MACD 的神经质版本，频繁的写入信号，对于中长期没法用</li></ul><h2 id="MA（移动均线）"><a href="#MA（移动均线）" class="headerlink" title="MA（移动均线）"></a>MA（移动均线）</h2><p>移动平均线——MA（Moving Average）：<strong>当日 MA = 过去 N 天的收盘价求算术平均</strong>，类似一个 N 天的滑动窗口</p><h3 id="均线的用法"><a href="#均线的用法" class="headerlink" title="均线的用法"></a>均线的用法</h3><ul><li>股价上站/回踩均线：例如“K线上站5日均线”作为短期趋势</li><li>均线排列：<ul><li>多头排列：短期均线依次在长期均线上，例如从上向下依次为 5-10-20-40-120</li><li>空头排列：相反</li></ul></li><li>均线交叉：<ul><li>金叉：短期均线上穿长期均线</li><li>死叉：短期均线下穿长期均线</li></ul></li><li>均线收敛/发散：<ul><li>均线间的距离呈收敛 + 向上突破：当多条均线出现收敛（均线值接近）迹象时，表名市场成本趋于一致，此时是买入信号 =&gt; <a href="#GMMA%EF%BC%88%E9%A1%BE%E6%AF%94%E5%9D%87%E7%BA%BF%EF%BC%89">顾比均线</a></li></ul></li></ul><h3 id="均线的周期"><a href="#均线的周期" class="headerlink" title="均线的周期"></a>均线的周期</h3><table><thead><tr><th>均线</th><th>又称</th><th>功能</th></tr></thead><tbody><tr><td>5日均线</td><td>周线</td><td></td></tr><tr><td>20日均线</td><td>月线</td><td>短期趋势</td></tr><tr><td>60日均线</td><td>季线</td><td>中期趋势</td></tr><tr><td>120日均线</td><td>半年线</td><td>中长期趋势</td></tr><tr><td>250日均线</td><td>年线</td><td>长期趋势</td></tr><tr><td>120月均线</td><td>十年线</td><td>大经济周期中的超长趋势</td></tr></tbody></table><ul><li>一般以日线 <strong>MA5 + MA10</strong> 解析短期走势，以 <strong>MA30 + MA60</strong> 解析中期走势，以 <strong>MA120+MA250</strong> 解析中长期走势</li><li>年线、5 年线（月K，MA60）和 10 年线（月K，MA120）的支持性局部增强</li></ul><h3 id="不同周期-K-线的均值设置"><a href="#不同周期-K-线的均值设置" class="headerlink" title="不同周期 K 线的均值设置"></a>不同周期 K 线的均值设置</h3><ul><li>日 K：<ul><li>MA(5)：周线</li><li>MA(20)：月线</li><li>MA(60)：季线</li><li>MA(250)：年线</li></ul></li><li>周 K：「周一的开盘价，周五的收盘价」，有些月份是 4 根K线，有些月份则是 5 根<ul><li>MA(60)：年</li></ul></li><li>月 K：<ul><li>MA(12)：年</li><li>MA(60)：五年</li><li>MA(120)：十年</li></ul></li><li>15 分钟 K 线，4 根 K 线 = 1 小时，16 根 K 线 = 1 交易日（A 股每天交易市场 4 小时，港股 5.5 小时）这个级别的 K 线在东财上可以看到资金的（大户/小户）分时博弈<ul><li>MA(16)：天</li><li>MA(80)：周</li></ul></li></ul><hr><h2 id="MACD（平滑移动均线）"><a href="#MACD（平滑移动均线）" class="headerlink" title="MACD（平滑移动均线）"></a>MACD（平滑移动均线）</h2><p>指数平滑移动平均线（Moving Average Convergence / Divergence，缩写：MACD，港澳台称为指数平滑异同移动平均线）是利用快速移动平均线和慢速移动平均线，在一段上涨或下跌行情中两线之间的差距拉大，而在涨势或跌势趋缓时两线又相互接近或交叉的特征，通过双重平滑运算后研判买卖时机的方法。运用两条平均线相互背离，相互应征的交易法则：当 MACD 从负数转向正数，是买的信号。当 MACD 从正数转向负数，是卖的信号。当 MACD 以大角度变化，表示快的移动平均线和慢的移动平均线的差距非常迅速的拉开，代表了一个市场大趋势的转变。</p><p><img src="/img/2025-11-12-%E8%82%A1%E7%A5%A8%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E6%8C%87%E6%A0%87/image.jpg" alt="MACD"></p><ul><li>白色线（DIF）：**DIF = EMA(close, 12) - EMA(close, 26)**，EMA(close, n) 表示过去 n 日收盘价的指数移动平均<ul><li>EMA12：最近 12 日移动平均值 = <strong>前一日EMA12 × 11/13 + 今日收盘价 × 2/13</strong></li><li>EMA26：最近 26 日移动平均值 = <strong>前一日EMA26 × 25/27 + 今日收盘价 × 2/27</strong></li></ul></li><li>黄色线（DEA）：即再计算上面 DIF 的 9 日 EMA = <strong>前一日DEA × 8/10 + 今日DIF × 2/10</strong></li><li>红蓝色柱：即为 MACD 柱状图 = <strong>(DIF - DEA) × 2</strong>，正数为红，负数为绿</li><li>零轴：在零轴以上，意味着每天的 DIF 大于零（每天的 12EMA 一直大于 26EMA）</li></ul><p>MACD 使用 MEA（指数移动平均值）的计算方法，和另一种均线指标 EXPMA（指数平均线）还是有去别的，<del>前者“前一日”权重更大，后者“今日”权重更大</del>；</p><p>相比较移动均线（MA）和 MACD，二者都属于“针对过去股价”计算的均线，所有均线都用同样的问题——滞后性，但 MACD 为了弥补这一点，使用了 DIF 差值，DIF 可以认为是长/短周期均值的差，反应变化程度，（对于平滑的曲线，计划变化程度用切线角度，但是 K 线不是“平滑”曲线，故这里也就不用切线斜率，而是用差值，来反应变化的程度）。</p><p>所以 MACD 指标的核心就是快慢线的变化趋势，也即 DIF 相较 DIF 的均值（DEA）的变化趋势，如果仅靠观察两条线的敞口大小（收敛趋势 or 发散趋势）不是很直观，为了方便观察快慢线差值变化，MACD 还引入了<strong>红绿柱</strong>，用红蓝柱体更明显反应两条线之间的差值。</p><h3 id="MACD-基本用法"><a href="#MACD-基本用法" class="headerlink" title="MACD 基本用法"></a>MACD 基本用法</h3><ul><li>DIF 向上穿过 DEA 时，被称为“金叉”，这是一个买入信号</li><li>DIF 向下穿过 DEA 时，被称为“死叉”，这是一个卖出信号</li><li>处于高位且快慢线和 K 线的趋势出现背离 ··· 卖出</li></ul><p>参考：</p><ul><li><a href="https://www.zhihu.com/question/29954111/answer/2444898925">MACD指标的内在逻辑是什么？ - 知乎</a></li></ul><p>MACD 择时效果量化实测：</p><ul><li><a href="https://www.zhihu.com/question/36411902/answer/2384383208">MACD指标在量化策略实战中如何应用？- 知乎</a> // 结论很有意思</li></ul><hr><p><strong>为什么 MACD 的默认参数是 12、26、9（DIFF 参数设置是 12 日和 26 日收盘价的 EMA，DEA 是 9 日 DIFF 的 MEA）？</strong></p><ol><li>为什么是 12、26 ？<br>坊间对 “12” 和 “26” 的来历说法都较为一致。相传在 Gerald 发明 MACD 的上世纪 70 年代，漂亮国交易市场仍在 “996”，一周有 6 个交易日，于是 “12” 对应的是两周。每个月有 4 周，一周休息一天，那么 30-4=26，“26” 就是对应的一个月。<br>但是查了道琼斯工业指数和麦当劳的历史日 K 图，发现一周没有 6 根 Bar，说明至少在漂亮国股票交易市场并没有 “996”，觉得更可能是 Gerald 关注的交易品种一周是交易 6 天，类似于期货从周一上午交易到周六凌晨。</li><li>为什么是 9 ？<br>“9” 是每周交易日数目乘以概率密度系数后的结果，其中 1/sqrt(2π) 是标准正态分布的<strong>概率密度函数</strong>的系数：(1+1/sqrt(2π))∗6≈9</li></ol><h2 id="KDJ-随机指标"><a href="#KDJ-随机指标" class="headerlink" title="KDJ(随机指标)"></a>KDJ(随机指标)</h2><p>KDJ 指标的中文名称又叫<strong>随机指标</strong>，最早起源于期货市场，由乔治·莱恩（George Lane）首创。随机指标 KDJ 最早是以 KD 指标的形式出现，而KD指标是在威廉指标的基础上发展起来的。不过 KD 指标只判断股票的超买超卖的现象，在 KDJ 指标中则融合了移动平均线速度上的观念，形成比较准确的买卖信号依据。</p><p>在实践中，K 线与 D 线配合 J 线组成 KDJ 指标来使用。KDJ 指标在设计过程中主要是研究最高价、最低价和收盘价之间的关系，同时也融合了动量观念、强弱指标和移动平均线的一些优点。因此，能够比较迅速、快捷、直观地研判行情，被广泛用于股市地中短期趋势分析，是期货和股票市场上最常用的技术分析工具。</p><ul><li>RSV（未成熟随机值）的计算较复杂，忽略</li><li>K 值 = <strong>2/3 × 前一日K值 × 1/3 × 当日RSV</strong>，变化率介于 D、J 之间</li><li>D 值 = <strong>2/3 × 前一日D值 × 1/3 × 当日K值</strong>，D 值可以看作是比 K 更“平均化”的 RSV，变化率最低</li><li>J 值 = <strong>3 × 当日K值 - 2 × 当日D值</strong>，反映了 K 和 D 之间的差值，变化率最高</li></ul><p>KDJ 主要是用来利用价格波动的真实涨幅来反映价格走势的<strong>强弱和超买超卖</strong>现象，在价格尚未上升或下降之前发出买卖信号的一种技术工具。它在设计过程中主要研究最高价、最低价和收盘价之间的关系，同时也融合了动量观念、强弱指标和移动平均线的一些优点，因此，能够比较迅速、快捷、直观地研判行情。由于KDJ线本质上是一个随机波动的观念，故其对于掌握中短期行情走势比较准确。</p><h3 id="KDJ基本用法"><a href="#KDJ基本用法" class="headerlink" title="KDJ基本用法"></a>KDJ基本用法</h3><ul><li>K/D 指标的交叉类似快慢 MA，K 线向上突破 D 线时金叉，K 线从上方下穿 D 线时死叉</li><li>K/D/J 三个值都大于 80，进入超买（大部分人只愿意买，股价被推高）区域，后续下跌的可能性变大</li><li>K/D/J 三个值都小于 20，进入超卖（大部分人只愿意卖，股价被拉低）区域，后续反弹的可能性变大</li><li>KDJ在进入超买/超卖区域后，容易出现钝化（3条线变得纠缠）</li><li>KDJ 适用于短期买卖点，一般和长期 MACD 配合使用</li></ul><h2 id="RSI（强弱指标）"><a href="#RSI（强弱指标）" class="headerlink" title="RSI（强弱指标）"></a>RSI（强弱指标）</h2><p>相对强弱指标（Relative Strength Index），RSI 强弱指标是根据一定时期内上涨和下跌幅度之和的比率制作出的一种技术曲线。能够反映出市场在一定时期内的景气程度。是由威尔斯.威尔德（Welles Wilder）最早应用于期货买卖，后来人们发现在众多的图表技术分析中，强弱指标的理论和实践极其适合于股票市场的短线投资，于是被用于股票升跌的测量和分析中。</p><p>技术方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N 日 RSI = A /（A+B）× 100，其中：</span><br><span class="line"></span><br><span class="line">A：N 日内收盘涨幅之和</span><br><span class="line">B：N 日内收盘跌幅之和（取正值）</span><br><span class="line"></span><br><span class="line">N常用的周期有：6日 / 12日 / 24日</span><br></pre></td></tr></table></figure><p>由上面算式可知 RSI 指标的技术含义，即以向上的力量与向下的力量进行比较，若向上的力量较大，则计算出来的指标上升；若向下的力量较大，则指标下降，由此测算出市场走势的强弱。</p><h3 id="RSI基本用法"><a href="#RSI基本用法" class="headerlink" title="RSI基本用法"></a>RSI基本用法</h3><p>RSI 值范围在 0-100，”强”和”弱”以 50 作为分界线：</p><ul><li>RSI &gt; 50，表明市场进入强市，可以考虑买入</li><li>RSI &gt; 80，表明买入力量极强，可以进入<strong>超买区</strong>，后市回调的机会增加</li><li>RSI &lt; 50，表明市场进入弱市，可以考虑卖出</li><li>RSI &lt; 20，表明卖出力量极强，可以进入<strong>超卖区</strong>，后市反弹的机会增加</li></ul><p>具体使用时，三条不同周期的 RSI 类似多周期均线，“金叉”/“死叉”，多头排列/空头排列，敞口收敛/发散…也适用于多周期 RSI；</p><h2 id="BIAS（乖离率指标）"><a href="#BIAS（乖离率指标）" class="headerlink" title="BIAS（乖离率指标）"></a>BIAS（乖离率指标）</h2><p>BIAS 乖离率指标是测量股价偏离均线大小程度的指标。当股价偏离市场平均成本太大时，都有一个回归的过程，即所谓的“物极必反”。乖离率是指股价与平均移动线之间的偏离程度，通过百分比的形式来表示股价与平均移动线之间的差距。如果股价在均线之上，则为正值；如果股价在均线之下，则为负值。乖离率最早来源于葛兰维的平均线定律，它的理论基础主要从投资者心理角度来分析，当股价偏离市场平均成本太大时，都有一个回归的过程，即所谓的“物极必反”，因为均线可以代表平均持仓成本，利好利空的刺激，造成股价出现暴涨暴跌。</p><center>BIAS=(收盘价−收盘价的N日简单平均)/收盘价的N日简单平均∗100</center><p>BIAS 指标有三条指标线，N 的参数一般设置为 6 日、12 日、24 日，从 BIAS 的计算过程可以看出，其值 = 最近一天价格，相较过去 N 日均价的波动程度，由于只是简单的算术平均，没有归一化，导致绝对值上下限波动大，且回复性并不怎么好；</p><p>因为BIAS三条线也属于快慢线，所以均线的用法（多空排列、上穿下穿）也适用于BIAS，绝对值越大=波动越大；</p><p>实际对BIAS的应用，是均值回归。大盘指数的均值回复性比个股更好；</p><p>如果是振荡期，BIAS 三条线纠缠，绝对值也不大（=波动不大）；</p><p>但如果出现过大的波动（上涨/下跌），则反向做，即出现正值的大波动开始做空，出现负值的大波动开始做多；</p><h2 id="EMA（指数平均数）"><a href="#EMA（指数平均数）" class="headerlink" title="EMA（指数平均数）"></a>EMA（指数平均数）</h2><p>EXPMA 指标简称 EMA，中文名字指数平均数指标，一种趋向类指标，从统计学的观点来看，只有把移动平均线（MA）绘制在价格时间跨度的中点，才能够正确地反映价格的运动趋势，但这会使信号在时间上滞后，而EXPMA指标是对移动平均线的弥补，EXPMA指标由于其计算公式中着重考虑了价格当天（当期）行情的权重。EXPMA=（当日收盘价－上一日EXPMA）/N + 上一日EXPMA</p><h2 id="GMMA（顾比均线）"><a href="#GMMA（顾比均线）" class="headerlink" title="GMMA（顾比均线）"></a>GMMA（顾比均线）</h2><p>顾比均线： GMMA（Guppy Multiple Moving Average）—— 顾比复合移动平均线，简称顾比均线</p><ul><li>顾比均线由两组均线构成，分别是长期组（黄线部分）和短期组（蓝线部分）。</li><li>短期组 6 根均线，分别是 3、5、8、10、12 和 15 日（周、月）平均线；</li><li>长期组也是 6 根均线，分别是 30、35、40、45、50 和 60 日（周、月）平均线。</li></ul><p>顾比均线使用：短期均线组和长期均线组，分别反映了短线交易者和中长期投资者的行为，当这两组指标相互靠近的时候，说明投资者和投机者对于证券的价值有了共识，而当两组相互远离的时候，就说明对价值产生了分歧</p><p>从偏股混合基金指数2005年以来的月线图来看，</p><ul><li>在顾比均线短期组完全上穿长期组时买入，是偏右侧的买入时机；</li><li>在 K 线下穿长期和短期均线时，是偏左侧的买入时机</li></ul><p><img src="/img/2025-11-12-%E8%82%A1%E7%A5%A8%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E6%8C%87%E6%A0%87/image2.jpg" alt="GMMA"></p><h2 id="布林（BOLL）线"><a href="#布林（BOLL）线" class="headerlink" title="布林（BOLL）线"></a>布林（BOLL）线</h2><p>在所有的指标计算中，BOLL 指标的计算方法是最复杂的之一，其中引进了统计学中的标准差概念，涉及到中轨线（MB）、上轨线（UP）和下轨线（DN）的计算。</p><p>另外，和其他指标的计算一样，由于选用的计算周期的不同，BOLL 指标也包括日 BOLL 指标、周 BOLL 指标、月 BOLL 指标、年 BOLL 指标以及分钟 BOLL 指标等各种类型。</p><p>经常被用于股市研判的是日 BOLL 指标和周 BOLL 指标。虽然它们的计算时的取值有所不同，但基本的计算方法一样。</p><p>以日 BOLL 指标计算为例，其计算方法如下：</p><ul><li>中轨线 = N日的移动平均线 // 一般用20日MA</li><li>上轨线 = 中轨线＋两倍的标准差</li><li>下轨线 = 中轨线－两倍的标准差</li></ul><p>布林线的理论使用原则：1是均值回复，主要是 K 线穿过上/下轨时，可能出现反向走势；2 是排列，3 线敞口收敛/发散、3 线方向；</p><h3 id="BOLL指标使用规则"><a href="#BOLL指标使用规则" class="headerlink" title="BOLL指标使用规则"></a>BOLL指标使用规则</h3><p>（1）买卖信号：</p><ul><li>当股价 K 线带量向上突破布林线的上轨，并且 TRIX 指标也已经发出底位“金叉”时，说明股价即将进入一个中长期上升通道之中，这是 BOLL 指标发出的买入信号。</li><li>当布林线轨道很长一段时间的底位窄幅水平运动后，一旦股价K线带量向上突破布林线的上轨，同时原本狭窄的布林线通道突然开口向上时，说明股价即将脱离原来的水平运行通道、进入新的上升通道之中，这也是 BOLL 指标发出的买入信号。</li><li>当股价 K 线向下突破布林线的中轨，并且 TRIX 指标也在已经发出高位“死叉”时，说明股价即将进入一个中长期下降通道之中，这是 BOLL 指标发出的卖出信号。</li><li>当布林线轨道很长一段时间的高位窄幅水平运动后，一旦股价K线向下突破布林线的下轨，同时原本狭窄的布林线通道突然开口向下时，说明股价即将脱离原来的水平运行通道、进入新的下降通道之中，这也是BOLL指标发出的卖出信号。</li></ul><p>（2）持股持币信号：</p><ul><li>当布林线开口向上后，只要股价K线始终运行在布林线的中轨上方的时候，说明股价一直处在一个中长期上升轨道之中，这是 BOLL 指标发出的持股待涨信号，如果 TRIX 指标也是发出持股信号时，这种信号更加准确。</li><li>当布林线开口向下后，只要股价K线始终运行在布林线的中轨下方的时候，说明股价一直处在一个中长期下降轨道之中，这是 BOLL 指标发出的持币观望信号，如果 TRIX 指标也是发出持币信号时，这种信号更加准确。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.futunn.com/learn/detail-introduction-of-k-line-1172-1901400024&quot;&gt;投资课程 &amp;gt; 股票 &amp;gt; 速学21个技术分析利器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MACD、KDJ、RS</summary>
      
    
    
    
    
    <category term="股票" scheme="https://wu3227834.github.io/tags/%E8%82%A1%E7%A5%A8/"/>
    
  </entry>
  
  <entry>
    <title>股票基础知识</title>
    <link href="https://wu3227834.github.io/2025/10/30/2025-10-30-gu-piao-ji-chu-zhi-shi/"/>
    <id>https://wu3227834.github.io/2025/10/30/2025-10-30-gu-piao-ji-chu-zhi-shi/</id>
    <published>2025-10-30T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="股票基础知识"><a href="#股票基础知识" class="headerlink" title="股票基础知识"></a>股票基础知识</h2><h3 id="T-1-交易制度"><a href="#T-1-交易制度" class="headerlink" title="T+1 交易制度"></a>T+1 交易制度</h3><p>股票买卖实行 T+1 制度（T 为交次日当天），即当天买的股票 T+1 次日才能卖出，当天卖的股票 T+1 才能取出现金，但可以用卖出股票的钱买其他股票或新股交款。</p><p>因此，当天买入的股票，可用数量不变，第二个交次日才有相应变化，当天买入的权证，买入成交数量立即加入可用数量。当天卖出的股票或权证，相应资金第二个交次日才是可取资金。</p><h3 id="股票交易费用"><a href="#股票交易费用" class="headerlink" title="股票交易费用"></a>股票交易费用</h3><h4 id="买进费用"><a href="#买进费用" class="headerlink" title="买进费用"></a>买进费用</h4><ol><li>佣金 0.2%~0.3%，根据你的证券公司决定，但是佣金最低收取标准是 5 元。比如你买了 1000 元股票，实际佣金应该是 3 元，但是不到 5 元都是按照 5 元收取</li><li>过户费（仅仅限于沪市）：每一千股收取 1 元，就是说你买卖一千股都要交 1 元</li><li>通讯费：上海、深圳本地交易收取 1 元，其他地区收取 5 元</li></ol><h4 id="卖出费用"><a href="#卖出费用" class="headerlink" title="卖出费用"></a>卖出费用</h4><ol><li>印花税 0.1%（政府会根据经济情况调节）</li><li>佣金 0.2%~0.3%，根据你的证券公司决定，但是佣金最低收取标准是 5 元。比如你卖出 1000 元股票，实际佣金应该是 3 元，但是不到 5 元都是按照 5 元收取</li><li>过户费（仅仅限于沪市）：每一千股收取 1 元，就是说你买卖一千股都要交 1 元</li></ol><h3 id="股票交易费用详情介绍"><a href="#股票交易费用详情介绍" class="headerlink" title="股票交易费用详情介绍"></a>股票交易费用详情介绍</h3><p>股票交易费用是指投资者在委托买卖证券时应支付的各种税收和费用的总和,通常包括印花税、佣金、过户费、其他费用等几个方面的内容。</p><p>​1. 印花税。印花税是根据国家税法规定,在股票(包括Ａ股和Ｂ股)成交后对出让方按照规定的税率单边征收的税金。印花税的缴纳是由证券经营机构在同投资者交割中代为扣收,然后在证券经营机构同证券交易所或登记结算机构的清算交割中集中结算,最后由登记结算机构统一向征税机关缴纳。其收费标准是按Ａ股成交金额的1‰计收,基金、债券等均无此项费用。<br>2. ​佣金。佣金是指投资者在委托买卖证券成交之后按成交金额的一定比例支付给券商的费用。此项费用一般由券商的经纪佣金、证券交易所交易经手费及管理机构的监管费等构成。<br>3. 过户费。过户费是指投资者委托买卖的股票、基金成交后买卖双方为变更股权登记所支付的费用。这笔收入属于证券登记清算机构的收入,由证券经营机构在同投资者清算交割时代为扣收。过户费的收费标准为：上海证券交易所Ａ股、基金交易的过户费为成交面额的 0.1 % ,起点 1 元；深圳证券交易所无过户费。</p><h2 id="K-线"><a href="#K-线" class="headerlink" title="K 线"></a>K 线</h2><h3 id="K-线产生的历史背景"><a href="#K-线产生的历史背景" class="headerlink" title="K 线产生的历史背景"></a>K 线产生的历史背景</h3><p>K 线又称为蜡烛线，也叫阴阳烛，据说起源于十八世次日本德川幕府时代的米市，当时的米商为了直观的观察米价的变动情况，编织出这种图线，后来被技术派人士引用到证券市场，成为股票分析的一种理论。而现代化 K 线是以柱状图、杠杆图、条形图、锚形图演进而成，其最大的特点就是客观的把握股价起伏，对行情动态一目了然。</p><h3 id="K-线的基础知识"><a href="#K-线的基础知识" class="headerlink" title="K 线的基础知识"></a>K 线的基础知识</h3><p>K 线是由开盘价、最高价、最低价、收盘价所组成，也是记录买方和卖方实战的过程；如果收盘价高于开盘价是以“实体红线”表示，收盘价低于开盘价则以“实体绿线”表示，最高价及最低价则以“影线”表示，高价拉升则留上影线，低价拉回则留下影线，因此这种多空实战的记录，就是用来预测未来是多头还是空头的一种指标。K 线是技术分析的基本工具，因此学习 K 线的时候，首先必须了解它的画法。</p><h4 id="K-线的画法"><a href="#K-线的画法" class="headerlink" title="K 线的画法"></a>K 线的画法</h4><p>K 线的画法：K 线又称阴阳线，是将每天的开盘价与收盘价画成直立的方块，若当天最高价大于收盘价或开盘价，则在方块上方加画一直线称为上影线，而当天之最低价弱小于开盘价或收盘价，则在方块下方加画一直线称为下影线。阳线方块多以红色表示，代表当天收红盘，阴线之方块会以绿色表示，当天则收绿盘。</p><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image.jpg" alt="K 线的画法"></p><p>K 线适用于任何时间架构，把每天的开盘价、最高价、最低价与收盘价每天股价表示出来就叫次日线。把每周的开盘价、最高价、最低价与收盘价等表示出来的叫周线，而把一个月或一年的开盘价最高价、最低价、收盘价表示出来就叫月线或年线。</p><h4 id="K-线的主要形状"><a href="#K-线的主要形状" class="headerlink" title="K 线的主要形状"></a>K 线的主要形状</h4><p>1）光头阳线和光头阴线；光脚阳线和光脚阴线；光头光脚阳线和光头光脚阴线</p><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image2.jpg" alt="K 线种类 1"></p><p>2）十字型；T 字型和倒 T 字型；一字型</p><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image3.jpg" alt="K 线种类 2"></p><h4 id="单根-K-线的含义"><a href="#单根-K-线的含义" class="headerlink" title="单根 K 线的含义"></a>单根 K 线的含义</h4><p>应用单根 K 线研判行情，主要从实体的长短、阴阳，上下影线的长短以及实体与上下影线长短之间的关系等几个方面进行。</p><p>（1）大阳线实体和大阴线实体</p><table>  <tr>    <td>      <img src="/img/2025-10-30-了解A股/image4.jpg" alt="大阳线实体" height="100" width="50">    </td>    <td>      <p>长红线或大阳线，表示强烈涨升，气势如虹。若出现跌势刚反转上涨时，代表空方失守，多方将获胜。</p>    </td>  </tr>    <tr>    <td>      <img src="/img/2025-10-30-了解A股/image5.jpg" alt="大阴线实体" height="100" width="50">    </td>    <td>      <p>长绿线或大阴线，表示空方极为强势。在上涨一段时间后出现长绿线，多方将告失守，通常将陷入盘跌或直转急下。在跌势时期出现长阴线，通常会加深盘势的弱势，需防股价暴跌。</p>    </td>  </tr></table><p>（2）有上下影线的阳线和阴线</p><table>  <tr>    <td>      <img src="/img/2025-10-30-了解A股/image6.jpg" alt="上下影线的阳线" height="100" width="50">    </td>    <td>      <p>大多发生在多空激战，多方仍胜于空方。如在大涨后出现，未来可能下跌；如在大跌后出现，未来可能出现反弹。若上影线长与下影线，则空方出现顽强抵抗，但多方仍略胜一筹：而上影线短于下    影线，则空方无力抵抗，多方胜利。当长上下影线小红实体K线时，多头稍站上风，但欲振乏力，未来可能下跌。当短上下影线小红实体K线时，则陷入窄幅震荡盘整</p>    </td>  </tr>    <tr>    <td>      <img src="/img/2025-10-30-了解A股/image7.jpg" alt="上下影线的阴线" height="100" width="50">    </td>    <td>      <p>大多发生在多空激战，空方仍胜于多方。如在大跌后出现，未来可能反弹；如在大涨后出现，未来可能出现盘跌格局。若下影线长与上影线，则多方出现顽强抵抗，但空方仍略胜一筹：而下影线短    于上影线，则多方无力抵抗，空方胜利。当长上下影线小绿实体K线时，空头稍站上风，未来可能下跌。当短上下影线小绿实体K线时，则陷入窄幅震荡盘整</p>    </td>  </tr></table><p>（3）有上影线的光脚阳线和阴线</p><table>  <tr>    <td>      <img src="/img/2025-10-30-了解A股/image8.jpg" alt="有上影线的光脚阳线" height="100" width="50">    </td>    <td>      <p>多头格局，但上涨卖压沉重，未来可能下跌。若在上涨末段出现，宜注意是否留下一根长长的上影线，是发出反转的信号</p>    </td>  </tr>    <tr>    <td>      <img src="/img/2025-10-30-了解A股/image9.jpg" alt="有上影线的光脚阴线" height="100" width="50">    </td>    <td>      <p>空方强势，上涨卖压沉重，未来可能下跌。若在上涨末段出现，是要反转下跌的信号</p>    </td>  </tr></table><p>（4）有下影线的光头阳线和阴线</p><table>  <tr>    <td>      <img src="/img/2025-10-30-了解A股/image10.jpg" alt="有上影线的光脚阳线" height="100" width="50">    </td>    <td>      <p>多头转强，买方站上风，下档买盘强劲。如在整理盘或长期跌势后，出现留下影线的红 K 线，可能为上涨之前兆，而下影线越长，则反弹力道越强</p>    </td>  </tr>    <tr>    <td>      <img src="/img/2025-10-30-了解A股/image11.jpg" alt="有上影线的光脚阴线" height="100" width="50">    </td>    <td>      <p>空方站上风，但下档有买盘支撑。如在跌势盘，出现留下影线的绿 K 线，可能为反弹前兆，而下影线越长，则反弹力道越强。在上涨高档出现，有可能转为盘整或下跌，宜密切注意后势发展</p>    </td>  </tr></table><p>（5）十字星</p><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image12.jpg" alt="十字星"></p><p>多空势均力敌，通常为反转或盘整的前兆。如果上下影线影线长，表示多空双方对抗激烈，未来可能会有变化，如果上下影线短表示未来可能陷入盘整。若出现在近期波段的高点，则多方力量减弱，股价有可能下跌。十字线出现在近期波段的低点，则空方力量转弱，股价有上涨的可能。当出现在盘整时，多空双方则必须再较量，才能分出高下，应密切注意后势发展。</p><p>（6）T 字线</p><table>  <tr>    <td>      <img src="/img/2025-10-30-了解A股/image13.jpg" alt="T 字线" height="100" width="50">    </td>    <td>      <p>T 字型，虽下档有卖压，但开盘价以下买盘积极，次日若卖方不强，则股价有可能反转向上。在连涨次日后出现，多方出现疲态，可能开始转弱;但在暴涨的格局中出现，则有可能继续往上攻坚。在跌势的盘局中出现，则可能是反转的信号，但应特别注意盘势是否已经止跌向上，还是下跌波中的小反弹。如果下影线越长，代表虽卖压强，但买盘更强，属多方胜利</p>    </td>  </tr></table><p>（7）⊥ 字线</p><table>  <tr>    <td>      <img src="/img/2025-10-30-了解A股/image14.jpg" alt="⊥ 字线" height="100" width="50">    </td>    <td>      <p>买气虽强，但上档压力更沉重，若次日买方不强，则股价有可能反转向下。在连续上涨中发生，则有可能开始转弱，所留上影线越长，则卖压越沉重。在连续下跌中出现，应特别注意次日所产生的变化，否则还是有可能继续下跌</p>    </td>  </tr></table><p>（8）- 字线</p><p>属于非常极端型，不是多头最强势、空头最强势就是极度冷门股。开盘跳空涨停板一价到收盘。开盘跳空跌停板一价到收盘。非常冷门的股票，一整天只在同一个价位成交一两笔股价。停牌。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><table>  <tr>    <td>      <img src="/img/2025-10-30-了解A股/image15.jpg" alt="⊥ 字线" height="200" width="200">    </td>    <td>      <p>红 K 线并不代表今天的股票一定是涨的，也有可能开在低盘，而收盘却在平盘以下的红Ｋ线，以Ｋ线的原理来说红 K 线所代表的意义是在整个涨升的气势，而不是涨跌，这是很多人所误解的</p>    </td>  </tr></table><h2 id="K-线组合的实战用法"><a href="#K-线组合的实战用法" class="headerlink" title="K 线组合的实战用法"></a>K 线组合的实战用法</h2><p>对于两根 K 线的组合来讲，第二天的 K 线是进行行情判断的关键。简单来说，第二天我空双方争斗的区域越高，越有利于上涨；越低就越有利于下跌。也就是说从区域 1 到区域 5 是多方力量减少、空方力量增加的过程。</p><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image16.jpg" alt="两根 K 线的组合"></p><h3 id="底部形态"><a href="#底部形态" class="headerlink" title="底部形态"></a>底部形态</h3><h4 id="早晨之星"><a href="#早晨之星" class="headerlink" title="早晨之星"></a>早晨之星</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image17.jpg" alt="早晨之星"></p><p>形态特征：</p><ol><li>第一天的实体阴阳线与趋势方向一致，为大阴线</li><li>第二天的小实体星形线与第一天有缺口，小实体的阴阳并不重要</li><li>第三天的 K 线的阴阳与第一天 K 线的阴阳相反，为大阳线</li></ol><p>技术含义：</p><p>股价在跌至新低（或前期成交密集区）时，往往会收到一根中阴线或大阴线，看似大势不妙，但第二天股价只是小幅跳空下行。收盘时收出一实体部分较短，带有上下影线的小阳线或小阴线或十字星，形成星体部分。而第三天股价就在平开或微微开高后，一路上行，最终收一中阳线（或大阳线），企稳待涨信号正式发出</p><p>确认原则及注意事项：</p><ol><li>早晨之星出现在下降趋势之后，才具有看涨的意义</li><li>如果早晨之星出现后，次日股票向上跳空开盘或是在较高的价位上拉出一根放量阳线，则其转势向上的信号就越强</li><li>早晨之星是次要的底部反转信号，因此一旦其出现后，等待次日的验证信号就显得十分重要。而设定止损位是我们必要的选择，对这种 K 线形态而言，出现早晨之星状态那一天的最低价，往往就是一个很好的止损位，一旦股票跌破该价位，则说明下跌抵抗失败，投资者应该及时止损出局</li></ol><h4 id="刺穿底部"><a href="#刺穿底部" class="headerlink" title="刺穿底部"></a>刺穿底部</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image18.jpg" alt="刺穿底部"></p><p>形状特征：</p><ol><li>第一天是继续反映下降趋势的长阴线实体</li><li>第二天是阳线实体，开盘价低于前一天的阳线实体</li><li>阳线的收盘价在第一天的实体中上部</li></ol><p>技术含义：</p><p>穿刺线形成于下降趋势中，第一天的长阴线保持了下降的含义。第二天的跳空低开进一步加强下降的含义。然而市场开始反弹，摈弃收盘收在前一天大阴线实体的中点之上。阳线穿入阴线的幅度越大，越像是反转形态。</p><p>确认原则及注意事项：</p><ol><li>对于该形态第二根阳线插入前面阴线的实体部分越长，其转势的可靠程度就越高。一般来说，一半以上才有分析意义</li><li>判别“曙光初现”形态可靠性的一个重要依据就是成交量。通常而言，成交量若不能放大到一个足够的数量级，是不能放大到一个足够的数量级，是不能轻言反转的</li><li>投资者对股价在第一次探底中出现的“曙光初现”形态，要保持一分警惕（可能会骗钱），而在二次探底中出现的“曙光初现”形态，其可靠性相对较高</li><li>以阳线的最低点作为止损点，防止庄家的骗钱</li></ol><h4 id="底部的“穿头破脚”"><a href="#底部的“穿头破脚”" class="headerlink" title="底部的“穿头破脚”"></a>底部的“穿头破脚”</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image19.jpg" alt="底部的“穿头破脚”"></p><p>形状特征：</p><ol><li>下跌趋势中</li><li>第二天的实体必须包含前一天的实体</li><li>第二根实体的颜色与第一根的颜色相反</li></ol><p>市场含义：</p><p>牛市包含形处在下跌趋势中，只有小成交量配合和小阳线实体发生。第二天，以新低开盘，然后是迅速的卖出狂潮并伴随大的成交量。收盘比前一天的开盘更高。下跌的趋势已经结束。如果第三天的价格仍然保持在较高的位置，那么，下跌趋势将反转。</p><p>确认原则及注意事项：</p><ol><li>第二根阳线的收盘价越低，见第回升的可能性越大</li><li>第二根阳线在开盘阶段大幅低于前期低点，然后反弹上涨，股价见底上攻的可能性大增</li><li>第二根阳线开盘时的初段的成交量越大，表示中了空头陷阱埋伏的投资者越多，转势的可能性也越大</li></ol><p>但是在实战运用过程中需注意：</p><ol><li>这种组合必须在明显的上升或下跌趋势中出现，才有研判的意义</li><li>这种组合有时会被庄家当成震仓清盘的工具。识别图形陷阱可以从三个方面入手：首先要看股价所处的位置，其次要看价量配合情况，最后看重心的变化情况</li></ol><h4 id="T字型（锤型）底部"><a href="#T字型（锤型）底部" class="headerlink" title="T字型（锤型）底部"></a>T字型（锤型）底部</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image20.jpg" alt="T字型底部"></p><p>形态特征：</p><ol><li>小实体在交易区域内的上面</li><li>下影线的长度应该比实体的长度长的多，一般要求是实体长度的 2-3 倍</li><li>上影线非常短甚至没有</li><li>小实体的阴阳并不重要</li><li>锤型线处在下降趋势中</li></ol><p>技术含义：</p><p>锤型线处在下降趋势中。当天的疯狂卖出被有效遏制，以较高价收盘。此时，投资者担心踏空。如收盘价高于开盘价，产生一根阳线，情况甚至更有利于上升。第二天较高的开盘价和更高的收盘价将使捶形线的牛市含义得到确认。</p><p>确认原则及注意事项：</p><ol><li>如果锤头线的实体部分与前一根 K 线之间出现跳空，则反正意义较浓</li><li>通常在出现锤头线时，要伴随底部放量，放量越明显，转势信号越强烈</li><li>由于捶形线是次要的底部反转信号，因此一旦其出现后，等待次日的验证信号就显得十分重要。而设定止损位是我们必要的选择，对这种 K 形线而言，出现锤头形态那一天的最低价，往往就是一个很好的止损位，一旦股价跌破该价位，则说明下跌抵抗失败，投资者应该及时止损出局</li></ol><h4 id="倒T字型（倒锤型）底部"><a href="#倒T字型（倒锤型）底部" class="headerlink" title="倒T字型（倒锤型）底部"></a>倒T字型（倒锤型）底部</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image21.jpg" alt="倒T字型底部"></p><p>形态特征：</p><ol><li>小实体在价格区域的较低部分形成</li><li>不要求有缺口，但要在一个明显的下降趋势之后</li><li>上影线的长度一般比实体的长度长 2 倍以上</li><li>下影线短到可以认为没有</li></ol><p>技术含义：</p><p>对于倒锤线，当市场以跳空向下开盘时，已经有了下降趋势。当天的上冲失败，市场以较低的价位收盘。这种形态决定趋势反转是成功还是失败，第二天的开盘是判断的标准。如果第二天的开盘高于倒锤线实体，潜在的趋势反转将引起空头的恐慌，这将支持股价进一步上扬</p><p>确认原则及注意事项：</p><ol><li>倒锤头出现在下降趋势之后，才具有看涨的意义</li><li>如果倒锤头出现后，次日股价向上跳空开盘或是在较高的价位上拉出一根放量阳线，则其转势而上的信号就越强</li><li>倒锤头是次要的底部反转信号，因此一旦其出现后，等待次日的验证信号就显得十分重要。并且应当把出现倒锤形态那一天的最低价设定止损位，一旦股价跌破该价位，则说明下跌抵抗失败，投资者应及时止损出局</li></ol><h3 id="顶部形态"><a href="#顶部形态" class="headerlink" title="顶部形态"></a>顶部形态</h3><p>多为股价上涨一段时间后形成的 K 线组合形态，多方力量已成消耗殆尽，而多空积蓄力量开始打压。</p><h4 id="黄昏之星"><a href="#黄昏之星" class="headerlink" title="黄昏之星"></a>黄昏之星</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image22.jpg" alt="黄昏之星"></p><p>形态特征：</p><ol><li>第一天的实体阴阳线与趋势方向一致，为大阳线</li><li>第二天的小实体星形线与第一天有缺口，小实体的阴阳并不重要</li><li>第三天的 K 线的阴阳与第一天 K 线的阴阳相反，为大阴线</li></ol><p>技术含义：</p><p>黄昏之星的情况与早晨之星正好相反，是上升趋势出现反转的组合形态。黄昏之星的开始是一根长阳线，它加强了原有的上升趋势。第二天价格向上跳空出现新高，交易发生在小的范围内，收盘同开盘接近持平。这个小实体显示了不确定性的开始。第三天价格跳空低开，收盘更低。显示反转已经发生。</p><p>确认原则：</p><ol><li>小星线的颜色并不重要，标准的形态中，小星线与前一根 K 线的实体之间存在着价格跳空</li><li>黄昏之星必须出现在上升趋势之后，或者出现在横向整理区域的顶部才有技术意义</li><li>通常而言，位于一个上涨趋势后的带量黄昏之星，往往会构成市场反转的顶部</li></ol><p>注意事项：</p><p>最后要提醒投资者注意的一点是，由于黄昏之星是一种次要的顶部反转信号，因此其出现图形陷阱的可能性较大。而判断黄昏之星是否真的形成顶部反转的依据有三点：</p><ol><li>黄昏之星成交量是否创近期天凉。如果是，则成为市场顶部的可能性较大。另外，如果黄昏之星前一根 K 线创天量，市场发生反转的可能性也很大</li><li>黄昏之星是否试图突破某个重要阻力位，而在重要阻力出现的黄昏之星通常是带量的，这一点应引起投资者的高度重视</li><li>黄昏之星与前一根 K 线实体之间是否有价格跳空也是判断流星线有效性的一个重要依据</li><li>一般来说，如果该形态出现反弹行情顶部，股价快速拉升之后，那么其可靠性较高；反之，若该形态出现在股价突破颈线之后，涨幅也相对较小时，则庄家洗盘的可能性较大</li><li>黄昏之星形成后股价重心的变动情况</li></ol><h4 id="乌云盖顶"><a href="#乌云盖顶" class="headerlink" title="乌云盖顶"></a>乌云盖顶</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image23.jpg" alt="乌云盖顶"></p><p>形态特征：</p><ol><li>第一天是继续指出上升趋势的长阳线</li><li>第二天是开盘高于第一天最高点的阴线</li><li>第二天的阴线的收盘低于第一天阳线实体的中部</li></ol><p>技术含义：</p><p>乌云盖顶的 K 线组合出现在上升趋势中。在典型的上升趋势中，出现了一根长阳线。第二天跳高开盘，收盘时价格下降到阳线实体的中间之下。明显的反转趋势已经发生。</p><p>确认原则及注意事项：</p><p>投资者在运用该形态进行分析时，应该注意以下几个方面：</p><ol><li>第二根 K 线（即阴线）的开盘价应高于第一根 K 线的最高价，但收盘时，股价大幅回落。同时，其阴线实体应深入到第一根 K 线实体部分的一般以下，否则分析意义不大。而且深入幅度越大，信号就越强烈</li><li>在分时图上，第二根 K 线在开市阶段曾出现向上突破明显的阻力位，然后掉头向下。这说明多头上攻乏力，见顶迹象开始显露。下例中的大显股份在02年7月22日的当天走势就是如此</li><li>第二根 K 线的成交量要明显放大，这说明市场主力高位派发的一员已很强烈。在上例中，我们可以看到：7月22日的当天走势就是如此</li><li>一般来说，如果该形态出现在反弹行情顶部，股价快速拉升之后，那么其可靠性较高；反之，若该形态出现在股价突破颈线之后，涨幅也相对较小时，则庄家洗盘的可能性较大</li></ol><h4 id="顶部的“穿透破角”"><a href="#顶部的“穿透破角”" class="headerlink" title="顶部的“穿透破角”"></a>顶部的“穿透破角”</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image24.jpg" alt="顶部的“穿透破角”"></p><p>形态特征：</p><ol><li>上升趋势中</li><li>第二天的实体必须完全包含前一天的实体</li><li>第二根实体的颜色与第一根的颜色相反</li></ol><p>市场含义：</p><p>熊市包含兴处在上升趋势中，只有小成交量配合和小阳线实体发生。第二天，以新高开盘，然后是迅速的卖出狂潮并伴随大的成交量。收盘比前一天的开盘价更低。上升的趋势已经被破坏。如果第三天的价格仍然保持在较低的位置，那么，上升趋势将反转。</p><p>确认原则及注意事项：</p><p>对于熊市包含形来说，确认原则：</p><ol><li>第二根阴线的开盘价越低，见顶回落的可能性越大</li><li>第二根阴线的开盘阶段大幅度超越前期高点，然后回头下跌，股价见顶回落的可能性大增</li><li>第二根阴线开盘时的初段的成交量越大，表示中了多头陷阱埋伏的投资者越多，转势的可能性也越大</li></ol><p>但在实战运用过程中需注意：</p><ol><li>这种组合必须在明显的上升或下跌趋势中出现，才有研判的意义</li><li>这种组合有时会被庄家当作震仓洗盘的工具。识别图形陷阱可以从三个方面入手：首先要看股价所处的位置，其次要看价量配合情况，最后看重心的变化情况</li></ol><h4 id="顶部“射击之星”"><a href="#顶部“射击之星”" class="headerlink" title="顶部“射击之星”"></a>顶部“射击之星”</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image25.jpg" alt="顶部“射击之星”"></p><p>形态特征：</p><ol><li>小实体在价格区域的较低部分形成</li><li>在上升趋势之后，以向上的价格跳空开盘</li><li>上影线的长度一般比实体的长度长 3 倍以上</li><li>下影线短到可以认为没有</li></ol><p>技术含义：</p><p>射击之星处在上升趋势中，市场跳空向上开盘，出现新高，最后收盘在当天的较低位置。第二天的跳空行为只能当成看跌的熊市信号。</p><p>确认原则：</p><ol><li>流星线的颜色并不重要，标准的形态中，流星线与前一根 K 线的实体之间存在着价格跳空</li><li>流星线必须出现在上升趋势之后，或者出现在横向整理区域的顶部才有技术意义</li><li>通常而言，位于一个上升趋势后的带量流星线，往往会构成市场反转的顶部</li></ol><p>注意事项：</p><p>射击之星处在上升趋势中，市场跳空向上开盘，出现新高，最后收盘在当天的较低位置。第二天的跳空行为只能当成看跌的熊市信号。</p><ol><li>流星线成交量是否创近期天量。如果是，则成为市场顶部的可能性较大。另外，如果流星线前一根 K 线创天量，市场发生反转的可能性也很大</li><li>流星线是否试图突破某个重要阻力位，而在重要阻力位出现的流星线通常是带量的，这一点应引起投资者的高度重视</li><li>流星线与前一根 K 线实体之间是否有价格跳空也是判断流星线有效性的一个重要依据</li><li>流星线形成后股价重心的变动情况</li></ol><p>总之，投资者在运用流星线来识别市场顶部时，一定要结合前后的 K 线来分析，此外成交量的作用也不能忽视，只有综合考虑这些因素，才能辨别出 K 线形态的真伪。</p><h4 id="顶部“吊顶”形态"><a href="#顶部“吊顶”形态" class="headerlink" title="顶部“吊顶”形态"></a>顶部“吊顶”形态</h4><p><img src="/img/2025-10-30-%E4%BA%86%E8%A7%A3A%E8%82%A1/image26.jpg" alt="顶部“吊顶”形态"></p><p>形态特征：</p><ol><li>上吊线处于上升趋势中</li><li>小实体在交易区域的上面</li><li>下影线的长度应该比实体的长度长的多，一般要求实体长度的 2-3 倍</li><li>上影线非常短甚至没有</li><li>小实体的阴阳并不重要</li></ol><p>技术含义：</p><p>上吊线处在上升趋势中。当天的价格交易行为一定在低于开盘价的位置，之后反弹使收盘价几乎是在最高价的位置。上吊线中产生出来的上下影线显示了一个疯狂卖出是怎么开始的。如果市场第二天开盘较低，就有很多持有多头头寸等待卖出时机的参与者在一旁观望。如果小实体是阴线，并且第二天开盘较低，将使得上吊线的熊市含义得以确定。</p><p>确认原则：</p><ol><li>跳空缺口：若上吊线实体部分与前一根 K 线形成跳空缺口，则说明追高一族的成本高</li><li>第二根 K 线一般为长阴线：上吊线出现后的第二根 K 线一般为阴线，阴线的长度越长，新一轮跌势开始的概率就越大</li><li>上吊线出现时，若当时成交量萎缩，则要等待出现下一个确认信号（第二天是否是放量阴线）才能做出最后的判断</li></ol><p>注意事项：</p><p>上吊线也常常会出现在主力盘中震荡洗盘的时候，而判断顶部形态的上吊线和整理形态的上吊线通常可用以下两点进行区分：</p><ol><li>上吊线出现的位置。如果股价在高位出现上吊线形态（是否有出货空间），则形成顶部的可能性较大；相反，如果股价刚脱离底部，则其成为整理形态的可能性较大——洗盘</li><li>上吊线形成时的成交量。如果上吊线伴有巨大的成交量，尤其是出现近期天量的时候，投资者要特别警惕股价可能会出现单日反转???——但不绝对，重要的是判断筹码的流向。相反，如果上吊线形成时，成交量大幅萎缩，投资者应等待出现另一个确认信号，以免落入陷阱</li><li>上吊线形成后股价重心的变动情况</li></ol><h3 id="应用K线组合应注意的问题"><a href="#应用K线组合应注意的问题" class="headerlink" title="应用K线组合应注意的问题"></a>应用K线组合应注意的问题</h3><p>无论是一根 K 线，还是两根、三根以至更多根 K 线，都是对多空争斗作出的一个描述，由它们的组合得到的结论都是相对的，不是绝对的。对股票投资者而言，结论只是一个建议作用。</p><p>在应用时，有时会发现运用不同种类的组合会得到不同的结论。有时应用一种组合得到明天会下跌的结论，但是次日股价没有下跌，反而上涨。这是的一个重要原则是尽量使用根数多的 K 线组合的结论，并将新的 K 线加进来重新进行分析判断。一般来说，多根 K 线组合得到的结果不大容易与事实相反。</p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><p><a href="https://htmlpreview.github.io/?https://github.com/AdvancingStone/stock-learning/blob/master/html/3.K%E7%BA%BF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">K线基础知识</a></p>]]></content>
    
    
    <summary type="html">A股股票交易基础知识详解，涵盖T+1制度、K线画法、单根K线含义及经典底部顶部组合形态，适合初学者系统学习与实盘参考。</summary>
    
    
    
    
    <category term="股票" scheme="https://wu3227834.github.io/tags/%E8%82%A1%E7%A5%A8/"/>
    
  </entry>
  
  <entry>
    <title>Pentax MX 拆卸</title>
    <link href="https://wu3227834.github.io/2025/10/22/2025-10-22-pentax-mx-chai-xie/"/>
    <id>https://wu3227834.github.io/2025/10/22/2025-10-22-pentax-mx-chai-xie/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.052Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本人碎碎念：<br>网上的一些拆解帖子很多都不见了，留存一些<br>原文是繁体字，改成简体字了，原文链接：<a href="http://cypresslin.web.fc2.com/Memo/M-PentaxMX.html">Pentax MX Disassembly</a></p></blockquote><p>之前跟 PPT 板友收了一台有点瑕疵的 Pentax MX，本来目标只是那颗装在上面的 50/1.4（版友：买镜头送机身啦~）</p><p>所以机身就没怎么去管他，后来觉得那个故障的机身就这样丢在那儿当装饰又有点可惜，但送修好像又不是很划算……</p><p>上网找了一下，还真给我找到维修手册跟拆解过程的网页。于是乎就跳了个比较有空的日志来拆，没想到这一拆就拆了好几次……</p><p>这台 MX 有两个问题：</p><ol><li>取景框里面的 Tv indicator 不会动</li><li>当使用低速快门时反光镜不会下来（mirror stuck up），网络上看了一下这个问题好像经常出现，而且不是只有 Pentax MX 有这个问题。（后来情况还变成没过片时按下快门反光镜自己会升上来）原因之一可能是反光镜中那块海绵老化，变得黏黏的（sticky foam），另一个原因就是机械上的问题了，我遇到的情况就是机械问题</li></ol><p><strong>注意！以下过程不建议轻易尝试</strong>（我也没有练过XD），<strong>拆坏的话跟我没有任何关系哟~</strong></p><p>如果那台相机对你有特别含义的话，送修吧，值得的！接下来时保持着没修好就算了的想法动手的。</p><p>工具：（依据情况需要什么，基本上只用前三种就够了）<br>螺丝起子组、尖头钳之类的东西、美工刀、电烙铁、焊锡、尖嘴钳、斜口钳、三用电表</p><p>参考资料：</p><ul><li>MX 维修手册（关键字 Service Manual，Pentax 在网络上可以找到有一整套的手册）维修手册里面很细，有些小细节要看里面才知道</li><li>参考网页一：<a href="http://www.mypentax.com/PentaxMX.html">http://www.mypentax.com/PentaxMX.html</a> （网页挂了，可惜）</li><li>参考网页二：<a href="http://www1.plala.or.jp/tsoma/repeia_mx.html">http://www1.plala.or.jp/tsoma/repeia_mx.html</a> 里面有很完整的大部分解步骤</li><li>参考网页三：<a href="http://www.kyphoto.com/classics/sealreplacement.html">http://www.kyphoto.com/classics/sealreplacement.html</a> 里面有有关于遮光海绵的更换，有兴趣的话可以自己更换</li></ul><blockquote><p>本人碎碎念：<br>原博主推荐的参考网页都打不开了</p></blockquote><p>拆解时千万要注意：</p><ol><li>拆下来的零件小心不要搞掉，搞掉了基本上是买不到（我搞掉了一只螺丝……）</li><li>不要手痒碰到不需要碰的东西，可能会有很可怕的后果（我拉坏了一根弹簧……）</li></ol><p>要避免螺丝不见、搞混，最简单的方法就是拆下来之后锁回原来的孔位里，或用胶带固定。</p><ul><li>以下照片大多数都是组装时拍的，拆的时候没有拍几张，所以可能会出现照片不连续的情况</li><li>当初拆的时候不知道问题出在哪里，所以出于好奇就动手拆了一大堆，实际维修的话应该是没有必要拆到这么细</li><li>零件的名称可能不是很正确，有误的部分烦请指正</li></ul><h2 id="上盖部分"><a href="#上盖部分" class="headerlink" title="上盖部分"></a>上盖部分</h2><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image.jpg" alt="快门扳手"></p><p>要注意，这是个「左手螺丝（Left-handed screw）」，我拆他就是用照片中那个尖尖的工具来转。相机里面有不少左手螺丝（尤其是那些会逆时针寻转的零件），拆之前最好看看维修手册。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image2.jpg" alt="速度转盘"></p><p>速度转盘也是用一样的工具，不过因为他比较小，所以我搭配了一支断水的原子笔来转。维修手册上面是建议拆解时设定在 1/1000 ISO100。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image3.jpg" alt="胶片仓拨杆"></p><p>因为没有特殊工具，所以遇到这种环我是用一字起来开，小心不要手滑，不然可能会挂到机身让他掉漆，还有这是一般的螺丝，不要转错方向把他锁死就好。</p><blockquote><p>本人碎碎念：<br>拆卸工具，原博主年代久远，可以直接用井字扳手代替<br>有些 mx 的结构，速度转盘可以不用拆下来，这玩意不好组装，视情况而定</p></blockquote><h2 id="机内部分"><a href="#机内部分" class="headerlink" title="机内部分"></a>机内部分</h2><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image4.jpg" alt="计数器结构"></p><p>把四只螺丝拆掉并移除上盖后，注意红框中的那根弹簧不要掉了，他很容易脱落的，而且很细一支，小到掉到地上没有声音，万一掉了计数器就会出现问题。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image5.jpg" alt="计数器弹簧"></p><p>它长这样，建议是拿下来收好，不然就用一小段胶带把他固定在某个地方。外壳拆开之后建议拍照留存，这样可以看哪些东西要装哪儿。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image6.jpg" alt="胶片仓拨杆"></p><p>红框中的海绵老化了，搓一搓会有碎屑，既然拆了就清一下。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image7.jpg" alt="固定螺丝"></p><p>参考网页一跟维修手册，里面会建议你如果要继续拆，要先把电线解焊，记得要记录哪些电线接哪个点；或者是把所有固定电路的零件拆下来，这样就不用解焊了。</p><p>只是要很小心，我当初没解焊，结果不小心拉断了几个节点，最后还是乖乖拿出焊枪。</p><p>这总共有五个螺丝（见红框）：</p><ul><li>最左边那个是固定测试光表的 LED</li><li>比较靠近镜头的两个是固定五棱镜用的</li><li>靠近观景窗的两个是固定观景窗用的</li><li>蓝色框框的地方拆开时没有螺丝，是后来锁上去的</li></ul><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image8.jpg" alt="转盘螺丝"></p><p>为了把这边的电路写下来，先把这个可变电阻拆掉，这边是设定 ISO 值用的。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image9.jpg" alt="转盘螺丝"></p><p>再把先前提到的那些螺丝拆了，就可以进行下一步了！</p><h2 id="前盖部分"><a href="#前盖部分" class="headerlink" title="前盖部分"></a>前盖部分</h2><p>拆前盖时要注意，电路中有两条黄色的电线是连到前盖上的（跟镜头沟通光圈大小用）</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image10.jpg" alt="倒数计时器"></p><p>图中红框中的是倒数计时器的连焊，装的时候注意一下方向</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image11.jpg" alt="圈口下螺丝"></p><p>再来把这几个螺丝拆了（还有右边几颗固定电线、电路板的螺丝），就是把电路跟相机分离（只剩电线连着这样）</p><h2 id="五棱镜部分"><a href="#五棱镜部分" class="headerlink" title="五棱镜部分"></a>五棱镜部分</h2><p>先把电路放到一边，继续上面的部分</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image12.jpg" alt="固定五棱镜结构"></p><p>电路板跟取景器移开之后可以看到五棱镜（可以趁现在清理观景窗），红色框框的螺丝固定五棱镜，蓝色框框的固定取景器</p><p>移除后就可以把五棱镜拿下来</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image13.jpg" alt="五棱镜1"></p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image14.jpg" alt="五棱镜2"></p><p>有时候不是取景器脏，而是五棱镜脏，那也可以趁机清一清</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image15.jpg" alt="五棱镜3"></p><p>绿框中的那五个洞就是搭配 LED 灯牌显示的位子</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image16.jpg" alt="五棱镜LED指示牌"></p><p>移除五棱镜之后，有个金属片，并没有固定在上面；取走之后就可以直接拿到对焦屏（小心刮伤，或者从前面拆也可以，MX 本来的设计就是可以更换对焦屏的）。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image17.jpg" alt="对焦屏"></p><p>拿走對焦屏之後記得找個安全的地方放，它很容易被刮到。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image18.jpg" alt="对焦屏固定框螺丝"></p><p>接着把这两颗螺丝拆掉</p><h2 id="机底部分"><a href="#机底部分" class="headerlink" title="机底部分"></a>机底部分</h2><p>移除底板后……</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image19.jpg" alt="反光镜室固定螺丝"></p><p>把照片的两个螺丝也拆掉，这样就可以把反光镜室整个拆下来了。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image20.jpg" alt="反光镜室1"></p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image21.jpg" alt="反光镜室2"></p><h3 id="反光镜室底部"><a href="#反光镜室底部" class="headerlink" title="反光镜室底部"></a>反光镜室底部</h3><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image22.jpg" alt="底部螺丝"></p><p>这四颗螺丝固定电路用，要研究反光镜的话建议把他拆掉比较不碍事儿，稍微讲解一下运作机制：</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image23.jpg" alt="运作机制1"></p><p>当你波动片杆儿的时候，会有个零件去推动 A，当 A 遵循着箭头方向移动的时候，零件 B 也会遵循箭头方向移动，然后蓝色方框那边的缺口就会卡住零件 A （此时即可拍摄）。</p><p>來看一下側面：</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image24.jpg" alt="反光镜室——側面"></p><p>是长这样的，哪些零件会依箭头方向移动，后面会有照片可以对照。</p><h3 id="机低快门部分"><a href="#机低快门部分" class="headerlink" title="机低快门部分"></a>机低快门部分</h3><p>继续看底部：</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image25.jpg" alt="快门——反光镜连动1"></p><p>拨动过片杆的时候，会有根根子推动零件 A，而因为那个上面有片金属片的齿轮会旋转，也因此会又跟拨杆远离零件 B。</p><p>再来看看处于快门待状态时的机械构造</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image26.jpg" alt="快门——反光镜连动2"></p><p>按下快门，前一张中的齿轮会转回来，将一个拨杆拨动零件B，使得蓝框中的卡榫跳开，让零件 A 回到之前的状态，这动作会让反光镜降下来。齿轮动作如下图：</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image27.jpg" alt="快门——反光镜连动3"></p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image28.jpg" alt="快门——反光镜连动4"></p><p>按下快门时，快门连杆（前盖部分第一张，有个 T 字型底下有弹簧的那个）会向下移动，<br>拨动照片中左上角那个近乎 L 型的零件，让它朝红色箭头方向移动<br>这会使照片中其他零件朝箭头方向移动，使反光镜上升</p><p>值得注意的是伴随黄色箭头的那个零件：<br>反光镜成功上升时，它会拨动在相机上部的另一个零件，让快门帘可以动作<br>换言之，它是确保反光镜完全上升之后才启动快门帘动作</p><p>之后就会像这样（反光镜处于升起状态，此时若去拨前述的零件 B，则可让反光镜归位）</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image29.jpg" alt="快门——反光镜连动5"></p><p>画面正中间那个伸出一只脚抵住连动杆的那支弹簧控制的是反光镜的下降<br>所以说，底部零件跟快门的动作都要正确执行才会完成升反光镜-&gt;降反光镜的动作</p><p>我遇到的状况是当快门释放时，零件 B 无法正确的被拨杆推动，所以反光镜降不下来；要怎么知道是不是这样呢？</p><p>当你的相机出现这种状况时，拆掉底板，将那上面有金属片的齿轮往顺时钟方向转一点点（也就是释放快门时它会旋转的方向）；看看会不会推动连杆，拨动零件 B，让反光镜降下来。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image30.jpg" alt="快门——反光镜连动6"></p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image31.jpg" alt="快门——反光镜连动7"></p><p>或是直接拨动连杆，如上图</p><p>我遇到的状况就是上述这样，解决方法是调整齿轮的位置，先将快门速度转到 1/125</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image31.jpg" alt="快门——反光镜连动6"></p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image32.jpg" alt="快门——反光镜连动7"></p><p>这个零件就可以“浮起来”，这样就可以调整它的角度</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image33.jpg" alt="快门——反光镜连动8"></p><p>拨动连杆的齿轮，底下有个突起的金属，图中看到黑黑的那个就是</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image34.jpg" alt="快门——反光镜连动8"></p><p>秉持着研究的精神，把它拆了看看，快门速度要调到多少我忘了，也许是 1/125 吧 把红色框的螺丝拆掉，就可以把控制快门速度的组件拆掉</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image35.jpg" alt="快门速度结构1"></p><p>拆装时小心不要凹到那些零件，这可能会造成它作动不顺畅</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image36.jpg" alt="快门速度结构2"></p><p>这也是控制快门速度的零件，拆装的方式是从侧面转它的螺丝，以及它正上方有个固定环</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image37.jpg" alt="快门速度结构3"></p><p>这就是刚刚一直在提的那个齿轮，上面有个凸起，会推动照片中连杆突起来的部分 上片时，齿轮转动，连杆也就不会被继续推着，就可以让零件B正常的卡住零件A</p><p>装回去的时候要注意一下相对位置，确定位置之后再锁起来</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image38.jpg" alt="快门速度结构4"></p><p>如果弄错位置的话，可能会发生转到 B 快门却是 1/4 秒快门的情况</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image39.jpg" alt="快门速度结构5"></p><p>将齿轮装回去的时候，也要注意一下相对位置，如维修手册所示：</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image40.jpg" alt="快门速度结构6"></p><p>当速度拨盘拨到慢速快门时，上面那个有个洞的金属片会往下抵住那颗齿轮的金属片，让它延迟旋转（使反光镜被放下来的时间延后）直到它们不再抵在一起。</p><p>如果没有调整到正确的相对位置的话，可能会发生上面那个金属片抵不到下面那片的状况，也就是说，慢速快门会失效。</p><p>结论：<strong>对反光镜上去下不来这个部分的维修，就是照上文所述的测试方法测测看是不是齿轮突起有没有正确的推动连杆，如果是，先将快门速度调整到 1/125，手动去拨那只连杆，让它处于拨动零件 B 的状态，再将齿轮提起，转到正确位置（突起刚好抵住连杆）再放回去，若有需要的话再调整齿轮上的金属片的螺丝，将金属片做角度的调整。</strong></p><p>就在修理完这个部分之后，因为自己手痒拉坏了一支弹簧…就是图中这个…</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image41.jpg" alt="意外1"></p><p>造成它弹力有点减弱，反光镜上升的有点不干脆……高速快门时似乎还会稍微挡道曝光……</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image42.jpg" alt="意外2"></p><p>去了电子零件行买了支弹簧，拉力颇强，反光镜响亮的啪啦声让我有点害怕。 没想到当初装上去时，没有把弹簧两端用钳子夹一下，让它固定在位置上。于是就发生了全部装回去，结果弹簧松脱的惨剧…我也因此拆了好几次。 最后是换上另一支于弹簧店购买，弹力稍弱的弹簧，并将两端固定才搞定这问题。</p><h2 id="解决-Tv-indicator-不动"><a href="#解决-Tv-indicator-不动" class="headerlink" title="解决 Tv indicator 不动"></a>解决 Tv indicator 不动</h2><p>老实说这问题比较麻烦，而且 indicator 不动其实也不会有啥影响。 就只是没办法从观景窗里面看到现在的快门速度而已。而且要对这个部分做维修，需要拆到连反光镜室都拆掉，个人不大建议尝试。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image43.jpg" alt="步骤1"></p><p>在速度拨盘旁有个螺丝，松开有個卡槽可以卡连动用的线。 他的原理是当快门速度从1/1000往下，那个卡槽会开始转，转一个速度就转一点点。 于是就会收线，让另一侧放线，带动Tv indicator。</p><p>实际上原厂好像是用钢线，一端有环可以锁再卡槽中，一端有一片金属可以固定在另一侧。 一开始我是用一般缝衣服用的线… 结果它除了会掉棉絮、容易断之外，还有就是它弹性不错…</p><p>意思就是会发生转了快门拨盘转了四五格之后，indicator才开始动的状况。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image44.jpg" alt="原理"></p><p>线要走的路径是这样，钢线我也不知道去哪买（后来有拆滤网的钢丝来用，不过要修到好真的不容易…）</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image45.jpg" alt="原理2"></p><p>后挑了钓鱼线，够韧，也不会变形太多，而且不会掉棉絮。 画面左侧那边还比较好固定，右侧很麻烦（红框），没有螺丝可以锁，只有一个凹槽。 最后我是用打火机把它的尾端融化（融化时会变一小球）再用瞬间胶固定在那个零件上。 有个目的是让它不要突起来去抵到那个 Tv indicator。</p><p>结论： 很难搞＝ ＝</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image46.jpg" alt="可变电阻1"></p><p>装回去的时候，要注意电阻，对的设定才会让测光正常，像这个时调整 ISO 的可变电阻，从电阻 0 到大概 15K欧姆吧，忘了</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image47.jpg" alt="可变电阻2"></p><p>调整ISO用可变电阻的时候，其实它上面已经被做过了记号了（照片中红框的部分）那个金属片的洞上被点上了灰色。转到有记号那边就可以了，不放心的话可以拿电表测测，我记的好像是高电阻高ISO。</p><p>另外如果测光还是不准，可以调整绿框(粗调)跟蓝框(微调)中的电阻。测试的时候记得要把上盖遮住，上面进去的光也会影响结果。</p><p>我测试的方法是找另一台相机，对准光源均匀分布的亮面跟暗面测（ex白墙、地板），再将数值套用在这台上，调整到测光表亮绿灯。挑面的原因是因为这样就不用管他画面中测光的比例占多少。</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image48.jpg" alt="组装"></p><p>完工！</p><p>可以看到电线换了几条……</p><p><img src="/img/2025-10-22-Pentax_MX_Disassembly/image48.jpg" alt="测试"></p><p>测光表会亮，Tv indicator 也会动（虽然有点落后速度拨盘…）很好！</p><p>历时好几个工作天，终于搞定了。 很有趣，但是很花时间（不要乱拆基本上是可以很快搞定）。 不过测光准不准、会不会漏光这些还得实际拍出来才知道。</p><p>之后发现还有个问题，就是在使用高速快门时反光镜不会升起来，将上盖、前盖拆掉后发现好像也没啥问题，最后发现问题是在于上盖有点变形，会碰到第二帘的启动开关，导致第二帘会不正常击发，稍微把外壳矫正一下就搞定。</p><p>这台实际调校这么多次后拿来拍结果还颇令人满意。</p>]]></content>
    
    
    <summary type="html">本文记录了拆卸和维修 Pentax MX 电影相机的详细过程，涉及到快门、反光镜、Tv 指示器等问题的解决，提供了丰富的拆解步骤和技巧，适合有维修需求的摄影爱好者参考。</summary>
    
    
    
    
    <category term="Pentax" scheme="https://wu3227834.github.io/tags/Pentax/"/>
    
    <category term="Film camera" scheme="https://wu3227834.github.io/tags/Film-camera/"/>
    
  </entry>
  
  <entry>
    <title>RobotFramework教程 - 一个完整的例子</title>
    <link href="https://wu3227834.github.io/2025/10/22/2025-10-22-robotframework-jiao-cheng-yi-ge-wan-zheng-de-li-zi/"/>
    <id>https://wu3227834.github.io/2025/10/22/2025-10-22-robotframework-jiao-cheng-yi-ge-wan-zheng-de-li-zi/</id>
    <published>2025-10-22T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>用 <a href="https://code.google.com/archive/p/robotframework/">Robot Framework</a> 时有太多选择：</p><ul><li>使用 Python, Jython 还是 Java？</li><li>测试用例使用哪种输入格式（HTML, Text, BDD）？</li><li>要使用 <a href="http://www.lyyyuna.com/2016/01/07/robotframework-tutorial-overview/">Robot IDE(RIDE)</a> 吗？</li><li>如何在本地和持续集成环境中运行相同的测试？</li><li>如何运行所有的测试 (scripting, ANT, Maven)？</li></ul><p>那什么是最好的选择呢？我见过太多太多复杂化的方案。当然，在 Eclipse 中用 Maven 做 Robot 测试非常酷。而且用 BDD 风格编写测试肯定比使用 HTML 格式更灵活。</p><p>但有一件事真的很酷：简单！这不仅意味着设置和运行简单，还意味着更容易排错。在不同技术背景的团队合作间，这尤其重要。</p><p>接下来我们用一个完整的例子展示 Robot Framework 的使用方法。</p><h2 id="测试准备"><a href="#测试准备" class="headerlink" title="测试准备"></a>测试准备</h2><p>开始测试工程前，首先要想好被测试系统需要哪些测试库：</p><ul><li>是测 web 应用？那你可能需要 SeleniumLibrary 或者 Selenium2Library</li><li>是测数据库？Python 和 Java 都有相应的数据库测试库</li><li>是测试 SSH/SFTP？那你可能需要 SSHLibrary</li></ul><p>这个列表可以继续列下去，直到没有可用的测试库为止。这时候你就需要自己写啦（需要单独写一篇文章来阐述）。</p><p>为什么如此重要？测试库的选择直接影响到了是使用 Python, Jython 还是 Java 版的 Robot Framework。某些测试库只有 Java 的实现，如果要用纯 Python 来调用此库，则要求其实现 Remote Library 接口。因此，在测之前，需要好好想想。</p><blockquote><p>本文的代码在 <a href="https://github.com/wu3227834/Robot-Framework-Sample-Project">GitHub</a></p></blockquote><p>我们假设被测系统是一个利用 MySQL 数据库做存储的 web 应用（非常普遍）。浏览器使用 Python 的 SeleniumLibrary，数据库使用 Java 版本的 DatabaseLibrary，并且 <strong>Remote Library</strong> 接口。</p><h2 id="测试框架"><a href="#测试框架" class="headerlink" title="测试框架"></a>测试框架</h2><p>下图是测试框架的概览：</p><p><img src="/img/2025-10-22-RobotFramework%E6%95%99%E7%A8%8B_%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90/Sample_Overview1.jpg" alt="实例框架"></p><p>Selenium 需要 Selenium Server。这可以是 Robot Framework 所在的同一台机器，也可以是另一台可通过 TCP/IP 连接的服务器。Database Library Server 同理。虽然 DatabaseLibrary 可以本地使用，但那就意味着必须使用 Jython 来测试了。当然也可以在同一台机器上运行多个服务器。在一些正式的测试环境中，Robot Framework 和 CI (持续集成) 服务器经常部署在一起。然后，Selenium Server 通常跑在 Windows 服务器上，因为需要尽量模拟用户的使用场景。DatabaseLibrary Server 也可以部署在 CI 服务器上。</p><h2 id="测试实现和管理"><a href="#测试实现和管理" class="headerlink" title="测试实现和管理"></a>测试实现和管理</h2><p>最后让我们来实现该测试。不是每一个细节都会 cover，具体可以看 <a href="https://github.com/wu3227834/Robot-Framework-Sample-Project">GitHub</a>。</p><p>但在此之前，让我们再多做一些常规性考虑。比如用哪种格式来组织测试用例，是否使用 RIDE。而 RIDE 的使用又会直接影响到测试用例的格式。团队成员的技术背景，以及不同团队合作潜在的维护成本，对上述选择都有影响。</p><blockquote><p>Tips: 如果你已经使用 Excel 来管理则是用例，你可以直接复制粘贴进 RIDE。</p></blockquote><p>要我在本文的例子中选择，我会选择 HTML 格式和 RIDE，理由如下：</p><ul><li>RIDE 相比较于最初版本已经有了十足的进步，支持关键字自动补全，实现 Test Suites 和 Resource Files 也十分便利。</li><li>使用 RIDE 不用特意考虑 BDD 风格。但其中有一些我不喜欢的语法元素。而且，非技术团队成员编写和维护测试用例比较困难，因为现在机器还不能完全看懂人类语言。并且我认为，如果 BDD 是唯一或者最重要的需求，其他那些只支持 BDD 的测试框架才会有优势。</li><li>HTML 格式有着简单粗暴的优点。你可以直接在浏览器中可视化这些测试用例，尤其是那些熟悉 Excel 的非技术团队成员，看到这些会感到非常亲切。</li><li>HTML 格式也有着缺点，在版本管理时，HTML 会带来各种各样的问题。</li></ul><p>在实现测试时最重要的就是能够同时在本地和正式测试环境（CI 服务器）中运行。幸运的是，Robot Framework 支持向关键字传入参数，这样便能轻松切换环境：</p><ul><li>参数为 web 应用的 URL</li><li>Selenium 服务器的 IP 地址与端口</li><li>Database Library 所使用的 JDBC 连接字符串</li></ul><p>这些参数可以存储在变量文件中。这些变量文件可以在命令行中传入 Robot Framework。由于在本地测试和 CI 服务器中有不同启动脚本，这样便能实现不同环境的快速切换。</p><p>这意味着最好以如下的目录树来组织你的测试工程。</p><p><img src="/img/2025-10-22-RobotFramework%E6%95%99%E7%A8%8B_%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90/Sample_DirectoryStructure2.jpg" alt="目录树"></p><p>定义一个通用的目录树结构有助于工程的复用。上述的目录结构对我来说工作的不错，我很早就开始用啦。</p><blockquote><p>Tips: 所有路径都应该用相对路径。</p></blockquote><p>首先，我们将所有文件放于顶层文件 robot 中。然后将测试的实现和执行分开存放。在实现这边，testsuites 和 resource 分开存放。当然在一些大型工程中，还需要额外的子目录来更好的组织测试用例。更重要的是，最好用相对路径来引用这些文件。使用相对路径能够更好的在不同系统间移植，项目成员间通过版本管理系统也能更好地共享工程。</p><p>执行分支这边必须处理不同运行目标环境的问题，比如本地开发环境和正式的 CI 环境。若还有其他的部署环境需要在此目录中实现。scripts 目录用于保存执行用的脚本（robot 本身，Selenium Server, Database Library Remote Server），setting 目录放置特殊的变量文件。请注意，这些脚本写完之后就不应该频繁改动，对于配置文件亦是如此，除非执行环境有变化。</p><p>最后是 lib 文件夹，这取决于项目是否需要自己编写库文件。</p><h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><p>当执行测试时，我坚持使用 shell 脚本。易于理解，历史悠久且不出问题，在 CI 环境中使用方便。当然，我们很可能需要两套不同的启动脚本，因为本地测试通常在 Windows 电脑上，而正式的 CI 环境是一些 bash 或者 csh 脚本。但需注意，这些写了“写了一遍就忘记”的脚本，其实并不复杂。</p><p>在最初，我们需要三个脚本：</p><ol><li>robot 测试的启动脚本</li><li>Selenium Server 的启动脚本</li><li>Database Library Remote Server 的启动脚本</li></ol><p>我们也可以把三个脚本合并成一个，但为什么不这么做呢，因为其实后两个服务器只需启动一次，只有测试才需要重复执行。</p><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>首先我们需要在开发机器上安装 Robot Framework 和库。我们假设平台是 Windows，在 Unix 上安装也不会太复杂。</p><blockquote><p>Robot Framework 同时支持 2.x 和 3.x。</p></blockquote><p>安装如下的工具包：</p><ul><li>Python 2.7</li><li>Robot Framwork</li><li>wxPython</li><li>RIDE</li><li>Selenium2Library</li><li>Database Library Server</li></ul><p>按顺序安装，然后配置 PATH 目录为 “C:\Python27;C:\Python27\Scripts”。现在你可以用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pybot</span><br></pre></td></tr></table></figure><p>来运行 Robot Framework，用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ride</span><br></pre></td></tr></table></figure><p>来启动 RIDE。示意图如下，</p><p><img src="/img/2025-10-22-RobotFramework%E6%95%99%E7%A8%8B_%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90/RF_Ride.jpg" alt="RIDE"></p><p>Selenium Library 通常会包含一个对应的 Selenium Server JAR 包。为了独立使用不同目录下的 Selenium Server（比如其他小组成员安装的），你需要指定一个新的环境变量 RF_HOME，该变量指向 Python 的安装目录。该变量用于 selenium 服务器的本地启动脚本。</p><p>对于本地的 MySQL 数据库，其配置<a href="https://github.com/wu3227834/Robot-Framework-Sample-Project/blob/main/robot/implementation/testsuites/SampleTestsuite.html">在此</a>。然后安装 MySQL，创建测试 schema 和相应的用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C:\xampp\mysql\bin<span class="operator">&gt;</span>mysql <span class="operator">-</span>u root <span class="operator">-</span>p</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> database databaselibrarydemo;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">user</span> ‘dblib’@’localhost’ identified <span class="keyword">by</span> ‘dblib’;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> databaselibrarydemo.<span class="operator">*</span> <span class="keyword">to</span> ‘dblib’;</span><br></pre></td></tr></table></figure><p>在 robot/execution/local/scripts 是执行测试前所有需要运行的脚本。测试的实现在 robot/implementation/testsuites 目录中。测试用例可以直接用 RIDE 打开 implementation 目录，然后直接查看和修改。</p><p>为了运行测试，必须先启动 Selenium 服务器和 DBLibrary 服务器。然后运行 Testsuite。Windows 的批处理脚本在 robot\execution\local\scripts 目录中。因为都使用相对路径，一切应该按计划顺利运行。这里虽然在被测服务器上部署文件，但本地可以很容易地适配。</p><h2 id="结论和感想"><a href="#结论和感想" class="headerlink" title="结论和感想"></a>结论和感想</h2><p>我们已经看到，Robot Framework 提供了众多功能和可能，即使同一件事也能用不同方法来完成。所以，在正式开始测试前做些基本分析是很有意义的。</p><p><img src="/img/2025-10-22-RobotFramework%E6%95%99%E7%A8%8B_%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90/impression_ride1.jpg" alt="ride"></p><p>使用 RIDE 使得实现测试功能更简单，尤其是那些非技术团队。简单意味着好维护（不只是 Robot Framework 测试哦 :-)）。</p><p><img src="/img/2025-10-22-RobotFramework%E6%95%99%E7%A8%8B_%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90/impression_seleniumserver.jpg" alt="seleniumserver"></p><p>顺便说一下，我还没有明确指出过，Robot Framework 的 <strong>报表</strong> 和 logging 非常棒，在 troubleshooting 时非常有用。</p><p><img src="/img/2025-10-22-RobotFramework%E6%95%99%E7%A8%8B_%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90/impression_logfile.jpg" alt="logfile"></p><p>Robot Framework 在各种不同的测试库中提供大量的测试功能。一旦决定哪个测试库最好用时，大大加速了写测试的过程，提高了生产力。</p><p><img src="/img/2025-10-22-RobotFramework%E6%95%99%E7%A8%8B_%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BE%8B%E5%AD%90/impression_dbserver.jpg" alt="dbserver"></p><p>尤其是在许多不同工程工作时，一个通用的工程结构和工具非常有用。在一些公共的资源文件中也需要实现一些产品相关的关键字。</p><p>希望本文有助于你开始使用 Robot Framework，并有效地组织你的测试工程结构。当然，本例还有许多增强的地方，希望这是一个良好的起点。</p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><ul><li><a href="https://www.codecentric.de/en/knowledge-hub/blog/robot-framework-tutorial-a-complete-example">Robot Framework Tutorial – A complete example</a></li><li><a href="https://www.lyyyuna.com/2016/04/09/robotframework-tutorial-a-complete-example/">Robot Framework 教程 - 一个完整的例子（译）</a></li></ul>]]></content>
    
    
    <summary type="html">本文提供了一个完整的 Robot Framework 使用实例，介绍了如何设置测试框架、选择测试库、组织项目结构以及在本地与持续集成环境中运行测试的步骤，涵盖了 Selenium 和数据库测试的实际操作。</summary>
    
    
    
    
    <category term="Robot Framework" scheme="https://wu3227834.github.io/tags/Robot-Framework/"/>
    
    <category term="自动化框架" scheme="https://wu3227834.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>RobotFramework教程 - 概述</title>
    <link href="https://wu3227834.github.io/2025/10/17/2025-10-17-robotframework-jiao-cheng-gai-shu/"/>
    <id>https://wu3227834.github.io/2025/10/17/2025-10-17-robotframework-jiao-cheng-gai-shu/</id>
    <published>2025-10-17T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://code.google.com/p/robotframework/">Robot Framework</a> 是一个通用的自动化测试框架。这是本系列的第一篇文章，将会给出一个全面的概述。</p><p>请注意，第一篇文章几乎不会包含任何“真正实现方面的东西”，而是讲述一些高级别、抽象的概念，来为以后的文章打下坚实的基础。</p><h2 id="什么是自动化测试框架"><a href="#什么是自动化测试框架" class="headerlink" title="什么是自动化测试框架"></a>什么是自动化测试框架</h2><p>如果你已经有自动化测试的经验（例如，使用一些自动化测试工具），你可以直接跳过本小节。</p><p>现在，我想先问一个问题：什么是自动化测试？以及它为何不同于手动执行的测试？Michael Bolton 写的<a href="http://www.developsense.com/blog/2009/08/testing-vs-checking/">这篇文章</a>对这两个问题给出了一个非常好的答案：</p><blockquote><p>核对是机器干的事儿，测试则需要智慧</p></blockquote><p>然而请注意，当我们下面讨论自动化测试时，会同时使用测试和核对两个术语。</p><p>让我们来看看具体的例子，比如说一个保险公司的评级引擎。这个引擎会根据输入的某些参数（数字）来计算值。对于这样一个算法已知的系统而言，显然大量（自动化）核对时非常合适的。但检验这个算法正确与否，则需要一些思考。</p><p>假设我们有一个基于数据库的接口，和一个批处理程序：从一个表中取出数据，计算后与另一个表中的数据核对结果。</p><p>首先，我们需要测试脚本语言（取决于个人喜好，可以是 Shell，Perl，Java 等等）。此外我们还要准备一些基本的测试功能。然后访问数据库表，执行一个又一个脚本，测试结果最好以某种报告的形式返回。一旦脚本运行完毕，我们便可以开始核对检查工作。基本上，我们认为，一个典型的自动化测试框架应该提供上述的功能。</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/GenericFrameworkView.png" alt="GenericFrameworkView"></p><p>上图描述了一个非常基本的自动化测试框架。该框架有一个可执行测试的核心系统，可以输出一些可执行测试的核心系统，可以输出一些报告，并提供接口来插入特定的测试功能。这个插入接口实现会非常简单。</p><p>这就带来一个基本的问题：当我用这些测试框架时，改用什么编程语言来实现我的测试功能？稍后我们会详细回答这个问题，但现在我们可以说，<strong>Robot Framework</strong> 测试框架允许使用很多不同的语言。</p><p>在了解 <strong>Robot Framework</strong> 的具体体系之前，我们先讨论下 <strong>Robot Framework</strong> 的核心术语，即<strong>关键字驱动测试</strong>。</p><h2 id="什么是关键字驱动测试"><a href="#什么是关键字驱动测试" class="headerlink" title="什么是关键字驱动测试"></a>什么是关键字驱动测试</h2><p>每当我试图解释什么是关键字的时候，我总会把它称为函数或方法，其能够用于测试被测系统的一个方面。</p><p>真正强大的是，一个关键字可以有其关键字来定义。这就是为什么通常说：</p><ul><li><strong>高级别关键字</strong>：这些关键字实际上是在测试被测系统的某个业务逻辑</li><li><strong>低级别关键字</strong>：为了将高级关键字的实现保持在一个合适的“大小”，通常需要将所需的功能分解为几个低级关键字</li><li><strong>技术关键字</strong>：这些关键字提供了访问和测试系统的技术实现</li></ul><p>下面这张图用一个关键字例子描述了这三者的关系。</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/Keywords.png" alt="Keywords"></p><p>通常技术关键字可以由任何编程语言来实现（好吧，也不一定）。其他的关键字则是有已存在的关键字组合而成。即本文关注的是抽象的概念，我们还是来看一个具体的关键字定义：</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/KeywordGoogleSearch.png" alt="KeywordGoogleSearch"></p><p>这个例子表明， Google Search 这个关键字可以由 <a href="https://robotframework.org/SeleniumLibrary/SeleniumLibrary.html">Selenium Library 库</a> 中的关键字来创建。好消息是已经有大量预定义的关键字，它们的集合称为测试库。</p><p>好，让我们开始。。。</p><h2 id="承诺的概况"><a href="#承诺的概况" class="headerlink" title="承诺的概况"></a>承诺的概况</h2><p>最后开始我们的主题，<strong>Robot Framework</strong> 概览。安装 <strong>Robot Framework</strong> 时，一些标准测试库会随核心框架一起安装。</p><p>除了<a href="http://code.google.com/p/robotframework/wiki/TestLibraries">标准测试库</a>外，还有很多<a href="http://code.google.com/p/robotframework/wiki/TestLibraries#External_test_libraries">额外的外部测试库</a>。它们通常是社区由不同的目的贡献的。在写特定测试用例的时候，你完全可以混用不同测试库的所有关键字。这意味着，在测试一个 web 应用时，可以用 <strong>Selenium Library</strong> 来与 web 前端交互，用 <strong>Database Library</strong> 来检测数据库中数据的正确性。理想情况下，完全不需要编程，只需组合库中的关键字来构成高级别关键字。</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/Overview_3.png" alt="Overview_3"></p><p>Robot Framework 除了核心功能和测试库外，还提供一个 IDE（RIDE, Robot Integrated Development Environment），用户可以在此编写和组织自己的测试用例和关键字。请注意，这个 RIDE 不是用来写技术性关键字的。技术性关键字取决于你的开发环境，比如 Eclipse 来开发 Java 写的关键字。</p><p>上图中尚未包含<strong>资源文件</strong>。我们测试用例的集合称作<strong>测试套件</strong>，听起来很有道理。现在为<strong>测试套件</strong>添加新关键字也是可行的。但最好在外部的<strong>资源文件</strong>中定义关键字。</p><p>现在，我们在使用 Robot Framwwork 框架时，有三个重要的概念：</p><ul><li><strong>测试套件</strong>：这是测试用例（机器的核对工作）的容器。通常每个项目至少有一个测试套件。在大型工程中，需要根据功能来划分不同的测试套件。</li><li><strong>资源文件</strong>：为了让测试设计者的角度看，几乎总会定义高级别关键字。反过来说，通常会有自己的资源文件。特别是对产品开发或者一些长期项目而言，肯定能益于关键字，而且还能被其他项目组使用。</li><li><strong>测试库</strong>：通常不需要编写自己的技术性关键字，除非你在使用特定技术细节，你才需要自己实现一个新的测试库，不过这并不费时。</li></ul><p>需要强调的是，<strong>测试库</strong>中的关键字和<strong>资源文件</strong>中组合成的关键字，在使用时没有区别。</p><h2 id="自定义测试功能该用什么语言"><a href="#自定义测试功能该用什么语言" class="headerlink" title="自定义测试功能该用什么语言"></a>自定义测试功能该用什么语言</h2><p>Robot Framework 自身和其核心库都是由 Python 实现的。因此，如果熟悉 Python（或者打算熟悉），用其写自己的关键字是个好的选择。我一直认为 python 是很酷的语言，但如果 Robot Framework 局限于 Python，它不会这么成功。这就是为什么会有 Jython。有了 Jython 就可以在 Java 的虚拟机上运行 python 代码。这就使得我们能够用 Java 来编写测试库，甚至是任何编译成 Java Byte Code 的语言。</p><blockquote><p>在 .NET 系中，IronPython 和 Jython 是类似的</p></blockquote><p>这引出了以下的安全堆栈：</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/InstallationStacks.png" alt="InstallationStacks"></p><p>Robot Framework 历史上是上图最左边的安装堆栈（在没有 RIDE 的情况下）。早期 Jython 的安装和支持欠佳。然而，现在 Java 已经适配的很好了，只有很少的问题。</p><p>现在还有 JAR 安装方式的 Robot Framework，Python 的测试库和 Jython 都被打包成一个大的 JAR 文件。这有很大的优势，你可以将 JAR 放入版本控制中，或者是放入本地的 Maven 仓库中。这样就能保证团队成员都使用相同版本的 Robot Framework，且能够实时更新。不过也有缺点，这种情况下，RIDE 无法显示 JAR 文件关键字的帮助信息，所以 RIDE 还需要单独安装。</p><p>好，现在回到我们的主题：用什么语言来实现自己的测试功能。</p><h2 id="Remote-Libraries"><a href="#Remote-Libraries" class="headerlink" title="Remote Libraries"></a>Remote Libraries</h2><p>目前为止，无论是本地还是服务器，Robot Framework 都是安装在同一台机器。然后我们也看到可以用 Python, Jython 和纯 Java 语言来开发测试库。</p><p>用 <a href="http://code.google.com/p/robotframework/wiki/RemoteLibrary">Remote Libraries</a>，可以在其他机器中，用支持 <a href="http://en.wikipedia.org/wiki/XML-RPC">XML-RPC protocol</a> 的任何语言来编写测试库。</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/RemoteLibrary.png" alt="RemoteLibrary"></p><p>当在测试用例和资源文件中导入 Remote Library，它们用起来和普通的库没有区别。还有一个优点是，你也可以从 Remote Library 中获取帮助文件。如果对其实现感兴趣，可以看看 Database Library 的源码。需要指出的是，Remote Library 功能本身就是某些测试库的附加功能。</p><p>Remote Library 作为一个远程的服务器，而 Robot Framework 作为一个客户端。当然这两个库完全能在本地使用。</p><p>这是绝对不能被低估的一个非常强大的功能。</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>把 Robot Framework 集成到持续集成服务器中非常直接，因为框架本身是用脚本语言写成的。Java 版本当然也可以使用 Maven 集成。</p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><ul><li><a href="https://www.codecentric.de/en/knowledge-hub/blog/robot-framework-tutorial-overview">Robot Framework Tutorial – Overview</a></li><li><a href="https://www.lyyyuna.com/2016/01/07/robotframework-tutorial-overview/">Robot Framework 教程 - 概览（译）</a></li></ul>]]></content>
    
    
    <summary type="html">本译文全面介绍了 Robot Framework 的概念、架构与关键字驱动测试原理，涵盖测试库、资源文件、Remote Library及语言选择等核心内容。</summary>
    
    
    
    
    <category term="Robot Framework" scheme="https://wu3227834.github.io/tags/Robot-Framework/"/>
    
    <category term="自动化框架" scheme="https://wu3227834.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>摄影简单构图思路</title>
    <link href="https://wu3227834.github.io/2025/08/31/2025-08-31-she-ying-jian-dan-gou-tu-si-lu/"/>
    <id>https://wu3227834.github.io/2025/08/31/2025-08-31-she-ying-jian-dan-gou-tu-si-lu/</id>
    <published>2025-08-31T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单构图（一）-左右分法"><a href="#简单构图（一）-左右分法" class="headerlink" title="简单构图（一）- 左右分法"></a>简单构图（一）- 左右分法</h2><p>大家可能听说过拍风景的三分法，又或者传统的黄金分割…… 可能对不少人来说，在观景窗去判断一些比较复杂的构图法则是一件苦差。</p><p>所以这里说的简单构图，就是简单得…… 只看一次，就学会了，下次就懂得怎么去拍。</p><p>我们的简单教学不是要大家学完就拍得很 dramatic 很特別，但是学会了以后，至少拍得还过得去。</p><p>这次先说的是<strong>左右分</strong>。</p><h3 id="横幅的做法"><a href="#横幅的做法" class="headerlink" title="横幅的做法"></a>横幅的做法</h3><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image.jpg" alt="橫幅图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image2.jpg" alt="橫幅图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image3.jpg" alt="橫幅图3"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image4.jpg" alt="橫幅图4"></p><p>你可以看到，主体通常会占了其中一边大部分的位置，主体是上下居中的，它的周围仍然会占用适量的空间，然而画面其他位置的地方都会尽量的简化，那么主体就会被凸显出来，令观众的眼睛停留在主图面上。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/left.jpg" alt="左边构图"></p><center> 左边构图 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/right.jpg" alt="右边构图"></p><center> 右边构图 </center><h3 id="直幅的做法"><a href="#直幅的做法" class="headerlink" title="直幅的做法"></a>直幅的做法</h3><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image5.jpg" alt="直幅图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image6.jpg" alt="直幅图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image7.jpg" alt="直幅图3"></p><p>直幅的做法大致和横幅差不多，可是在处理主体上则有少许不同。横幅的做法会是，把主体上下置中，完好的安放在构图的左/右方。然而因为直幅的阔度很窄，你很难去把主体完完整整的放进图片里。否则很有可能主体会有很大概率失去它在图片中的主要性，得不偿失，所以，我们可以把主题的边缘部分跳出框架，把它们从构图中拿走。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/top_left.jpg" alt="top_left"></p><center> 左边构图 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/top_right.jpg" alt="top_right"></p><center> 右边构图 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image8.jpg" alt="直幅图4"></p><p>有些时候，想夸大图片的效果，突出主体的重要性（如上图），那你可以把主题占照片的比例增加，也就是把跳出框架的部分增加。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/top_left_big.jpg" alt="top_left_big"></p><center> 把主体在图片中的占有率增加 </center><h2 id="简单构图（二）-二三分法"><a href="#简单构图（二）-二三分法" class="headerlink" title="简单构图（二）- 二三分法"></a>简单构图（二）- 二三分法</h2><p>很多朋友都知道风景构图的其中一种技巧三分法，其实很多时候我们不止可以三分，还可以简单的二分，又或者更细微的八九分。</p><p>当然，在这里不会由二到九的详细介绍，其实他们都大同小异，只要明白一两个例子，就可以完整的套用在另一个方法里。</p><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><p>二分，显而易见就是把图面一开二，也就是人们常说的<strong>天一半地一半</strong>，通常这构图的方式是用在风景照里，同样的，也可以用再前后景明显的图画里。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/hori.jpg" alt="hori"></p><center> 横幅 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/vert.jpg" alt="vert"></p><center> 直幅 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image9.jpg" alt="二分构图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image10.jpg" alt="二分构图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image11.jpg" alt="二分构图3"></p><h3 id="二分法变种"><a href="#二分法变种" class="headerlink" title="二分法变种"></a>二分法变种</h3><p>所谓的二分法变种，就是把二分法的比例稍作改动，意思就是可能天的一半多一点，地的那一半少一点空间，或者相反。作用是可以把焦点侧重于其中一部分，把最好的那个目光投射到观众的眼睛里。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image12.jpg" alt="二分变种构图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image13.jpg" alt="二分变种构图2"></p><h3 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h3><p>三分法的应用，通常的情况会是用于一些有前、中、后景的环境里。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/hori3.jpg" alt="hori3"></p><center> 横幅 </center><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/vert3.jpg" alt="vert3"></p><center> 直幅 </center><p>三分构图方式能够带出照片的前中后三金发的关联性，可增加照片的立体观感，若在不影响照片阅读性的情况下，可适当的加减景深令照片更富有层次感。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image14.jpg" alt="三分构图1"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image15.jpg" alt="三分构图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image16.jpg" alt="三分构图3"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image17.jpg" alt="三分构图4"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image18.jpg" alt="三分构图5"></p><h2 id="简单构图（三）-简易黄金比"><a href="#简单构图（三）-简易黄金比" class="headerlink" title="简单构图（三）- 简易黄金比"></a>简单构图（三）- 简易黄金比</h2><p>黄金比例是一个广泛使用的教学用词。自古希腊时代开始，一直被人类认为是美的代表…… 而在艺术上也是。</p><h3 id="黄金比的起源"><a href="#黄金比的起源" class="headerlink" title="黄金比的起源"></a>黄金比的起源</h3><p>很多人常说“没有数学就没有艺术”，其中所指便是黄金比例的发现。黄金比约为 1:1.618。早在古希腊时期，建筑师已将其应用于神殿设计，如帕特农神庙。到了文艺复兴时期，达·芬奇更发现这一比例与人体结构存在密切联系。随着人类理解的深化，黄金比逐渐被广泛运用于建筑、艺术乃至自然美学之中。</p><p>好，大概的资料到此为止，入正题了。</p><h3 id="黄金构图法则"><a href="#黄金构图法则" class="headerlink" title="黄金构图法则"></a>黄金构图法则</h3><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image19.jpg" alt="黄金构图1"></p><p>一般来说，当运用在摄影中时的黄金比，其实说直白一点，就是三分法和左右分法的混合体。</p><p>为什么呢？让我们一起来看看吧</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image20.jpg" alt="黄金构图2"></p><p>我们先从制作一个黄金分法开始</p><p>首先，我们把普通的一张 3:2 的图片，用对角线一分为二。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/step1.jpg" alt="黄金分法1"></p><p>接着，从每个角落的三角形里，拉一条与刚才对角线垂直的直线。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/step2.jpg" alt="黄金分法2"></p><p>最后，把这四条垂线的交点连起来，就会得到一个九宫格。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/step3.jpg" alt="黄金分法3"></p><p>注意，那其实不是平均分配的哦！不过，当我们在实际应用的时候，谁会记得他们不是平均的。所以一般对焦屏中的九宫格，都是平均的。</p><p>好，所以说九宫格就是黄金比喽？</p><p>嗯，当我们要构图的时候，试一下把焦点，落在那四个交接点上面，我们就称这类为黄金分割法。</p><p>像以下这些就是在不知不觉中，渗入了九宫格式构图的照片。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image21.jpg" alt="黄金构图3"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image22.jpg" alt="黄金构图4"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image23.jpg" alt="黄金构图5"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image24.jpg" alt="黄金构图6"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image25.jpg" alt="黄金构图7"></p><p>那……是否每一张照片使用黄金比例就会很好看呢？</p><p>这当然不一定啦！一张好照片的构成因素其实有很多，所谓的黄金比，其实只是为大家提供一种比较容易把握的构图的方式而已。当你熟悉并习惯运用后，便能在此基础上自由变化，创造出更具个人风格的作品 o(<em>￣▽￣</em>)ブ</p><h2 id="简单构图（四）-物件居中"><a href="#简单构图（四）-物件居中" class="headerlink" title="简单构图（四）- 物件居中"></a>简单构图（四）- 物件居中</h2><p>这篇东西是思前想后所写出来的，因为把构图居中，大概每个人都懂。所以本篇说的重点是之中物体于画面比例的关联性。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image26.jpg" alt="居中构图1"></p><h3 id="简单图画的处理"><a href="#简单图画的处理" class="headerlink" title="简单图画的处理"></a>简单图画的处理</h3><p>如果说图画有透视感的，人的焦点就会自然落在透视点的位置。如果图画是一个相对平面，没有太多线条所影响的话，人所寻找的胶片，通常第一点，都会落左中心点附近的地方。</p><p>所以这里构图方式，很适合一些简朴的画面，如上图一样，只有一个物件，和一个色彩的背景。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image27.jpg" alt="居中构图2"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image28.jpg" alt="居中构图3"></p><p>但这是必然的吗? 并不是。只是在这情况下，这里构图的办法是比较常用而已，像下图这种比较复杂的其实也是可以的。</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image29.jpg" alt="居中构图4"></p><h3 id="置中物件跟背景比例的关系"><a href="#置中物件跟背景比例的关系" class="headerlink" title="置中物件跟背景比例的关系"></a>置中物件跟背景比例的关系</h3><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image30.jpg" alt="居中构图5"></p><p>相信拍了一段时间的朋友，不难会发现一件事：就是主体的大小，跟画面出来的感觉，彼此一样很重要的关联；这就是距离感。</p><p>像上图来说，是相隔一条街的拍摄效果，从画面上那人占的比例来说，好像并不是距离太远而已。这，可能会令人自不然联想起，原来他跟我们其实好近，可能下一步就是要走过来似的；</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image31.jpg" alt="居中构图6"></p><p>相反这一张，白衣的朋友，在画面中占的比例好像很小，乍一看的感觉是满遥远的；所以，就算她想走过来，也需要一段时间吧。这就是距离感上的分别。</p><p>而周边的空间扩大了，主体的比例小了一些；在画面上看起来，主体的影响力也会相对的小一点。这类的作法也常见于营造疏离感觉的照片当中。</p><p>所以，或者有些时候，我们可以把距离感，说成是一种 亲近 与 疏离 的分别。</p><p>这是亲近的：</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image32.jpg" alt="居中构图7"></p><p>这也许是中立的，不远，也不近：</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image33.jpg" alt="居中构图8"></p><p>这是远离的，就像是在一旁静静的看别处的人的动静似的：</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image34.jpg" alt="居中构图9"></p><h3 id="尝试跟其他方法交叉运用"><a href="#尝试跟其他方法交叉运用" class="headerlink" title="尝试跟其他方法交叉运用"></a>尝试跟其他方法交叉运用</h3><p>大斜线的构图方式：</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image35.jpg" alt="居中构图10"></p><p>这张也是，画面焦点中二人的剪影，跟背景喷泉形成了强烈的对比</p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image36.jpg" alt="居中构图11"></p><h3 id="Dos-and-Don’ts"><a href="#Dos-and-Don’ts" class="headerlink" title="Dos and Don’ts"></a>Dos and Don’ts</h3><p>简单的说说，一些可以尝试一下的 Dos and Don’ts</p><h4 id="Dos"><a href="#Dos" class="headerlink" title="Dos"></a>Dos</h4><ul><li>可以从九宫格的中心格开始，移前一点，移后一点，进行构图上的试行</li><li>尝试多跟画面呈水平的状态，这会比较易拍出效果</li><li>遇到有透视感觉的画面的时候，不妨试一下置中的构图，可能会有意想不到的效果</li></ul><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image37.jpg" alt="居中构图12"></p><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image38.jpg" alt="居中构图13"></p><h4 id="Don’ts"><a href="#Don’ts" class="headerlink" title="Don’ts"></a>Don’ts</h4><ul><li>置中的主体，不要太小，也不要太大；这会很难拍得好的，虽然这不是 100% 的定律</li></ul><p><img src="/img/2025-08-31-%E6%91%84%E5%BD%B1%E7%AE%80%E5%8D%95%E6%9E%84%E5%9B%BE%E6%80%9D%E8%B7%AF/image39.jpg" alt="居中构图14"></p><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><ul><li><a href="https://photalks.com/articles/25/%e7%b0%a1%e5%96%ae%e6%a7%8b%e5%9c%96-%e4%b8%80-%e5%b7%a6%e5%8f%b3%e5%88%86%e6%b3%95/">簡單構圖-一-左右分法</a></li><li><a href="https://photalks.com/articles/44/%e7%b0%a1%e5%96%ae%e6%a7%8b%e5%9c%96-%e4%ba%8c-%e4%ba%8c%e4%b8%89%e5%88%86%e6%b3%95/">簡單構圖-二-二三分法</a></li><li><a href="https://photalks.com/articles/567/%e7%b0%a1%e5%96%ae%e6%a7%8b%e5%9c%96-%e4%b8%89-%e7%b0%a1%e6%98%93%e9%bb%83%e9%87%91%e6%af%94/">簡單構圖-三-簡易黃金比</a></li><li><a href="https://photalks.com/articles/612/%e7%b0%a1%e5%96%ae%e6%a7%8b%e5%9c%96-%e5%9b%9b-%e7%89%a9%e4%bb%b6%e7%bd%ae%e4%b8%ad/">簡單構圖-四-物件置中</a></li></ul>]]></content>
    
    
    <summary type="html">探索摄影简单构图技巧，包括左右分法、二三分法、黄金比及物件居中，助你快速掌握构图要领，拍出吸引人的照片。</summary>
    
    
    
    
    <category term="摄影笔记" scheme="https://wu3227834.github.io/tags/%E6%91%84%E5%BD%B1%E7%AC%94%E8%AE%B0/"/>
    
    <category term="构图" scheme="https://wu3227834.github.io/tags/%E6%9E%84%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>async-profiler</title>
    <link href="https://wu3227834.github.io/2025/08/13/2025-08-13-async-profiler/"/>
    <id>https://wu3227834.github.io/2025/08/13/2025-08-13-async-profiler/</id>
    <published>2025-08-13T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<p>前两篇文章介绍了 jvm 中的安全点机制，以及为什么（大多数）分析器都很难用。这篇文章介绍一下 async-profiler 这个工具。</p><p>这个项目是一个针对 Java 的低开销采样性能分析器，不受 Safepoint 偏差问题的影响。它具有 HotSpot 特定的 API, 用于收集堆栈跟踪和跟踪内存分配。该性能分析器可与 OpenJDK 和其他基于 HotSpot JVM 的 Java 运行时配合使用。<br>项目文档地址：<a href="https://github.com/async-profiler/async-profiler/tree/master/docs">async-profiler/docs/</a></p><h2 id="性能分析模式"><a href="#性能分析模式" class="headerlink" title="性能分析模式"></a>性能分析模式</h2><p>除了 CPU 时间，async-profiler 还提供了各种其他性能分析模式，如 Allocation, Wall Clock, Java Method，甚至是 Multiple Events 性能分析模式。</p><h3 id="CPU-分析"><a href="#CPU-分析" class="headerlink" title="CPU 分析"></a>CPU 分析</h3><p>在这种模式下，性能分析器收集栈跟踪样本，其中包括 <strong>Java 方法、原生调用、JVM 代码和内核函数</strong>。</p><p>通用方法是接收 <code>perf_events</code> 生成的调用栈，并将它们与 AsyncGetCallTrace 生成的调用栈进行匹配，以生成 Java 和本机代码的准确性分析。此外，Async-profiler 提供了一种解决方案，用于在 <code>AsyncGetCallTrace</code> 失败的<a href="https://bugs.openjdk.org/browse/JDK-8178287">某些案例情况</a>恢复栈跟踪。</p><p>与直接在 Java 代理中使用 <code>perf_events</code> 相比，这种方法具有以下优势，后者可以将地址转换为 Java 方法名称：</p><ul><li>不需要 <code>-XX:+PreserveFramePointer</code>, 这会引入性能开销，有时高达 10%</li><li>不需要在 JVM 开始时使用代理将 Java 代码地址转换为方法名称</li><li>显示解释器帧</li><li>不会生成大型中间文件（perf.data），一边在用户空间脚本中进一步处理</li></ul><p>如果希望在 libjvm 中解析帧，则需要使用调试符号。</p><h2 id="ALLOCATION-性能分析"><a href="#ALLOCATION-性能分析" class="headerlink" title="ALLOCATION 性能分析"></a>ALLOCATION 性能分析</h2><p>可以将性能呢分析器配置为收集分配了最大量堆内存的调用站点。</p><p>Async-profiler 不使用字节码探测或昂贵的 DTrace 探针等侵入性技术，这些技术对性能有显著影响。它也不影响 Escape Analysis 或阻止 JIT 优化 (如分配消除)。只测量实际的堆分配。</p><p>性能分析器具有 TLAB(Thread Local Allocation Buffer, 线程本地分配缓存) 驱动的采样功能。它依赖于 HotSpot 特定的回调来接收两种类型的通知：</p><ul><li>当在新创建的 TLAB 中分配对象时</li><li>当在 TLAB 之外的慢速路径上分配对象时</li></ul><p>可以使用 <code>--alloc</code> 选项调整采样间隔。例如 <code>--alloc 500k</code> 将在平均分配空间 500KB 后采样一次。在 JDK 11 之前，小于 TLAB 大小的间隔不会生效。</p><p>在分配分析模式下，每个调用跟踪的顶帧是分配对象的类，计数器是堆压力（分配的 TLAB 或 TLAB 外对象的总大小）。</p><h2 id="Native-memory-leaks"><a href="#Native-memory-leaks" class="headerlink" title="Native memory leaks"></a>Native memory leaks</h2><p>性能分析模式 <code>nativemem</code> 记录 <code>malloc</code>、<code>relloc</code>、<code>calloc</code> 和 <code>free</code> 地址，以便将分配与空闲调用进行匹配。这有助于将性能分析报告仅集中在非空闲分配上，这些分配可能是内存泄漏的来源。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asprof start -e nativemem -f app.jfr &lt;YourApp&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line">asprof start --nativemem N -f app.jfr &lt;YourApp&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or <span class="keyword">if</span> only allocation calls are interesting, <span class="keyword">do</span> not collect free calls:</span></span><br><span class="line">asprof start --nativemem N --nofree -f app.jfr &lt;YourApp&gt;</span><br><span class="line"></span><br><span class="line">asprof stop &lt;YourApp&gt;</span><br></pre></td></tr></table></figure><p>现在我们需要处理 jfr 文件，以查找原生内存泄漏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--total <span class="keyword">for</span> bytes, default counts invocations.</span></span><br><span class="line">jfrconv --total --nativemem --leak app.jfr app-leak.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">No leak analysis, include all native allocations:</span></span><br><span class="line">jfrconv --total --nativemem app.jfr app-malloc.html</span><br></pre></td></tr></table></figure><p>当使用 <code>--leak</code> 选项时，生成的火焰图将显示未匹配免费调用的分配。</p><p><img src="/img/2025-08-13-async-profiler/nativemem_flamegraph.png" alt="火焰图"></p><p>为了避免对分析会话结束时未释放的最新分配产生偏差，泄漏分析器会忽略分析期间最后10%的尾部分配。可以通过–tail选项调整尾部长度，该选项接受比率或百分比（%）作为参数。例如，要忽略10分钟分析中最后2分钟的分配，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jfrconv --nativemem --leak --tail 20% app.jfr app-leak.html</span><br></pre></td></tr></table></figure><p>原生内存分析的开销取决于原生分配的数量，但通常对生产环境来说也足够小。如果需要，可以通过配置分析间隔来降低开销。例如，添加 <code>nativemem=1m</code> 的分析器选项后，分配样本将限制为每分配 1MB 最多一个样本。</p><h2 id="Wall-clock-分析"><a href="#Wall-clock-分析" class="headerlink" title="Wall-clock 分析"></a>Wall-clock 分析</h2><p><code>-e wall</code> 选项告诉 async-profiler 在给定时间段内平等地采样所有线程，而不考虑线程状态：运行、睡眠或阻塞。例如，这在分析应用程序启动时间时可能会很有帮助。</p><p>Wall-clock 分析器在每线程模式（<code>-t</code>）下最有用。</p><p>示例：<code>asprof -e wall -t -i 50ms -f result.html 8983</code></p><h2 id="Lock-分析"><a href="#Lock-分析" class="headerlink" title="Lock 分析"></a>Lock 分析</h2><p><code>-e lock</code> 选项告诉 async-profiler 测量已分析应用程序中的锁争用。锁性能分析可以帮助开发人员了解锁获取模式、锁争用（当线程需要等待获取锁时）、等待锁花费的时间以及哪些代码路径因锁而被阻塞。</p><p>在锁分析模式中，顶部帧是锁/监视器类，计数器是进入该锁/监视器所需要的纳秒数。</p><p>示例：<code>asprof -e lock -t -i 5ms -f result.html 8983</code></p><h2 id="Java-方法分析"><a href="#Java-方法分析" class="headerlink" title="Java 方法分析"></a>Java 方法分析</h2><p><code>-e ClassName.methodName</code> 选项检测给定的 Java 方法，以记录对该方法的所有调用以及栈跟踪。</p><p>示例：<code>-e java.util.Properties.getProperty</code> 将分析调用 getProperty 方法的所有位置。</p><p>仅支持非原生 Java 方法。要分析原生方法，请改用硬件断电时间，例如 <code>-e Java_java_lang_Throwable_fillInStackTrace</code>。<strong>请注意</strong>，如果在运行时附加异步配置文件，非原生 Java 方法的第一次插桩可能会导致所有编译的方法去优化。虽有的插桩只会刷新依赖代码。</p><p>如果将 async-profiler 作为代理附加，则不会发生大规模的 CodeCache 刷新。</p><h2 id="Native-function-分析"><a href="#Native-function-分析" class="headerlink" title="Native function 分析"></a>Native function 分析</h2><p>以下是一些可以分析的 Native function：</p><ul><li><code>G1CollectedHeap::humongous_obj_allocate</code> - 跟踪 G1 GC 的巨大分配</li><li><code>JVM_StartThread</code> - 跟踪新 Java 线程的创建</li><li><code>Java_java_lang_ClassLoader_defineClass1</code> - 跟踪类加载</li></ul><h2 id="Multiple-events"><a href="#Multiple-events" class="headerlink" title="Multiple events"></a>Multiple events</h2><p>可以同时分析 CPU、分配和锁。除了 CPU，还可以选择任何其他执行事件：wall-clock, perf event, tracepoint, Java method 等等</p><p>唯一支持多个事件同时分析的输出格式是 JFR。记录将包含以下事件类型：</p><ul><li><code>jdk.ExecutionSample</code></li><li><code>jdk.ObjectAllocationInNewTLAB</code> (alloc)</li><li><code>jdk.ObjectAllocationOutsideTLAB</code> (alloc)</li><li><code>jdk.JavaMonitorEnter</code> (lock)</li><li><code>jdk.ThreadPark</code> (lock)</li></ul><p>如果分析 cpu + allocations + locks，可以指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof -e cpu,alloc,lock -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>或者使用 <code>--alloc</code> 和 <code>--lock</code> 参数并设置所需的阈值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof -e cpu --alloc 2m --lock 10ms -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>同样，当将分析器作为代理启动时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentpath:/path/to/libasyncProfiler.so=start,event=cpu,alloc=2m,lock=10ms,file=profile.jfr</span><br></pre></td></tr></table></figure><h2 id="使用-–all-进行多事件分析"><a href="#使用-–all-进行多事件分析" class="headerlink" title="使用 –all 进行多事件分析"></a>使用 –all 进行多事件分析</h2><p><code>--all</code> 标志提供了一个同时启动预定义的常见性能分析时间集合方法。默认情况下，<code>--all</code> 会激活 cpu、wall、alloc、lock 和 nativemem。</p><p><strong>注意</strong>：虽然 <code>--all</code> 标志对于开发环境来说可以用于获得广泛的概述，但不建议在生产环境中启动它，尤其是对于持续性能分析。用户需要仔细选择要分析的内容以及使用哪些设置。</p><p><strong>示例</strong>：下面这个命令启用了 <code>--all</code> 中包含的默认事件集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>或者结合 <code>--alloc</code>/<code>--wall</code>/<code>--lock</code>/<code>--nativemem</code> 选项来覆盖单个设置。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all --alloc 2m --lock 10ms -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>同样，当将性能分析器作为代理启动时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentpath:/path/to/libasyncProfiler.so=start,event=all,alloc=2m,lock=10ms,file=profile.jfr</span><br></pre></td></tr></table></figure><p>可以用你选择的任何其他事件类型来覆盖 <code>--all</code> 参数，而不是 <code>cpu</code>。例如，以下命令将分析循环以及 <code>wall</code>, <code>alloc</code>, <code>live</code>, <code>lock</code> 和 <code>nativemem</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all -e cycles -f profile.jfr</span><br></pre></td></tr></table></figure><h2 id="连续性能分析"><a href="#连续性能分析" class="headerlink" title="连续性能分析"></a>连续性能分析</h2><p>持续性能分析是一种可以持续性能分析应用程序并在每个指定时间段转储性能分析结果的方法。这是一种主动且高效地发现性能下降的非常有效的技术。持续性能分析有助于用户了解同一应用程序各版本之间的性能差异。可以将最近的输出与持续性能分析的输出历史记录进行比较，以找出差异并优化性能下降情况下引入的变更。aysnc-profiler 提供了使用循环选项持续性能分析应用程序的能力。确保文件名包含时间戳模式，否则输出将在每次迭代中被覆盖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --loop 1h -f /var/log/profile-%t.jfr 8983</span><br></pre></td></tr></table></figure><h2 id="perf-event-types-supported-on-Linux"><a href="#perf-event-types-supported-on-Linux" class="headerlink" title="perf event types supported on Linux"></a>perf event types supported on Linux</h2><table><thead><tr><th>Usage</th><th>Description</th></tr></thead><tbody><tr><td>Predefined:</td><td></td></tr><tr><td><code>-e cpu-clock</code></td><td>High-resolution per-CPU timer. Similar to <code>-e cpu</code> but forces using perf_events.</td></tr><tr><td><code>-e page-faults</code></td><td>Software page faults</td></tr><tr><td><code>-e context-switches</code></td><td>Context switches</td></tr><tr><td><code>-e cycles</code></td><td>Total CPU cycles</td></tr><tr><td><code>-e instructions</code></td><td>Retired CPU instructions</td></tr><tr><td><code>-e cache-references</code></td><td>Cache accesses (usually Last Level Cache, but may depend on the architecture)</td></tr><tr><td><code>-e cache-misses</code></td><td>Cache accesses requiring fetching data from a higher-level cache or main memory</td></tr><tr><td><code>-e branch-instructions</code></td><td>Retired branch instructions</td></tr><tr><td><code>-e branch-misses</code></td><td>Mispredicted branch instructions</td></tr><tr><td><code>-e bus-cycles</code></td><td>Bus cycles</td></tr><tr><td><code>-e L1-dcache-load-misses</code></td><td>Cache misses on Level 1 Data Cache</td></tr><tr><td><code>-e LLC-load-misses</code></td><td>Cache misses on the Last Level Cache</td></tr><tr><td><code>-e dTLB-load-misses</code></td><td>Data load misses on the Translation Lookaside Buffer</td></tr><tr><td>Breakpoint:</td><td></td></tr><tr><td><code>-e mem:&lt;addr&gt;</code></td><td>Breakpoint on a decimal or hex (0x) address</td></tr><tr><td><code>-e mem:&lt;func&gt;</code></td><td>Breakpoint on a public or a private symbol</td></tr><tr><td><code>-e mem:&lt;func&gt;[+&lt;offset&gt;][/&lt;len&gt;][:rwx&gt;]</code></td><td>Breakpoint on a symbol or an address with offset, length and read/write/exec. Address, offset and length can be hex or dec. The format of <code>mem</code> event is the same as in <a href="https://man7.org/linux/man-pages/man1/perf-record.1.html"><code>perf-record</code></a>.</td></tr><tr><td><code>-e &lt;symbol&gt;</code></td><td>Equivalent to an execution breakpoint on a symbol: <code>mem:&lt;symbol&gt;:x</code>. Example: <code>-e strcmp</code> will trace all calls of native <code>strcmp</code> function.</td></tr><tr><td>Tracepoint:</td><td></td></tr><tr><td><code>-e trace:&lt;id&gt;</code></td><td>Kernel tracepoint with the given numeric id</td></tr><tr><td><code>-e &lt;tracepoint&gt;</code></td><td>Kernel tracepoint with the specified name. Example: <code>-e syscalls:sys_enter_open</code> will trace all <code>open</code> syscalls.</td></tr><tr><td>Probes:</td><td></td></tr><tr><td><code>-e kprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Kernel probe. Example: <code>-e kprobe:do_sys_open</code>.</td></tr><tr><td><code>-e kretprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Kernel return probe. Example: <code>-e kretprobe:do_sys_open</code>.</td></tr><tr><td><code>-e uprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Userspace probe. Example: <code>-e uprobe:/usr/lib64/libc-2.17.so+0x114790</code>.</td></tr><tr><td><code>-e uretprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Userspace return probe</td></tr><tr><td>PMU:</td><td></td></tr><tr><td><code>-e r&lt;NNN&gt;</code></td><td>Architecture-specific PMU event with the given number. Example: <code>-e r4d2</code> selects <code>MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM</code> event, which corresponds to event 0xd2, umask 0x4.</td></tr><tr><td><code>-e &lt;pmu descriptor&gt;</code></td><td>PMU event descriptor. Example: <code>-e cpu/cache-misses/</code>, <code>-e cpu/event=0xd2,umask=4/</code>. The same syntax can be used for uncore and vendor-specific events, e.g. <code>amd_l3/event=0x01,umask=0x80/</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">async-profiler 是一个低开销 Java 性能分析器，规避 Safepoint 偏差，支持 CPU、内存分配、锁争用等多种分析模式，适用于 HotSpot JVM，提供精确的栈跟踪和内存泄漏检测。</summary>
    
    
    
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
    <category term="Profiler" scheme="https://wu3227834.github.io/tags/Profiler/"/>
    
  </entry>
  
  <entry>
    <title>为什么（大多数）取样 javaprofiler 都很难用</title>
    <link href="https://wu3227834.github.io/2025/08/12/2025-08-12-wei-shi-me-da-duo-shu-qu-yang-javaprofiler-du-hen-nan-yong/"/>
    <id>https://wu3227834.github.io/2025/08/12/2025-08-12-wei-shi-me-da-duo-shu-qu-yang-javaprofiler-du-hen-nan-yong/</id>
    <published>2025-08-12T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一篇英文翻译转载文章，主要介绍了 javaprofiler 的工作原理。<br><br>原英文链接：<a href="https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html">https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html</a><br></p></blockquote><p>这篇文章建立在之前的一篇<a href="https://wu3227834.github.io/2025/08/12/2025-08-12-jian-shu-jvm-zhong-de-an-quan-dian-ji-zhi/">关于安全点的文章</a>的基础上。如果你没有读过它，你可能会感到迷茫和困惑。如果你读过这篇文章，仍然感到迷茫和困惑，并且您确定这种感觉与当前的问题有关（而不是生存危机），请继续提问。</p><p>那么，既然我们已经确定了什么是安全点，那么：</p><ol><li>安全点轮询分散在相当多的任意点（取决于执行模式，主要是在未计数的循环后端或方法返回/入口）</li><li>将 JVM 带到全局安全点的成本很高</li></ol><p>我们已经掌握了所有需要的信息，可以得出结论，通过在安全点采样来进行剖析可能有点糟糕。这对于某些人来说并不奇怪，但是这个问题在最常见的分析器中是存在的。根据 RebelLabs 的调查，以下是详细情况：</p><p><img src="/img/2025-08-12-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%8F%96%E6%A0%B7javaprofiler%E9%83%BD%E5%BE%88%E9%9A%BE%E7%94%A8/which-profiler.png" alt="which-profiler"></p><p>VisualVM、NB Profiler（同上）、YourKit 和 JProfiler 都提供了一个 CPU 分析器，可以在安全点进行采样。鉴于这是一个相当常见的问题，让我们深入研究一下。</p><h2 id="采样执行探查器如何工作-理论上"><a href="#采样执行探查器如何工作-理论上" class="headerlink" title="采样执行探查器如何工作 (理论上)"></a>采样执行探查器如何工作 (理论上)</h2><p>抽样分析器应该通过收集应用程序在不同时间点所处位置的样本，来接近应用程序中“花费的时间”的分布。在每个样本中收集的数据可以是：</p><ul><li>current instruction</li><li>current line of code</li><li>current method</li><li>current stack trace</li></ul><p>数据可以为单个线程收集，也可以为每个样本中的所有线程收集。我们需要保存哪些数据才能进行有效的采样？</p><blockquote><p>然而，要使采样结果与完整（未采样）分析结果相媲美，必须满足以下两个条件。<br><strong>首先，我们必须拥有大量样本才能获得具有统计意义的结果。</strong>例如，如果一个分析器在整个程序运行过程中只收集了一个样本，那么该分析器会将程序执行时间的 100% 分配给它进行采样的代码，而将 0% 分配给其他所有代码。[…]<br><strong>其次，分析器应该以相同的概率对程序运行中的所有点进行采样。</strong>如果分析器不这样做，它的分析结果最终会出现偏差。例如，假设我们的分析器只能对包含调用的方法进行采样。即使不包含调用的方法可能占据了程序执行时间的很大一部分，该分析器也不会将执行时间分配给这些方法。<br>——摘自<a href="http://plv.colorado.edu/papers/mytkowicz-pldi10.pdf">《评估 Java 分析器的准确性》</a>，我们稍后会回到这篇文章。</p></blockquote><p>这听起来很简单，对吧？</p><p>一旦我们有了大量的样本，我们就可以构建一个热方法列表，甚至是这些方法中的代码行（如果样本报告了它），我们可以查看分布在调用树上的样本（如果收集了调用跟踪）并且度过一段美好的时光！</p><h2 id="通用商业-Java-采样执行分析器如何工作"><a href="#通用商业-Java-采样执行分析器如何工作" class="headerlink" title="通用商业 Java 采样执行分析器如何工作"></a>通用商业 Java 采样执行分析器如何工作</h2><p>好吧，我可以在这里从不同的解决方案进行逆向工程，或者通读开源代码库，但是我会提供一些没有支持的猜测，如果你知道更多的话，可以自由地告诉我。通用分析器依赖于 JVMTI(JVM Tool Interface) 规范，所有 jvm 都必须满足这一规范：</p><ul><li>JVMTI 仅提供安全点采样堆栈跟踪收集选项（调用线程的 GetStackTrace 不需要安全点，但对分析器来说用处不大；在 Zing 中，对其他线程调用 GetStackTrace 仅会将该线程带到安全点）。因此，希望其工具能在所有 JVM 上运行的厂商只能采用安全点采样方式。</li><li>无论你是在对单个线程进行采样还是对所有线程进行采样（至少在 OpenJDK 上是这样，Zing 略有不同，但作为分析工具供应商，你应假设使用的是 OpenJDK）。我所查看过的所有分析工具都采用对所有线程进行采样的方式。据我所知，它们也不会限制收集的堆栈深度。这相当于以下 JVMTI 调用：JvmtiEnv:：GetAllStackTraces (0，&amp;stack_info，&amp;thread_count)</li><li>因此，这相当于：设置一个定时线程，每隔 ‘sampling_interval’ 时间触发一次，并收集所有的堆栈跟踪信息。</li></ul><p>这有几个坏处，其中一些可以避免的：</p><ol><li>采样分析器需要采样，因此通常会将采样频率设置得相当高（通常为每秒 10 次，或每 100 毫秒一次）。设置 <code>-XX:+PrintGCApplicationStoppedTime</code> 并查看这引入了什么样的暂停时间是有指导意义的。几毫秒的暂停并不罕见，但具体情况具体分析（取决于线程数、堆栈深度、TTSP 等）。每 100 毫秒暂停 5 毫秒意味着分析器会引入 5% 的开销（实际损失可能比这更严重）。通常可以通过设置更长的间隔来控制损失，但这也意味着你需要更长的分析周期才能获得有意义的样本计数。</li><li>从所有线程收集完整的栈跟踪意味着你的安全点操作成本是开发的。你的应用程序拥有的线程越多（想想应用程序服务器、SEDA 架构、大量线程池等），你的栈跟踪越深（想想 Spring 和 Co.），你的应用程序等待单个线程来回采集名称和填写表单的时间就越长。据我所知，当前的分析器对此毫无帮助。如果你正在构建自己的分析器，那么对数量设置限制似乎是明智的，这样你就可以控制开销。JVMTI 功能允许你查看当前线程列表，如果少于 100 个，你可以对所有的线程进行采样，否则可以随机选择 100 个线程的子集进行采样。也许更倾向于采样那些实际在做某事的线程，而不是那些整天被阻塞的线程，这是有道理的。</li><li>仿佛这一切还不够糟糕似的，其实我感觉在安全点进行抽样似乎也有些毫无意义</li></ol><p>第 1 点和第 2 点是关于剖析开销的，这基本上是关于成本的。在我之前关于安全点的文章中，我查看了这些成本，所以没有必要重复这个练习。对于良好的剖析信息，成本可能是可以接受的，但正如我们将看到的，这些信息并不那么重要。</p><p>第 3 点需要解释，所以我们开始寻找其含义。</p><h2 id="安全点采样：理论"><a href="#安全点采样：理论" class="headerlink" title="安全点采样：理论"></a>安全点采样：理论</h2><p>那么，在安全点进行采样意味着什么？这意味着只运行代码中的安全点轮询是可见的。考虑到热代码可能是由 C1/C2 (客户端/服务器编译器) 编译的，我们减少了方法退出和未经计数的循环备份的采样机会。这导致了所谓的安全点排查现象，即采样性能分析器的采样偏向于下一个可用的安全点轮询位置（这违反了上面列出的第二个标准“<strong>性能分析器应该以相对概率对程序运行中的所有点进行采样</strong>”）。</p><p>这乍听起来可能没那么糟糕，所以让我们通过一个简单的例子来看看哪一行收到了责备。</p><p><strong>注意</strong>：在以下所有示例中，我将使用 JMH 作为测试工具，并使用 “CompilerControl” 注释来防止内联。这就使我能够控制编译单元的限制，这可能看起来很残酷、不寻常，或者至少是不公平的。在“野生”环境中，内敛决策受到很多因素的影响，（在我看来）将它们视为任意的（在几个编译器/JVM供应商/命令行参数等的手中）是安全的。内联可能是“所有优化之母”，但它在这方面是一个反复无常且狡猾的长辈。</p><p>让我们看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Param(&quot;1000&quot;)</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">byte</span>[] buffer;</span><br><span class="line"><span class="type">boolean</span> result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setup</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotNoInline</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    b += buffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  result = b == <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// SP poll, method exit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotInline</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    b += buffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  result = b == <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// SP poll, method exit (removed when method is inlined)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个容易思考的例子。我们可以通过改变数组的大小来控制方法中的工作量。我们知道技术循环中没有安全点轮询（通过查看汇编输出验证），因此理论上，上述方法在方法退出时将有一个安全点。问题是，如果我们让上述方法内联，方法的末尾安全点轮询将消失，而下一轮轮询将在测试循环中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotInline_avgt_jmhStub</span><span class="params">(InfraControl control, RawResults result,</span></span><br><span class="line"><span class="params">    SafepointProfiling_jmhType l_safepointprofiling0_0, Blackhole_jmhType l_blackhole1_1)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">operations</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> <span class="variable">realTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  result.startTime = System.nanoTime();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    l_safepointprofiling0_0.meSoHotInline(); <span class="comment">/* LINE 163 */</span></span><br><span class="line">    operations++;</span><br><span class="line">    <span class="comment">// SP poll, uncounted loop</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!control.isDone); <span class="comment">/* LINE 165 */</span></span><br><span class="line">  result.stopTime = System.nanoTime();</span><br><span class="line">  result.realTime = realTime;</span><br><span class="line">  result.measuredOps = operations;</span><br><span class="line">  <span class="comment">// SP poll, method exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果测量方法没有内联，预期它会受到指责似乎是合理的，但如果它确实内联了，我们可以预期测量方法会受到指责。对吧？非常合理，但有点偏差。</p><h2 id="安全点采样：现实"><a href="#安全点采样：现实" class="headerlink" title="安全点采样：现实"></a>安全点采样：现实</h2><p>在这篇 2010 年发表的精彩论文<a href="http://plv.colorado.edu/papers/mytkowicz-pldi10.pdf">《评估 Java 性能分析器的准确性》</a>中，作者们讨论了安全点偏差。他们认识到，不用的 Java 性能分析器会在同一基准中识别不同的热点，并深入研究其原因。他们没有建立一些一直热点的基准，并利用这些基准来理解安全点偏差性能分析器所看到的内容。他们指出：</p><blockquote><p>如果我们知道程序运行的“正确”分析结果，我们就可以根据这个正确的分析结果来评估分析器。不幸的是，大多数情况下并不存在“正确”的分析结果，因此我们无法确切地确定分析器是否产生了正确的结果。</p></blockquote><p>那么，如果我们构建一个已知的工作负载…… 这些分析器会看到什么呢？</p><p>我们将使用 JMH 安全点偏置性能分析器 “-prof stack” 来研究这一点。它很像 JVisualIVM 提供的相同代码的性能分析，而且对于这项研究来说，它看起来更加方便。注意：在接下来的部分中，我是用术语 sub-method 来描述从另一个方法调用的方法。例如，如果方法 A 调用了方法 B，则 B 是 A 的子方法。也许存在更好的术语，但这就是我在这里的意思。</p><p>如果我们运行上面的示例，我们会得到两行不同的热线代码 (使用 <code>-prof stack:detailLine=true</code> 运行): </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Benchmark: safepoint.profiling.SafepointProfiling.meSoHotInline</span><br><span class="line">....[Thread state: RUNNABLE]...</span><br><span class="line"> <span class="number">99.6</span>%  <span class="number">99.8</span>% meSoHotInline_avgt_jmhStub:<span class="number">165</span></span><br><span class="line"></span><br><span class="line"># Benchmark: safepoint.profiling.SafepointProfiling.meSoHotNoInline</span><br><span class="line">....[Thread state: RUNNABLE]...</span><br><span class="line"> <span class="number">99.4</span>%  <span class="number">99.6</span>% meSoHotNoInline_avgt_jmhStub:<span class="number">163</span></span><br></pre></td></tr></table></figure><p>在实际的热点方法中没有这种情况。似乎方法退出安全点并不被认为是其自身方法的指示，而是被认为是调用它的代码行的指示。因此，强制测量中的方法不内联意味着测量循环中的调用代码行，而让它内联则意味着循环的后端受到责备。同样，似乎一个未计数的循环安全点轮询也被认为是其自身方法的指标。</p><p>我们可以推断（但不一定是正确的），当看到这种没有代码行数据的分析结果时，一个热点方法表示：</p><ol><li>某些非内联子方法是热点</li><li>在一个未计数的循环中，某些代码（自用方法？内联子方法？非内联子方法？）是热点</li></ol><p>拥有一行代码数据可以帮助消除上述情况的歧义，但作为一行代码数据并不是很有用。一行热点代码可能表示：</p><ol><li>该行有一个方法调用：从该行调用的方法（或者它的内联子方法）是热点</li><li>该行是一个循环的后端：这个循环中的一些代码（包括内联子方法）是热点</li></ol><p>这看起来有用么？别抱太大希望。</p><p>因为我们通常不知道哪些方法被内联了，这可能会有点令人困惑（如果你想知道，可以使用 <code>-XX:+PrintInlining</code>，但是要注意，内敛决策可能会随着运行而变化）</p><h2 id="注意间距"><a href="#注意间距" class="headerlink" title="注意间距"></a>注意间距</h2><p>如果上述规则成立，你可以通过检查执行树中被指责节点下方的代码来使用安全点偏差性分析。换句话说，这将意味着一个热点方法表名热点 diamagnetic 可能位于该代码或其调用的方法中的某处。了解这一点会很有帮助，这个分析可以作为一些有效挖掘的起点。但遗憾的是，这些规则并不总是成立。它们忽略了一个事实，即热点代码可能位于指定的安全点轮询和之前的轮询之间的热河位置。参考以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blameSetResult</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      b += buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    setResult(b); <span class="comment">/* LINE 38 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult(b == <span class="number">1</span>); <span class="comment">/* LINE 90 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    result = b;</span><br><span class="line">  &#125;</span><br><span class="line">....[Thread state: RUNNABLE]........................................................................</span><br><span class="line"> <span class="number">98.6</span>%  <span class="number">98.8</span>% safepoint.profiling.SafepointProfiling.setResult:<span class="number">90</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% sun.misc.Unsafe.unpark:-<span class="number">2</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% safepoint.profiling.SafepointProfiling.blameSetResult:<span class="number">38</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% safepoint.profiling.generated.SafepointProfiling_blameSetResult_jmhTest.blameSetResult_avgt_jmhStub:<span class="number">165</span></span><br></pre></td></tr></table></figure><p>显然，在调用 setResult 之前，时间是在循环中度过的，但分析结果会归咎于 setResult。setResult 没有任何问题，除了它调用方法不是内联的，这为我们的分析器提供了归咎的机会。这证明了安全点轮询机会呈现给用户代码的随机性，并表明热代码可能位于当前安全点轮询和上一个安全点轮询之间的任何位置。这意味着，如果不知道上一个安全点轮询的位置，那么在安全点偏向的分析结果中，热方法/代码行可能会产生误导。请考虑以下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Benchmark</span></span><br><span class="line">  <span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">blameSetResultDeeper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">      b += buffer[i];</span><br><span class="line">    &#125;</span><br><span class="line">    setResult8(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult8</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult7(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult7</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult6(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult6</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult5(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult5</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult4(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult4</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult3(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult3</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult2(b);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult2</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult(b); <span class="comment">/* Line 86 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    setResult(b == <span class="number">1</span>); <span class="comment">/* LINE 90 */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(<span class="type">boolean</span> b)</span> &#123;</span><br><span class="line">    result = b;</span><br><span class="line">  &#125;</span><br><span class="line">....[Thread state: RUNNABLE]........................................................................</span><br><span class="line"> <span class="number">99.2</span>%  <span class="number">99.4</span>% safepoint.profiling.SafepointProfiling.setResult:<span class="number">90</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% safepoint.profiling.generated.SafepointProfiling_blameSetResultDeeper_jmhTest.blameSetResultDeeper_avgt_jmhStub:<span class="number">163</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% sun.misc.Unsafe.compareAndSwapInt:-<span class="number">2</span></span><br><span class="line">  <span class="number">0.2</span>%   <span class="number">0.2</span>% safepoint.profiling.SafepointProfiling.setResult2:<span class="number">86</span></span><br></pre></td></tr></table></figure><p>分析器暗示调用者指向了堆栈下方 9 层的一个廉价方法，但真正的罪魁祸首是最顶层方法的循环。需要注意的是，内联会阻止方法显示，但非内联的框架只会在返回时打破安全点之间的间隙（无论如何，在 OpenJDK 上如此。这取决于供应商和用户的想法。例如，Zing 将方法级别的安全点放在入口处，我不确定 J9 对此持何种立场。这并不是说一种方法比另一种更好，只是说位置是任意的）。这就是为什么非内联且位于堆栈更高位置的 setResult6 没有显示的原因。</p><h2 id="总结：它有什么用"><a href="#总结：它有什么用" class="headerlink" title="总结：它有什么用"></a>总结：它有什么用</h2><p>如上所述，安全点采样分析器可能会对应用程序中的热点代码位置产生严重不准确的判断。这使得对“运行中”线程的衍生观察变得相当可疑，但至少对哪些线程正在运行的观察是正确的。这并不意味着它们完全没有用，有时候我们只需要一个正确的方向提示，就能进行一些好的分析，但这里也存在浪费时间的巨大风险。虽然在解释器中运行的代码样本不会受到安全点偏差的影响，但这并不是很有用，因为热点代码很快就会被编译。如果你的热点代码还在解释器中运行，那么你有比安全点偏差更大的问题需要解决……</p><p>阻塞线程的堆栈跟踪是准确的，因此 “Waiting” 状态分析对于发现阻塞代码的性能瓶颈非常有用。如果阻塞方法是你性能问题的根源，那么这一分析结果会是一个很重要的线索。</p><p>外面还有更好的选择！例如：</p><ul><li>Java Mission Control</li><li>Solaris Studio</li><li>Honest-Profiler</li><li>Perf + perf-map-agent (or perfasm if your workload is wrapped in a JMH benchmark)</li></ul><p>没有哪种工具是完美的，但上述所有工具在识别 CPU 时间花费方面都还不错。</p>]]></content>
    
    
    <summary type="html">本文探讨了Java采样分析器因安全点偏差导致的不准确性，分析其工作原理及局限性，揭示热点代码识别的误导性，并推荐更精准的工具，助开发者优化性能。</summary>
    
    
    
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>简述 jvm 中的安全点机制</title>
    <link href="https://wu3227834.github.io/2025/08/12/2025-08-12-jian-shu-jvm-zhong-de-an-quan-dian-ji-zhi/"/>
    <id>https://wu3227834.github.io/2025/08/12/2025-08-12-jian-shu-jvm-zhong-de-an-quan-dian-ji-zhi/</id>
    <published>2025-08-12T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文是一篇英文翻译转载文章，主要介绍了 Safepoints。<br><br>原英文链接：<a href="https://psy-lob-saw.blogspot.com/2015/12/safepoints.html">https://psy-lob-saw.blogspot.com/2015/12/safepoints.html</a><br></p></blockquote><p>在过去的一年里，我做了几次关于性能分析和 JVM 运行时/执行的演讲，在这两次演讲中，我都发现自己遇到了安全点（Safepoint）这个话题。大多数人对安全点的存在一无所知，而我通常会在一屋子人中找到一两个对这个术语有所了解的开发人员。这并不令人惊讶，因为安全点并不是 Java 语言规范的一部分。但是，由于安全点是每一个 JVM 实现（据我所知）的一部分，并且扮演着重要角色，所以一下是我对这个概述的拙劣尝试。</p><h2 id="什么是-Safepoint"><a href="#什么是-Safepoint" class="headerlink" title="什么是 Safepoint?"></a>什么是 Safepoint?</h2><p>最近有人问我：“安全点是像安全词一样的东西吗？” 简短的回答是 “完全不是”，但因为我喜欢这个比喻，所以我会继续使用它：</p><p>想象一下，一个 JVM 里挤满了忙碌的变异线程（Mutator Threads），它们挥汗如雨地在堆上进行变异操作。有些线程甚至（天哪！）共享了可变状态。它们肆无忌惮地并发修改彼此的状态，简直像野兽一样。有些线程则躲在角落里独自修改自己的状态（迟早会把自己搞瞎）。突然，一块霓虹灯牌闪亮，上面写着 “PINEAPPLES”（Stop-the-World）。变异线程一个接一个停下它们在堆上的疯狂折腾，静静等待，汗水滴落。当最后一个变异线程停下时，一群精灵（gc）走了进来，清空烟灰缸，装满所有饮料，清理地上的水洼，然后以最快的速度消失，回到北极。霓虹灯牌熄灭，线程们又重新开始它们的狂欢 ……</p><p>在网上可以找到许多关于安全点的引用，接下来是我尝试使用更细致入微的内容，从这一点开始，不再使用 “汗流浃背的变异线程”。</p><ol><li>安全点（Safepoint）是指线程执行过程中，其状态能被清晰描述的一段范围。变异线程（Mutator Threads）是那些操作 JVM 堆的线程（所有 Java 线程都是变异线程，非 Java 线程在调用与堆交互的 JVM API 时也可能被视为变异线程）</li><li>在安全点上，变异线程与堆的交换处于一个已知且定义明确的状态。这意味着栈上的所有引用都被映射（位于已知位置），并且 JVM 能够完全追踪这些引用。只要线程保持在安全点，我们就可以安全地操作堆和栈，确保线程在离开安全点时，其对世界的识图保持一致</li></ol><p>这一机制在 JVM 需要检查或更改堆时尤为重要，例如进行垃圾回收（GC）或出于其他多种原因。如果栈上的引用未被追踪，而 JVM 执行垃圾回收，可能会错误地认为某些对象已不再存活（尽管它们仍被栈上的引用所指向）而将其回收，或者可能在移动某个对象时未更新栈上的引用，导致内存损坏。</p><p>因此，JVM 需要一种方法将线程带入安全点（并保持在安全点），以便执行各种运行时“魔法”操作。以下是 JVM 在所有变异线程到达安全点并被锁定（即全局安全点）时才能执行的部分活动列表，这些活动有时被称为安全点操作：</p><ul><li>Some GC phases (the Stop The World kind)</li><li>JVMTI stack sampling methods (not always a global safepoint operation for Zing)</li><li>Class redefinition</li><li>Heap dumping</li><li>Monitor deflation (not a global safepoint operation for Zing)</li><li>Lock unbiasing</li><li>Method deoptimization (not always)</li><li>And many more!</li></ul><p>Azul 公司的 John Cuthbertson 在 2014 年 JavaOne 大会上发表了一场精彩的演讲，详细介绍了安全点的背景以及除垃圾回收外的其他安全点操作细节（我们在 Azul 认为垃圾回收问题已解决，因此该演讲聚焦于其他需要暂停线程的原因）。</p><p>需要注意的是，请求全局安全点和线程安全点之间的区别仅在某些 JVM 实现中存在（例如Azul Systems的Zing JVM，提醒：我为Azul工作）。在 OpenJDK/Oracle JVM 中没有这种区别。这意味着 Zing 可以单独将某个线程带入安全点。</p><p>总结如下：</p><ul><li>安全点是 JVM 实现中的一个常见细节。</li><li>它们用于暂停变异线程，以便 JVM 进行“修复”操作。</li><li>在 OpenJDK/Oracle JVM 中，每次安全点操作都需要全局安全点。</li><li>所有当前 JVM 都有对全局安全点的某些需求。</li></ul><h2 id="我的线程什么时候处于安全点？"><a href="#我的线程什么时候处于安全点？" class="headerlink" title="我的线程什么时候处于安全点？"></a>我的线程什么时候处于安全点？</h2><p>因此，将线程置于安全点允许 JVM 继续进行其托管运行时的“魔法表演”，太棒了！这个酷炫的状态何时发生呢？</p><ul><li>如果一个 Java 线程被锁或同步块阻塞、等待监听器、驻留或在阻塞 IO 上阻塞，那么它就处于安全点。本质上，这些都是 Java 线程的有序调度事件，并且是将线程带到安全点之前进行整理的一部分</li><li>Java 线程在执行 JNI 代码时处于安全点。在跨越本机调用边界之前，堆栈保持一致状态，然后移交给本机代码。这意味着线程仍然可以在安全点上运行</li><li>执行字节码的 Java 线程不在安全点（或者至少 JVM 不能假定它在安全点）</li><li>被操作系统中断但不在安全点的 Java 线程在取消调度之前不会被带到安全点</li></ul><p>JVM 和正在运行的 Java 线程围绕安全点有以下关系：</p><ul><li>JVM 不能强制任何线程进入安全点状态</li><li>JVM 可以阻止线程离开安全点状态</li></ul><p>那么，JVM 如何将所有线程带入安全点状态呢？问题是需要将线程暂停在已知状态，而不仅仅是中断它。为了实现这一目标，JVM 让 Java 线程在方便的地方挂起自己，如果它们观察到一个 “安全点标志” 的话。</p><h2 id="将-Java-线程引入安全点"><a href="#将-Java-线程引入安全点" class="headerlink" title="将 Java 线程引入安全点"></a>将 Java 线程引入安全点</h2><p>Java 线程会以“合理”的间隔轮询“安全点标志”（可以是全局标志或线程级标志），并在观察到“进入安全点”标志时转换到安全点状态（线程在安全点被阻塞）。这听起来很简单，但为了避免频繁检查是否需要暂停，C1/C2编译器（即-client/-server JIT编译器）会尽量减少安全点轮询的次数。除了检查标志本身的开销外，维持“已知状态”还会显著增加某些优化实现的复杂性。因此，将安全点轮询间隔拉长可以为优化提供更大的空间。综合这些考虑，安全点轮询通常出现在以下位置：</p><ul><li>在解释器中运行时，在任意两个字节码之间（有效）</li><li>在 C1/C2 编译代码中的“非计数”循环后沿 （ On ‘non-counted’ loop back edge in C1/C2 compiled code ）<ul><li>A common type of program loop is one that <strong>is controlled by an integer</strong> that counts up from a initial value to an upper limit. Such a loop is called a <strong>counting loop</strong>. The integer is called a loop control variable. Loops are implemented with the conditional branch, jump, and conditional set instructions.</li></ul></li><li>在 C1/C2 编译代码中的方法入口/出口（Zing JVM在方法入口，OpenJDK在方法出口）。注意，当方法被内联时，编译器会移除这些安全点轮询。</li></ul><p>如果你是那种以汇编为乐趣 (或利润，或两者兼而有之) 的人，你会在 <code>-XX:+PrintAssembly</code> 输出中找到安全点轮询，方法是：</p><ul><li>‘{poll}’ or ‘{poll return}’ on OpenJDK, this will be in the instructions comments</li><li>‘tls.pls_self_suspend’ on Zing, this will be the flag examined at the poll operation</li></ul><p>这一机制在不同的虚拟机上实现方式不同（以下以x86 + Linux为例，我未研究其他架构）：</p><ul><li>在 Oracle/OpenJDK 中，通过对一个特殊内存页的地址执行盲 TEST 指令来实现。所谓“盲”，是因为该指令后没有分支指令，因此非常不显眼（通常 TEST 指令会紧跟一个分支指令）。当 JVM 希望将线程带入安全点时，它会保护该内存页，导致发生 SEGV（段错误），JVM 会捕获并适当处理此错误。每个 JVM 只有一个这样的特殊内存页，因此要将某个线程带入安全点，必须将所有线程带入安全点。</li><li>在 Zing JVM 中，安全点标志是线程局部的（因此有 tls 前缀）。线程可以独立地被带入安全点。</li></ul><p>更多关于轮询的细节，可参见相关文章：<a href="https://psy-lob-saw.blogspot.com/2014/03/where-is-my-safepoint.html">Dude, Where’s My Safepoint?</a></p><p>一旦线程检测到安全点标志，它将执行轮询触发的安全点动作。这通常意味着线程会在某个 JVM 级别的锁上阻塞，直到安全点操作完成时被释放。可以将此视为一种锁机制，其中：</p><ul><li>线程可以自行锁定（例如，通过调用 JNI 或在安全点阻塞）。</li><li>线程可以尝试重新进入（例如，从 JNI 返回时），但如果锁被 JVM 持有，它们将被阻塞。</li><li>安全点操作会请求该锁，并阻塞直到获得锁（即所有变异线程都已自行锁定）。</li></ul><h2 id="补充-JIT"><a href="#补充-JIT" class="headerlink" title="补充 JIT"></a>补充 JIT</h2><p>JIT 是 just in time 的缩写，也就是即时编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。下面，就对该编译器技术做个简单的讲解。</p><p>当 JVM 执行代码时，它并不立即开始编译代码。这主要有两个原因：</p><p>首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译（编译成二进制）这段代码并执行代码来说，要快很多。</p><p>当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。其实说简单点，就是 JIT 在起作用，我们知道，对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。</p><p>JIT 编译器在运行程序时有两种编译模式可以选择，并且其会在运行时决定使用哪一种以达到最优性能。这两种编译模式的命名源自于命令行参数（eg: -client 或者 -server）。JVM Server 模式与 client 模式启动，最主要的差别在于：-server 模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。原因是：当虚拟机运行在 -client 模式的时候，使用的是一个代号为 C1 的轻量级编译器，而 -server 模式启动的虚拟机采用相对重量级代号为 C2 的编译器。C2 比 C1 编译器编译的相对彻底，服务起来之后，性能更高。</p>]]></content>
    
    
    <summary type="html">本文深入探讨了JVM中的安全点（Safepoint）机制，阐述其在垃圾回收和其他运行时操作中的关键作用，分析线程如何进入安全点，以及不同JVM实现（如OpenJDK和Zing）的差异和优化策略</summary>
    
    
    
    
    <category term="Java" scheme="https://wu3227834.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>性能分析思路</title>
    <link href="https://wu3227834.github.io/2025/08/04/2025-08-04-xing-neng-fen-xi-si-lu/"/>
    <id>https://wu3227834.github.io/2025/08/04/2025-08-04-xing-neng-fen-xi-si-lu/</id>
    <published>2025-08-04T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<p>我还年轻的时候，经常听一些大会或者演讲。有些人说，思路逻辑非常重要。我那时就想，你肯定是瞎忽悠的，因为我怎么就没听懂你说的思路呢？而现在轮到自己来写或者讲一些东西的时候，才发现他们说得对，而我之所以不理解，也是有原因的。性能分析思路和具体实现之间，有一道鸿沟，那就是操作的能力。之前我为什么听不懂那些人的思路，其实是因为我没有操作的功底。而有了操作的功底之后，还有一个大的鸿沟要越过去，那就是从操作到对监控计数器的理解。这一步可以说让很多性能测试人员都望而却步了。但是这还不算完，这一步迈过去之后，还有一个跳跃，就是相关性分析和证据链分析的过程。</p><p>如此一来，就会得到一张性能测试分析的能力阶梯视图，如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image.png" alt="性能分析能力阶梯视图"></p><ol><li>工具操作：包括压力工具、监控工具、剖析工具、调试工具</li><li>数值理解：包括上面工具中所有输出的数据</li><li><strong>趋势分析、相关性分析、证据链分析</strong>：就是了解了工具产生的数值之后，还要把它们的逻辑关系明白。这才是性能测试分析中最重要的一环</li><li>最后才是调优：有了第 3 步之后，调优的方案策略就有很多种了，具体选择取决于调优成本和产生的效果</li></ol><p>那么怎么把这些内容都融会贯通呢？下面我们就来说说性能测试分析的几个重要环节。</p><p>应该说，从我十几年的性能工作中，上面讲的这些内容是我觉得最有价值的内容了。在今天的文章中，我们将对它做一次系统的说明。我先把性能分析思路大纲列在这里：</p><ol><li>瓶颈的精确判断</li><li>线程递增的策略</li><li>性能衰退的过程</li><li>响应时间的拆分</li><li>构建分析决策树</li><li>场景的比对</li></ol><h2 id="瓶颈的精确判断"><a href="#瓶颈的精确判断" class="headerlink" title="瓶颈的精确判断"></a>瓶颈的精确判断</h2><h3 id="TPS-曲线"><a href="#TPS-曲线" class="headerlink" title="TPS 曲线"></a>TPS 曲线</h3><p>对性能瓶颈做出判断是性能分析的第一步，有了问题才能分析调优。之前有很多人在描述性能测试的过程中，说要找到性能测试中曲线上的“拐点”。我也明确说，大部分系统其实没有明确的拐点的。举例来说，TPS 的试图如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image2.png" alt="TPS图 1"></p><p>显然，这是一个阶梯式增加的场景，非常好。但是拐点在哪呢？有人说，显然在 1200TPS左右的时候。也有人说了，显然是到 1500TPS 才是拐点呀。但是也有人说，这都已经能到2000TPS 了，显然 2000TPS 是拐点。</p><p>我们再来看一下这张图对应的响应时间视图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image2.png" alt="响应时间图 1"></p><p>是不是有人要说响应时间为 4.5ms 时是拐点了？其实这些对拐点的判断，都是不合理的。如果我们对 TPS 的增加控制得更为精确的话，那么这个 TPS 的增加是是有一个有清晰的弧度，而不是有一个非常清晰的拐点。</p><p>但是至少我们可以有一个非常明确的判断，那就是瓶颈在第二个压力阶梯上已经出现了。因为响应时间增加了，TPS 增加得却没有那么多，到第三个阶梯时，显然增加的 TPS 更少了，响应时间也在不断地增加，所以，性能瓶颈在加剧，越往后就越明显。</p><p>那么我们的判断就是：</p><ol><li>有瓶颈！</li><li>瓶颈和压力有关</li><li>压力呈阶梯，并且增长幅度在衰减</li></ol><p>如果你觉得上面的瓶颈还算清晰的话，那么我们再来看一张图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image4.png" alt="TPS图 2"></p><p>在这个 TPS 的曲线中，你还能判断出拐点在哪吗？</p><p>显然是判断不出来拐点的，但是我们根据图得出以下几个结论：</p><ol><li>有瓶颈！</li><li>瓶颈和压力有关</li><li>压力也是阶梯的，但是并没有明确的拐点</li></ol><p>我们再来看一个 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image5.png" alt="TPS图 3"></p><p>看到这张图，是不是明显感觉系统有瓶颈呢？那么瓶颈是不是和压力大小有关呢？</p><p>这种比较有规律的问题，显然不是压力大小的原因。为什么呢？因为 TPS 周期性地出现降低，并且最大的 TPS 也都恢复到了差不多的水位上。所以，即使是压力降低，也最多降低最大的 TPS 水位，会让问题出现得更晚一点，但是不会不出现。</p><p>综合以上，如果画一个示意图的话，TPS 的衰减过程大概会如下所示：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image6.png" alt="示意图"></p><ol><li>随着用户数的增加，响应时间也在缓慢增加</li><li>TPS 前期一直都在增加，但是增加的幅度在变换，直至变平</li></ol><p>在这样的曲线图中，我们是看不到明确的观点的。但是我们能做的清晰的判断就是：有瓶颈！</p><p>所以对 TPS 曲线来说，它可以明确告诉我们的就是：</p><ol><li>有没有瓶颈：其实准确来说所有的系统都有性能瓶颈，只看我们在哪个量级上做性能测试了</li><li>瓶颈和压力有没有关系：TPS 随着压力的变化而变化，那就是有关系。不管压力增不增加，TPS 都会出现曲线趋势问题，那就是无关</li></ol><p>这时你可能会问，为什么不看响应时间就武断地下此结论呢？其实响应时间用来判断业务有多快的，而 TPS 才是用来判断容量有多大的。</p><h3 id="响应时间的曲线"><a href="#响应时间的曲线" class="headerlink" title="响应时间的曲线"></a>响应时间的曲线</h3><p>我们还是来看看响应时间，下面看一张响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image7.png" alt="响应时间图"></p><p>它对应的线程图是：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image8.png" alt="线程图"></p><p>多明显的问题，随着线程的增多，响应时间也在增加，是吧。再来看它们对应的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image9.png" alt="TPS图"></p><p>到第 40 个线程时，TPS 基本上达到上限，为 2500 左右。响应时间随着线程数的增加而增加了，系统的瓶颈显而易见地出现了。</p><p>但是，如果只让你看 TPS 曲线，你是不是也会有同样的判断？那就是：有瓶颈！并且和压力有关？所以说，其实 TPS 就可以告诉我们系统有没有瓶颈了，而响应时间是用来判断业务有多块的。</p><p>后面我们还会提到响应时间会是性能分析调优地重要分析对象。</p><h2 id="线程递增的策略"><a href="#线程递增的策略" class="headerlink" title="线程递增的策略"></a>线程递增的策略</h2><p>讲完响应时间之后，我们再来看下线程递增。在见识了很多性能测试人员做的场景之后，必须得承认，有些场景地问题太多了。</p><p>首先，我们来看两个场景地执行对比。</p><p>场景 1 的线程图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image10.png" alt="线程图 1"></p><p>场景 1 的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image11.png" alt="TPS图 1"></p><p>场景 1 的响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image12.png" alt="响应时间图 1"></p><p>场景 2 的线程图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image13.png" alt="线程图 2"></p><p>场景 2 的 TPS 图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image14.png" alt="TPS图 2"></p><p>场景 2 的响应时间图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image15.png" alt="响应时间图 2"></p><p>这两个场景的比对如下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image16.png" alt="比对图"></p><table><thead><tr><th>对比项</th><th>场景 1</th><th>场景 2</th></tr></thead><tbody><tr><td>线程数</td><td>一次性加到500</td><td>10线程递增，并且递增中也是有梯度的</td></tr><tr><td>TPS</td><td>最大值达到400</td><td>最大值达到400，但递增过程中有抖动</td></tr><tr><td>响应时间</td><td>在600ms~660ms之间</td><td>在20ms~150ms之间</td></tr><tr><td>错误率</td><td>无</td><td>无</td></tr><tr><td>粒度</td><td>以分钟为粒度</td><td>以2秒为粒度</td></tr></tbody></table><p>有了这些对比数据之后，你是不是觉得哪里似乎是有问题的？</p><p>对的！</p><p>TPS 都是达到 400，但两个场景中线程递增的策略不同。产生的响应时间完全不同。虽然都没有报错，但是第一种场景是完全不符合真实的业务场景的。这是为什么呢？</p><p>在场景的执行过程中，首先，响应时间是从低到高的，而在场景 1 中不是这样。其次，线程应该是递增的，而场景 1 并没有这样做（这里或许有人会想到秒杀的场景，认为场景 1 符合秒杀的业务设定，这个问题我们稍后提及）。最后，在两个场景中，TPS 的上限都达到了 400 TPS。但是你可以看到，在场景 2 中，只要 40 线程即可达到，但场景 1 中居然用到了 500 线程，显然压力过大，所以响应时间才那么长。</p><p>其实在生产环境中，像场景 1 这样的情形是不会出现的。如果它出现了，那就是你作为性能测试的责任，因为你没有给出生成环境中应该如何控制流量的参数配置说明。</p><p>同时，我们从上面的场景对比中可以看到，<strong>对一个系统来说，如果仅在改变压力策略（其他的条件比如环境、数据、软硬件配置等都不变）的情况下，系统的最大 TPS 上限是固定的。</strong></p><p>场景 2 使用了递增的策略，在每个阶梯递增的过程中，出现了抖动，这就明显是系统设置的不合理导致的。设置不合理，有两种可能性：</p><ol><li>资源的动态分配不合理，向后端线程池、内存、缓存等等</li><li>数据没有预热</li></ol><p>我们再回到之前说的秒杀场景。说到秒杀场景，有人觉得用大线程并发是合理的，其实这属于认知上的错误。因为即使线程数增加得再多，对已经达到 TPS 上限的系统来说，除了会增加响应时间之外，并无其他作用。所以他们描述系统的容量是用系统当前能处理的业务量（你用 TPS 也好，RPS 也好，HPS 也好，它们都是用来描述服务端的处理能力的），而不是压力工具中的线程数。</p><p>那么，对于场景中线程（有些工具中叫虚拟用户）递增的策略，我们要做到以下几点：</p><ol><li>场景中的现场递增一定是连续的，并且在递增的过程中也是有梯度的。</li><li>场景中的线程递增一定要和 TPC 的递增有比例关系，而不是突然达到最上限。</li><li>上面两点针对的是常规的性能场景。对于秒杀类的场景，我们前期一定要做好了系统预热的工作的，在预热后，线程突增产生的压力，也是在可处理范围的。这是，我们可以设计线程徒增的场景来看系统瞬间的处理能力。如果不能模拟出秒杀的徒增，就是不合理的场景。</li></ol><p>这里给出我做性能场景递增的经验值：</p><table><thead><tr><th>响应时间</th><th>递增幅度</th></tr></thead><tbody><tr><td>0-50ms</td><td>1</td></tr><tr><td>50-100ms</td><td>1-3</td></tr><tr><td>100-200ms</td><td>3-5</td></tr><tr><td>200-500ms</td><td>5-10</td></tr></tbody></table><p>当然这里也不会放在哪个系统中合适的递增幅度，你还是要根据实际的测试过程来做相应的判断。</p><h2 id="性能衰减的过程"><a href="#性能衰减的过程" class="headerlink" title="性能衰减的过程"></a>性能衰减的过程</h2><p>有瓶颈的判断能力，也有了线程递增的意识，那么下面在场景执行，我们就要有判断性能衰减的能力了吧。来，我们先看一个压力过程中产生的结果图。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image17.png" alt="压力结果图"></p><p>在递增的压力过程中，随着用户数的增加。我们可以做几次计算。</p><p>第一次计算，在线程达到 24 时，TPS 为 1810.6，也就是每线程每秒发出 75.44 个请求。</p><p>第二次计算，在线程达到 72 时，TPS 为 4375.1，也就是每线程每秒发出 60.77 个请求。</p><p>第三次计算，在线程达到 137 时，TPS 为 5034，也就是每线程每秒发出 36.74 个请求。</p><p>通过这三次计算，我们是不是可以看到，每线程每秒发出的请求数在变少，但是整体 TPS 是在增加的。</p><p>我们很多做性能测试的人，基本上，只看 TPS 和响应时间的时候，在上面这个示例中，肯定会一直往上加用户。虽然响应时间在增加，但是增加得也不多嘛。</p><p>但实际上，通过我们的计算可以知道，性能是在不断地衰减的。我们来看一张统计图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image18.png" alt="统计图"></p><p>通过红线德大致比对可以知道，当每线程每秒的请求数降到 55 左右的时候，TPS 就达到上线了，大概在 5000 左右，再接着往上增加线程已经没有用了，响应时间开始往上增加了。</p><p>这就是性能衰减的过程（题外话，再上图中，其实还有一个问题，就是在红线前面，性能在上升的过程中有几次抖动，这个抖动到后面变大了，也变频繁了，如果这是必然出现的抖动，那也是配置问题）</p><p>为什么要这么细致地描述性能衰退的过程呢？</p><p>其实我就是想告诉你，<strong>只要每线程每秒的 TPS 开始变少，就意味着性能瓶颈已经出现了。但是瓶颈出现之后，并不是说服务器的处理能力（这里我们用 TPS 来描述）会下降，应该说 TPS 仍然会上升，在性能不断衰退的过程中，TPS 就会达到上限。</strong></p><p>这也是前面说的，性能瓶颈其实在最大 TPS 之前早就已经出现了。</p><p>那么我们是不是应该在性能衰减到最大 TPS 时就停止场景呢？这个不一定的哦。</p><p>因为停不停场景，取决于我们的场景目标，如果我们只是为了得到最大 TPS，那确实可以停止场景了。但是，如果我们要扩大化性能瓶颈，也就是说为了瓶颈更为明显，就完全不需要停止场景，只要不报错，就接着往上压，一直压到我们能要说的下一个话题 ———— 响应时间变长，需要拆分。</p><h2 id="响应时间的拆分"><a href="#响应时间的拆分" class="headerlink" title="响应时间的拆分"></a>响应时间的拆分</h2><p>在性能分析中，响应时间的差分通常是一个分析起点。因为在性能场景中，不管是什么原因，只要系统达到了瓶颈，再接着增加压力，肯定会导致响应时间的上升，直至达到超时为止。</p><p>在判断了瓶颈之后，我们需要找到问题出现在什么地方。在压力工具上看到的响应时间，都是经过了后端的每一个系统的。</p><p>那么，当响应时间变长，我们就要知道，它在哪个阶段时间变长了，来看下面这个图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image19.png" alt="压力测试逻辑图"></p><p>这应该是最简单的一个压力测试逻辑图。一个应用，一个 DB，结果也拆分出了 8 个时间段，这还是在我没有加上压力工具自己所消耗的时间的情况下。但是在真实的场景中，基本上不是这样的。如果是内网，那基本上都是连在一个交换机上，所以通常是这样的：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image20.png" alt="拓扑图1"></p><p>在这样的拓扑中，我们仍然可以拆出来 t1 到 t8 的时间。只是实际动手的时候，思路一定要清晰，时间拆分是从哪里到哪里，要画出来，不能混乱。</p><p>我们有很多手段可以进行时间的拆分，当然要看我们的应用支持哪一种。如果我们是这样的架构，拆分时间应该是比较清楚的。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image21.png" alt="拓扑图2"></p><p>首先我们需要查看 Nginx 上的时间。日志里就可以通过配置$request_time $upstream_response_time得到日志如下信息：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14.131.17.129</span> - - <span class="string">[09/Dec/2019:08:08:09 +0000]</span> <span class="string">&quot;<span class="keyword">GET</span> / HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">25317</span> <span class="number">0</span>.<span class="number">028</span> <span class="number">0</span>.<span class="number">028</span></span><br></pre></td></tr></table></figure><p>最后两列中，前面是请求时间的 28ms，后面是后端响应时间的 28ms。同时，我们再到 Tomcat 上去看时间。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">172.18.0.1</span> - - <span class="string">[09/Dec/2019:08:08:09 +0000]</span> <span class="string">&quot;<span class="keyword">GET</span> / HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">25317</span> <span class="number">28</span> <span class="number">27</span> http-nio-<span class="number">8080</span>-exec-<span class="number">1</span></span><br></pre></td></tr></table></figure><p>请求时间消耗了 28ms，响应时间消耗了 27ms。接着再来看一下前端的时间消耗。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image22.png" alt="前端耗时图"></p><p>从这里可以看到，从发出请求到接收到第一个字节，即 TTFB 是 55.01ms，内容下载用了 11.75ms。从这就可以看得出 Nginx 基本上没消耗时间，因为它和 Tomcat 上的请求响应时间非常接近。</p><p>那么网络上的消耗时间怎么样呢？我看到有很多人用 TTFB 来描述网络的时间。先来说明一下，TTFB 中显然包括了后端一系列处理和网络传输的时间。如下图所示。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image23.png" alt="TTFB 图1"></p><p>下面的红色点是指要接收的内容。上面的红色线就是 TTFB。如果接收完了呢？就是这个状态。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image24.png" alt="TTFB 图2"></p><p>所以，我觉得用 TTFB 描述网络的健康状态并不合理。如果用 Content Download 来描述会更为合理。比如我们上面的这个例子中，那就是 11.75ms 下载了 25317 Bytes 的内容。</p><p>Tomcat 上基本上是消耗了处理的所有时间，当然这中间也包括了 MySQL 花费的时间。而前端看到的其他时间就消耗在了网络中。</p><p>在这个例子中，主要说明了响应时间怎么一步步拆。当然，如果你是下面这种情况的话，再一个个拆就比较辛苦了，需要换另一种方式。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image25.png" alt="拓扑图3"></p><p>你肯定想知道每个系统消耗了多长时间，那么我们就需要链路监控工具来拆分时间了。比如像这样来拆分：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image26.png" alt="拆分图"></p><p>从 User 开始，每个服务之间的调用时间，都需要看看时间消耗的监控。这就是时间拆分的一种方式。其实不管我们用什么样的工具来监控，最终我们想要得到的无非是每个环节消耗了多长时间。用日志也好，用链路监控也好，甚至抓包都可以。当我们拆分到了某个环节之后，就有了下一步的动作：构建分析决策树。</p><h2 id="构建分析决策树"><a href="#构建分析决策树" class="headerlink" title="构建分析决策树"></a>构建分析决策树</h2><p>分析决策树，对性能测试分析人员实在太重要了，是性能分析中不可或缺的一环。<strong>它是对架构的梳理，是对系统的梳理，是对问题的梳理，是对查找证据链过程的梳理，是对分析思路的梳理。它起的是纵观全局，高屋建瓴的指导作用。</strong></p><p>性能做到了艺术的层级之后，分析决策树就是提炼出来的，可以触及旁通的方法论。而我要在这里跟你讲的，就是这样的方法论。应该说，所有的技术行业在面对自己的问题时，都需要分析决策树。再广而推之，所有的问题都要有分析决策树来协助。</p><p>通过上面的几个步骤，我们就会知道时间消耗在了哪个节点上。那么之后呢？又当如何？总要找到根本的原因才可以把，我画了如下的分析决策图：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image27.png" alt="分析决策图"></p><p>从压力工具中，只需知道 TPS、响应时间和错误率三条曲线，就可以明确判断瓶颈是否存在。再通过分段分层策略，结合监控平台、日志平台，或者其他实时分析平台，知道架构中哪个环节有问题，然后再根据更细化的架构图一一拆解下去。</p><p>我在这里，以数据库分析和操作系统分析举一下例子。首先我们看一下数据库分析决策树，比如针对 RDBMS 中的 MySQL，我们就可以画一下如下的决策树：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image28.png" alt="mysql分析决策图"></p><p>由于这里面的内容实在过多，无法一次性展现在这里。我举几个具体的例子给你说明一下。</p><p>MySQL 中的索引统计信息有配置值，有状态值。我们要根据具体的结果来判断是否需要增加 key_buffer_size 值的大小。比如这种就无所谓了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Buffer</span> used     <span class="number">3</span>.<span class="number">00</span>k of   <span class="number">8</span>.<span class="number">00</span>M  %Used:   <span class="number">0</span>.<span class="number">0004</span></span><br></pre></td></tr></table></figure><p>从上面的数据可以看到，key buffer size 就用到了 4%，显然不用增加。</p><p>再比如，我们看到这样的数据：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="attribute">__Tables_______________________</span></span><br><span class="line"><span class="attribute">Open</span>             <span class="number">2000</span> of <span class="number">2000</span>    %Cache: <span class="number">100</span>.<span class="number">00</span></span><br><span class="line"><span class="attribute">Opened</span>         <span class="number">15</span>.<span class="number">99</span>M     <span class="number">4</span>.<span class="number">1</span>/s</span><br></pre></td></tr></table></figure><p>这就明显有问题了。配置值为 2000 的 Open Table Cache，已经被占满了。显然这里需要分析。但是，看到状态值达到配置值并不意味着我们需要赶紧加大配置值，而是要分析是否合理，再做相应的处理。比如说上面这个，Table 确实打开得多，但是如果我们再对应看下这一条。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Slow</span> <span class="number">2</span> s        <span class="number">6</span>.<span class="number">21</span>M     <span class="number">1</span>.<span class="number">6</span>/s</span><br></pre></td></tr></table></figure><p>你是不是觉得应该先去处理慢 SQL 的问题了？</p><p>关于数据库的我们就不举更多的例子了。在这里只是为了告诉你，在分析决策树的创建过程中，有非常多的相互依赖关系。</p><p>然后我们再来看一下操作系统分析决策树，我在这里需要强调一下，操作系统的分析决策树，不可以绕过。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image29.png" alt="操作系统分析决策图"></p><p>如果你想到操作系统架构图就头大，那么这时候应该觉得有了希望。那就是我觉得操作系统上的问题判断是比较清晰的，所以基于此决策树，每个人都可以做到对操作系统中性能问题的证据链查找。</p><p>但是！对嘛，总得有个但是。</p><p>对操作系统的理解是个必然的前提。我看过很多人写的操作系统性能分析方面的书籍或资料，发现大部分人把描述计数器的数值当成性能分析。怎么理解这句话呢？比如说</p><p>“CPU 使用率在 TPS 上升的过程中，从 10% 增加到 95%，超过了预期值。” “内存使用率达到 99%，所以是瓶颈点。” “I/O 使用率达到 100%。” 等等。</p><p>像这样的描述，在我的性能团队中，一定会被骂回去重写。我要这些描述有什么用？我要的是为什么达到了这样的值，原因在哪？怎么解决？</p><p>就像分析决策树中所描述的那样，性能工程师要做的是一步步地细化分析，给出最终的原因。</p><p>有人说，如果按这个路子，似乎操作系统的分析并不复杂嘛。大概三五个命令就可以跳到代码层了。是的，对于操作来说，确实不多，但是对于判断来说，那就复杂了。举个例子来说明一下：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image30.png" alt="TOP图"></p><p>看到这样的图，你是不是有种手足无措的感觉？中断能占 40%，sy CPU 也能占 40%。这系统还用干业务的事吗？全干自己的事去了，可见操作系统有问题！你是不是要做这个判断了？</p><p>而实际情况是，这个主机上只有一个网卡队列，而请求量又比较大。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image31.png" alt="网卡队列图"></p><p>所以要解决的是网卡队列的问题，至于怎么解决，那手段就多了。可以换个服务器，可以多加几个队列，可以多接几个节点…</p><p>以上只是给出几个性能分析过程中常见的决策树示例。在后续的分析过程实例中，我们将秉承着这种分析思路，一步步地走到瓶颈的面前。</p><h2 id="场景的比对"><a href="#场景的比对" class="headerlink" title="场景的比对"></a>场景的比对</h2><p>为什么要写这一部分呢？因为我看到很多人对瓶颈的判断，并不那么精确，所以想写一下场景对比的建议。其实简单来说，就一句话：当你觉得系统中哪个环节不行的话，又没能力分析她，你可以直接做该环节的增加。举例来说，我们现在有一个如下的架构：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image32.png" alt="架构图"></p><p>可以得到这样的结果：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image33.png" alt="结果图"></p><p>从 TPS 曲线中，我们明显看到系统是有瓶颈的，但是并不知道在哪里。鉴于系统架构如此简单，我们索性直接再某环节上加上一台服务器，变成这样：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image34.png" alt="架构图"></p><p>然后得到如下数据：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image35.png" alt="结果图"></p><p>哟，没好使！</p><p>怎么办？再接着加其他节点，我加了更多的 JMeter 机器。</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image36.png" alt="架构图"></p><p>再来看下结果：</p><p><img src="/img/2025-08-04-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%80%9D%E8%B7%AF/image37.png" alt="结果图"></p><p>真巧，TPS 增加了！</p><p>看到了吧，这就是我说的场景比对。</p><p>当我们不知道系统中哪个环节存在性能瓶颈时，对架构并不复杂的系统来说，可以使用这样的手段，来做替换法，以快速定位问题。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这一篇中，我说到了瓶颈的精准判断、线程递增的策略、性能衰减的过程、响应时间的拆分、构建分析决策树以及场景的比对，这几个环节，是性能分析过程中非常重要的环节。</p><p>从我的经验上来说，这一篇文章可能是我工作十几年的精华所在了。而这里的每一个环节，又有非常多的细分，特别是构建分析决策树这一块，它需要太多的架构知识、系统知识、数据库知识等等。鉴于本文只是想起到一个提纲挈领的作用，所以无法展开描述，希望在后续的篇幅中，我们尽量细致拆解。</p>]]></content>
    
    
    <summary type="html">介绍了瓶颈的精准判断、线程递增的策略、性能衰减的过程、响应时间的拆分、构建分析决策树以及场景的比对，这几个环节，是性能分析过程中非常重要的环节</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="极客时间" scheme="https://wu3227834.github.io/tags/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何用perf工具分析Java程序</title>
    <link href="https://wu3227834.github.io/2025/07/21/2025-07-21-ru-he-yong-perf-gong-ju-fen-xi-java-cheng-xu/"/>
    <id>https://wu3227834.github.io/2025/07/21/2025-07-21-ru-he-yong-perf-gong-ju-fen-xi-java-cheng-xu/</id>
    <published>2025-07-21T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何分析容器内的进程"><a href="#如何分析容器内的进程" class="headerlink" title="如何分析容器内的进程"></a>如何分析容器内的进程</h2><p><img src="/img/2025-07-21-%E5%A6%82%E4%BD%95%E7%94%A8perf%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90Java%E7%A8%8B%E5%BA%8F/image.png" alt="perf record"></p><p>当使用 perf 工具时，看到 16 进制地址而不是函数名，通常是因为缺少符号信息（symbol information）或调试信息，导致 perf 无法将地址解析为对应的函数名或源代码行。比较常见的场景是分析容器内的子进程，因为容器应用依赖的库都在镜像里面。</p><p>针对容器的情况，总结了一下四种解决方法。</p><p><strong>第一种方法，再容器外构建相同路径的依赖库。</strong>这种方法从原理上可行，但是并不推荐，一方面是因为找出这些依赖库比较麻烦，更重要的是，构建这些路径，会污染容器主机环境</p><p><strong>第二种方法，在容器内部运行 perf。</strong>不过，这需要容器运行在特权模式下，但实际的应用程序往往只以普通容器的方式运行。所以，容器内部一般没有权限执行 perf 分析。</p><p>比方说，如何你在普通容器内运行 perf record，你将会看到下面这个错误提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@efbd40d93ebf /]# perf record -g -p 1</span><br><span class="line"></span><br><span class="line">perf_event_open(…, PERF_FLAG_FD_CLOEXEC) failed with unexpected error 1 (Operation not permitted)</span><br><span class="line"></span><br><span class="line">perf_event_open(…, 0) failed unexpectedly with error 1 (Operation not permitted)</span><br><span class="line"></span><br><span class="line">Error:</span><br><span class="line"></span><br><span class="line">No permission to enable cycles event.</span><br><span class="line">You may not have permission to collect stats.</span><br><span class="line">Consider tweaking /proc/sys/kernel/perf_event_paranoid,</span><br><span class="line">which controls use of the performance events system by</span><br><span class="line">unprivileged users (without CAP_SYS_ADMIN).</span><br><span class="line">The current value is -1:</span><br><span class="line">-1: Allow use of (almost) all events by all users</span><br><span class="line"></span><br><span class="line"> Ignore mlock limit after perf_event_mlock_kb without CAP_IPC_LOCK</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 0: Disallow ftrace <span class="keyword">function</span> tracepoint by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line"></span><br><span class="line"> Disallow raw tracepoint access by users without CAP_SYS_ADMIN</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 1: Disallow CPU event access by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">= 2: Disallow kernel profiling by <span class="built_in">users</span> without CAP_SYS_ADMIN</span></span><br><span class="line">To make this setting permanent, edit /etc/sysctl.conf too, e.g.:</span><br><span class="line">kernel.perf_event_paranoid = -1</span><br></pre></td></tr></table></figure><p>从<a href="https://docs.docker.com/engine/security/seccomp/">docker seccomp</a>文档中可以看出，由于安全问题，系统调用 “perf*” 和 “ptrace” 默认被禁止。当然，其实你可以通过配置 /proc/sys/kernel/perf_event_paranoid（比如改成 -1），来允许非特权用户执行 perf 事件分析；不过还是那句话，为了安全起见，这种方式不太推荐。</p><p><strong>第三种方法，指定符号路径为容器文件系统的路径。</strong></p><p>举个例子：我们要分析一个在 Nginx 容器中运行的 worker 进程，可以执行一下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取 worker 在宿主机上的进程号</span></span><br><span class="line">PID = $(docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; mynginx)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">宿主机上创建临时目录作为挂载点</span></span><br><span class="line">mkdir /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 bindfs 进行挂载 (需要 root 权限)</span></span><br><span class="line">bindfs /proc/$PID/root /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 perf record 记录性能数据</span></span><br><span class="line">perf record -p $PID -g -- sleep 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 perf report 分析数据并指定符号路径</span></span><br><span class="line">perf report --symfs /tmp/foo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载 bindfs 挂载</span></span><br><span class="line">umount /tmp/foo/</span><br></pre></td></tr></table></figure><p>不过要注意，bindfs 这个工具需要你额外安装。bindfs 的基本功能是实现目录绑定（类似于 mount –bind）。</p><p><strong>第四种方法，在容器外吧分析记录保存下来，再去容器里查看结果。</strong>这样，库和符号的路径也就都对了。比如，你可以这么做。先运行 <code>perf record -g -p &lt;pid&gt;</code>，执行一会儿（比如 15 秒）后，按 Ctrl+C 停止。</p><p>然后，把生成的 perf.data 文件，拷贝到容器里边来分析，不过，这里也需要注意 perf 工具的版本问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker cp perf.data mynginx:/tmp </span><br><span class="line">docker exec -i -t mynginx bash</span><br><span class="line"></span><br><span class="line">cd /tmp/ </span><br><span class="line">yum install perf</span><br><span class="line">perf report</span><br></pre></td></tr></table></figure><p>当你按照前面这几种方法操作后，你就可以在容器内部看到：</p><p><img src="/img/2025-07-21-%E5%A6%82%E4%BD%95%E7%94%A8perf%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90Java%E7%A8%8B%E5%BA%8F/image2.png" alt="perf report"></p><h2 id="为何看不到原生的Java的调用栈"><a href="#为何看不到原生的Java的调用栈" class="headerlink" title="为何看不到原生的Java的调用栈"></a>为何看不到原生的Java的调用栈</h2><p>分析 Java 应用时，perf 工具面临一个根本挑战：Java 代码并非直接在 CPU 上执行原生机器码，而是运行在一个名为 JVM（Java 虚拟机）的托管环境中：</p><ul><li>JIT 编译的抽象层：JVM 会在运行时通过即时编译（JIT）技术将热点的 Java 字节码动态编译成高效的机器码。这个过程意味着 perf 采样到的是这些动态生成的、无明确符号（函数名）的机器码地址</li><li>非标准调用栈：perf 默认只能识别操作系统层面的函数调用，因此它能看到 JVM 自身的函数（如 JavaMain），但是无法理解 JVM 内部的、属于 Java 应用程序的调用关系</li></ul><p>为了让 perf 发挥最用，必须建立一座桥梁，将 JVM 内的函数调用信息与 perf 的系统级采样数据关联起来。可以采用以下方案解决：</p><p>步骤一：保留帧指针（Preserve Frame Pointer），这是确保调用栈能被正常回溯的基础</p><ul><li>操作：在启动 Java 应用时，添加 JVM 参数 <code>-XX:-PreserveFramePointer</code></li><li>原理：处于性能优化，JIT 编译器默认会省略帧指针，这会释放一个寄存器提供其他用途。然后，perf 等多数性能分析工具依赖帧指针来遍历和回溯函数调用栈。启动此选项可以强制 JVM 保留该信息，从而生成完整、可追溯的调用栈。</li></ul><p>步骤二：生成 Java 符合映射表</p><p>此步骤的目的是将 perf 看到的内存地址翻译成可读的 Java 函数名</p><ul><li>工具：使用 <a href="https://github.com/jvm-profiling-tools/perf-map-agent">perf-map-agent</a>，这是一个专门为此设计的开源工具</li><li>原理：perf-map-agent 会作为一个 Java Agent 附加到目标 JVM 进程上，查询 JIT 编译后的机器码地址与原始 Java 方法名的对应关系，并将其写入一个 perf 能够识别的映射文件（通常是 /tmp/perf-<pid>.map）。perf 在生成报告时会自动检测并使用此文件。</li></ul><p>步骤三：使用 perf 采样与分析</p><p>完成上述准备后，就可以使用标准的 perf 命令进行性能分析。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo perf record -F 99 -p &lt;pid&gt; -g -- sleep 30 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-F 99：以 99Hz 的频率采样</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-g：记录调用图（Call Graph）</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">分析采样数据</span></span><br><span class="line">sudo perf report</span><br></pre></td></tr></table></figure><p><strong>拓展</strong>：目前有现成的工具解决上述问题，<a href="https://github.com/async-profiler/async-profiler">async-profiler</a>，是一个专为 Java 设计的低开销、高精度的性能分析器，它集成了 perf 的功能并做了大量优化，是目前 Java 性能分析的优选工具。</p>]]></content>
    
    
    <summary type="html">使用 perf 分析 Java 程序需解决符号缺失和调用栈问题，可通过容器内外路径映射、保留 JVM 帧指针、使用 perf-map-agent 或 async-profiler 优化分析</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：网络</title>
    <link href="https://wu3227834.github.io/2025/06/17/2025-06-17-linux-tracing-network/"/>
    <id>https://wu3227834.github.io/2025/06/17/2025-06-17-linux-tracing-network/</id>
    <published>2025-06-17T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux网络性能指标"><a href="#Linux网络性能指标" class="headerlink" title="Linux网络性能指标"></a>Linux网络性能指标</h2><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><ul><li>带宽，表示链路的<strong>最大传输速率</strong>，单位通常为 b/s（比特/秒）</li><li>吞吐量，表示单位时间内成功传输的数据量，单位通常为 b/s（比特/秒）或者 B/s(字节/秒)。<strong>吞吐量受带宽限制</strong>，而吞吐量/带宽，也就是该网络的使用率</li><li>延时，表示从网络请求发出后，一直到收到远端响应，所需要的时间延迟。在不同场景中，这一指标可能会有不同的涵义。比如，它可以表示，建立连接需要的时间（比如 TCP 握手延时），或一个数据包往返所需的时间（比如 RTT）</li><li>PSS，是 Packet Per Second（包/秒）的缩写，表示以<strong>网络包为单位的传输速率</strong>。PSS 通常用来评估<strong>网络的转发能力</strong>，比如硬件交换机，通常可以达到线性转发（即 PPS 可以达到或者接近理论最大值）。而基于 Linux 服务器的转发，则容易受网络包大小的影响</li></ul><p>另外，<strong>网络的可用性</strong>（网络能否正常通信）、<strong>并发连接数</strong>（TCP 连接数量）、<strong>丢包率</strong>（丢包百分比）、<strong>重传率</strong>（重新传输的网络包比例）等也是常用的性能指标。</p><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><p>使用命令 ifconfig 或者 ip 查看</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig eth1</span><br><span class="line">eth1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 9.134.194.74  netmask 255.255.248.0  broadcast 9.134.199.255</span><br><span class="line">        ether 52:54:00:82:12:e8  txqueuelen<span class="number"> 1000 </span> (Ethernet)</span><br><span class="line">        RX packets<span class="number"> 70297502 </span> bytes<span class="number"> 34143392231 </span>(31.7 GiB)</span><br><span class="line">        RX errors<span class="number"> 0 </span> dropped<span class="number"> 0 </span> overruns<span class="number"> 0 </span> frame 0</span><br><span class="line">        TX packets<span class="number"> 78816203 </span> bytes<span class="number"> 45528648722 </span>(42.4 GiB)</span><br><span class="line">        TX errors<span class="number"> 0 </span> dropped<span class="number"> 0 </span>overruns<span class="number"> 0 </span> carrier<span class="number"> 0 </span> collisions 0</span><br><span class="line"></span><br><span class="line">$ ip -s  addr show dev eth1</span><br><span class="line">2: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu<span class="number"> 1500 </span>qdisc mq state UP qlen 1000</span><br><span class="line">    link/ether 52:54:00:82:12:e8 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 9.134.194.74/21 brd 9.134.199.255 scope global eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">   <span class="number"> 34143407013 </span>70297654<span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>      </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns </span><br><span class="line">   <span class="number"> 45528723929 </span>78816328<span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span>     <span class="number"> 0 </span> </span><br></pre></td></tr></table></figure><p>第一，网络接口的状态标志。ifconfig 输出 RUNNING，或者 ip 输出中的 LOWER_UP，都表示物理网络是连通，即网卡已经连接到了交换机或者路由器中。如果你看不到它们，通常表示网线被拔掉了。</p><p>第二，MTU 的大小。MTU 默认大小是 1500，根据网络架构的不同（比如是否使用了 VXLAN 等叠加网络），你可能需要调大或者调小 MTU 的数值。</p><p>第三，网络接口的 IP 地址、子网以及 MAC 地址。这些地址都是保障网络功能正常工作所必须的，你需要确保配置正确。</p><p>第四，网络收发的字节数、包数、错误数以及丢包情况，特别是 TX 和 RX 部分的 errors、dropped、overruns、carrier 以及 collisions 等指标不为 0 时，通常表示出现了网络 I/O 问题。其中：</p><ul><li>errors 表示发生错误的数据包数，比如校验错误、帧同步错误等</li><li>dropped 表示丢弃的数据包数，即数据包已经收到了 Ring Buffer，但因为内存不足等原因丢包</li><li>overruns 表示超限数据丢包数，即网络 I/O 速度过快，导致 Ring Buffer 中的数据包来不及处理（队列满）而导致的丢包</li><li>carrier 表示发生 carrirer 错误的数据报数，比如双工模式不匹配、物理电缆出现问题等</li><li>collisions 表示碰撞数据包数</li></ul><h3 id="嵌套字信息"><a href="#嵌套字信息" class="headerlink" title="嵌套字信息"></a>嵌套字信息</h3><p>使用 netstat 或 ss 来表示<strong>嵌套字、网络栈、网络接口以及路由表的信息</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -nlp | head -n <span class="number">3</span></span><br><span class="line">Active Internet connections (<span class="keyword">only</span> servers)</span><br><span class="line">Proto Recv-Q Send-Q <span class="keyword">Local</span> Address           <span class="keyword">Foreign</span> Address         State       PID/Program <span class="type">name</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10248</span>         <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:*               <span class="keyword">LISTEN</span>      <span class="number">624565</span>/kubelet</span><br><span class="line"></span><br><span class="line">$ ss -ltnp | head -n <span class="number">3</span></span><br><span class="line">State      Recv-Q Send-Q <span class="keyword">Local</span> Address:Port               Peer Address:Port</span><br><span class="line"><span class="keyword">LISTEN</span>     <span class="number">0</span>      <span class="number">65535</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10248</span>                    *:*                   users:((&quot;kubelet&quot;,pid=<span class="number">624565</span>,fd=<span class="number">29</span>))</span><br><span class="line"><span class="keyword">LISTEN</span>     <span class="number">0</span>      <span class="number">65535</span>  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">10249</span>                    *:*                   users:((&quot;kube-proxy&quot;,pid=<span class="number">624952</span>,fd=<span class="number">12</span>))</span><br></pre></td></tr></table></figure><p>其中，<strong>接收队列（Recv-Q）和发送队列（Send-Q）</strong>需要关注，它们通常是 0。当你发现它们不是 0 时，说明有网络包的堆积发生</p><p>当嵌套字处于连接状态（Established）时，</p><ul><li>Recv-Q 表示嵌套字缓冲还没有被应用程序取走的字节数（即接收队列长度）</li><li>Send-Q 表示还没有被远端主机确认的字节数（即发送队列长度）</li></ul><p>当嵌套字处于监听状态（Listening）时，</p><ul><li>Recv-Q 表示当前全连接队列（accept 队列）长度</li><li>Send-Q 表示全连接队列的最大长度</li></ul><h3 id="协议栈统计信息"><a href="#协议栈统计信息" class="headerlink" title="协议栈统计信息"></a>协议栈统计信息</h3><p>使用 netstat 或 ss 命令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -s</span><br><span class="line">Ip:</span><br><span class="line">   <span class="number"> 11236847787 </span>total packets received</span><br><span class="line">   <span class="number"> 76906 </span>forwarded</span><br><span class="line">   <span class="number"> 0 </span>incoming packets discarded</span><br><span class="line">   <span class="number"> 10964584370 </span>incoming packets delivered</span><br><span class="line">   <span class="number"> 10948611259 </span>requests sent out</span><br><span class="line">   <span class="number"> 448 </span>outgoing packets dropped</span><br><span class="line">   <span class="number"> 4 </span>dropped because of missing route</span><br><span class="line">Icmp:</span><br><span class="line">   <span class="number"> 37370022 </span>ICMP messages received</span><br><span class="line">   <span class="number"> 158 </span>input ICMP message failed.</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 141016</span><br><span class="line">        echo requests: 20256273</span><br><span class="line">        echo replies: 16972733</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[root@pudding-161 ~]<span class="comment"># ss -s</span></span><br><span class="line">Total:<span class="number"> 1434 </span>(kernel 1816)</span><br><span class="line">TCP:  <span class="number"> 1144 </span>(estab 894, closed 164, orphaned 0, synrecv 0, timewait 158/0), ports 0</span><br><span class="line"></span><br><span class="line">Transport Total     IP        IPv6</span><br><span class="line">*        <span class="number"> 1816 </span>     -         -</span><br><span class="line">RAW      <span class="number"> 2 </span>       <span class="number"> 1 </span>        1</span><br><span class="line">UDP      <span class="number"> 13 </span>      <span class="number"> 7 </span>        6</span><br><span class="line">TCP      <span class="number"> 980 </span>     <span class="number"> 349 </span>      631</span><br><span class="line">INET     <span class="number"> 995 </span>     <span class="number"> 357 </span>      638</span><br><span class="line">FRAG     <span class="number"> 0 </span>       <span class="number"> 0 </span>        0</span><br></pre></td></tr></table></figure><h3 id="网络吞吐-和-PPS"><a href="#网络吞吐-和-PPS" class="headerlink" title="网络吞吐 和 PPS"></a>网络吞吐 和 PPS</h3><p>使用 sar 命令，加上 -n 参数，可以查看网络的统计信息，比如网络接口（DEV）、网络接口错误（EDEV）、TCP、UDP、ICMP 等</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sar <span class="operator">-</span>n DEV <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span><span class="operator">-</span><span class="number">957</span>.el7.x86_64 (xxx)       <span class="number">06</span><span class="symbol">/18/2025</span>      _x86_64_        (<span class="number">8</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">42</span> PM     IFACE   rxpck<span class="symbol">/s</span>   txpck<span class="symbol">/s</span>    rxkB<span class="symbol">/s</span>    txkB<span class="symbol">/s</span>   rxcmp<span class="symbol">/s</span>   txcmp<span class="symbol">/s</span>  rxmcst<span class="symbol">/s</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM    dummy0      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM      eth0    <span class="number">695.00</span>    <span class="number">663.00</span>   <span class="number">6938.75</span>   <span class="number">3796.65</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM        lo    <span class="number">112.00</span>    <span class="number">112.00</span>     <span class="number">39.30</span>     <span class="number">39.30</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br><span class="line"><span class="number">07</span>:<span class="number">20</span>:<span class="number">43</span> PM kube-ipvs0      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span>      <span class="number">0.00</span></span><br></pre></td></tr></table></figure><ul><li>rxpck/s 和 txpck/s 分别是接收和发送的 PPS，单位为包/秒</li><li>rxkB/s 和 txkB/s 分别是接收和发送的吞吐量，单位是 KB/s</li><li>rxcmp/s 和 txcmp/s 分别是接收和发送的压缩数据包数，单位是包/秒</li></ul><p>带宽可以用 ethtool 来查询，它的单位通常是 Gb/s 或者 Mb/s（千兆网卡或者万兆网卡的单位都是 bit）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ethtool enp4s0f0 <span class="string">| grep Speed</span></span><br><span class="line">        Speed<span class="punctuation">:</span> <span class="number">1000</span>Mb/s</span><br></pre></td></tr></table></figure><h3 id="连通性和延时"><a href="#连通性和延时" class="headerlink" title="连通性和延时"></a>连通性和延时</h3><p>使用命令 ping，来测试远程主机的连通性和延时（基于 ICMP 协议）</p><p>如下，测试本机到 baidu.com 这个地址的连通性和延时</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$<span class="built_in"> ping </span>-c3 baidu.com<span class="built_in"></span></span><br><span class="line"><span class="built_in">PING </span>baidu.com (182.61.201.211) 56(84) bytes of data.</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=1 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=29.1 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=2 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=27.2 ms</span><br><span class="line">64 bytes <span class="keyword">from</span> 182.61.201.211 (182.61.201.211): <span class="attribute">icmp_seq</span>=3 <span class="attribute">ttl</span>=49 <span class="attribute">time</span>=27.8 ms</span><br><span class="line"></span><br><span class="line">--- baidu.com<span class="built_in"> ping </span>statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 27.280/28.097/29.158/0.785 ms</span><br></pre></td></tr></table></figure><p>ping 的输出，可以分为两部分：</p><ul><li>每个 ICMP 请求的信息，包括 ICMP 序列号（icmp_seq）、TTL（生存时间，或者跳数）以及往返延时</li><li>三次 ICMP 请求的汇总</li></ul><h2 id="C10K和C100K问题"><a href="#C10K和C100K问题" class="headerlink" title="C10K和C100K问题"></a>C10K和C100K问题</h2><h3 id="C10K"><a href="#C10K" class="headerlink" title="C10K"></a>C10K</h3><p>C10K 代表同时处理 10000 个请求</p><p>从资源上来说，对 2GB 内存和千兆网卡的服务器来说，同时处理 10000 个请求，只要每个请求处理占用不到 200KB（2GB/10000）的内存和 100Kbit（1000Mbit/10000）的网络带宽就可以。</p><p>从软件上来看，主要是网络 I/O 模型的问题，在 C10K 之前，Linux 主要是<strong>同步阻塞</strong>的方式，每个请求都分配一个进程或者线程，而 10000 个进程或者线程的调度、上下文切换和内存，都可能成为瓶颈。</p><p>需要解决的问题：</p><ul><li>怎样在一个线程内处理多个请求，也就是要在一个线程内响应多个网络 I/O？</li></ul><h4 id="I-O-模型优化"><a href="#I-O-模型优化" class="headerlink" title="I/O 模型优化"></a>I/O 模型优化</h4><p>异步、非阻塞 I/O 的思路：I/O 多路复用</p><blockquote><p>两种 I/O 时间通知的方式：水平触发和边缘触发<br>水平触发：只要文件描述符可以非阻塞地执行 I/O，就会触发通知。也就是说，应用程序可以随时检查文件描述符地状态，然后再根据状态，进行 I/O 操作。<br>边缘触发：只有在文件描述符的状态发生改变（也就是 I/O 请求达到）时，才会发送一次通知。这时候，应用程序需要尽可能多地执行 I/O，知道无法继续读写，才可以停止。如果 I/O 没执行完，或者因为某种原因没来得及处理，那么这次通知也就丢失了</p></blockquote><ul><li>第一种，使用非阻塞 I/O 和水平触发通知，比如使用 select 或者 poll</li><li>第二种，使用非阻塞 I/O 和边缘触发通知，比如 epoll（在 select 和 poll 基础上进行优化）</li><li>第三种，使用异步 I/O（Asynchronous I/O，简称为 AIO）</li></ul><h4 id="工作模型优化"><a href="#工作模型优化" class="headerlink" title="工作模型优化"></a>工作模型优化</h4><p>I/O 多路复用有两种主要的工作模式：</p><p><strong>第一种</strong>：主进程 + 多个 worker 子进程（比如 nginx），主要流程是：</p><ul><li>主进程执行 bind() + listen() 后，创建多个子进程；</li><li>在每个子进程中，都通过 accept() 或 epoll_wait() ，来处理相同的套接字</li></ul><p><img src="/img/2025-06-17-linux_tracing_network/image.png" alt="示意图"></p><p><strong>注意</strong>：accept() 和 epoll_wait() 调用，还存在一个<strong>惊群</strong>的问题（当网络 I/O 事件发生时，多个进程被同时唤醒，但实际上只有一个进程来响应这个事件，其他被唤醒的进程都会重新休眠）</p><p>为了避免<strong>惊群问题</strong>，Nginx 在每个 worker 进程中，都会增加一个全局锁（accept_mutex）。这些 worder 进程需要首先竞争到锁，只有竞争到锁的进程，才会加入到 epoll 中，这样就确保只有一个 worker 子进程被唤醒</p><p><strong>第二种</strong>：监听到相同端口的多进程模型，所有的进程都监听相同的端口，有各自的套接字，开启 SO_REUSEPORT 选项（Linux 3.9+ 才支持），由内核负责将请求负载均衡到这些监听进程中去</p><p><img src="/img/2025-06-17-linux_tracing_network/image2.png" alt="示意图"></p><h3 id="C1000K"><a href="#C1000K" class="headerlink" title="C1000K"></a>C1000K</h3><p>C1000K 代表同时 100w 个请求</p><ul><li>从物理资源上来说，100 万个请求需要大量的系统资源<ul><li>内存：假设每个请求需要 16KB 内存的化，那么总共就需要大约 15GB 内存</li><li>带宽：假设只有 20% 活跃连接，即使每个连接只需要 1KB/s 的吞吐量，总共需要 200000 * 8 / 1024 / 1024 = 1.6 Gb/s 的吞吐量，千兆网卡已经不能够满足，需要配置万兆网卡</li></ul></li><li>从软件资源上来说，大量的连接也会占用大量的软件资源，比如<strong>文件描述符的数据、连接状态的跟踪（CONNTRACK）、网络协议栈的缓存大小（比如套接字读写缓存、TCP 读写缓存）</strong>等等，也会带来<strong>大量的中断处理</strong></li></ul><p><strong>优化</strong>：在 I/O 多路复用的基础上，需要多队列网卡、硬中断负载均衡、CPU 绑定、RPS/RFS（软中断负载均衡到多个 CPU 核上），以及将网络包的处理卸载（Offload）到网络设备（如 TSO/GSO、LRO/GRO、VXLAN OFFLOAD）等各种硬件和软件的优化。</p><h3 id="C10M"><a href="#C10M" class="headerlink" title="C10M"></a>C10M</h3><p>同时有 1000w 个请求，解决方法是<strong>跳过内核协议栈</strong>，将网络包直接发送到要处理的应用程序</p><p>第一种机制：DPDK（Data Plane Development Kit），用户网络的标准，跳过内核协议栈，直接由用户态进程通过轮询的方式来处理网络请求</p><p><img src="/img/2025-06-17-linux_tracing_network/image3.png" alt="示意图"></p><p>第二种机制：XDP（eXpress Data Path），Linux 内核提供的一种高性能网络数据路径，它允许网络包，在进入内核协议栈之前，就进行处理</p><p><img src="/img/2025-06-17-linux_tracing_network/image4.png" alt="示意图"></p><h2 id="怎么评估系统的网络性能"><a href="#怎么评估系统的网络性能" class="headerlink" title="怎么评估系统的网络性能"></a>怎么评估系统的网络性能</h2><h3 id="各协议层的性能测试"><a href="#各协议层的性能测试" class="headerlink" title="各协议层的性能测试"></a>各协议层的性能测试</h3><h4 id="转发性能"><a href="#转发性能" class="headerlink" title="转发性能"></a>转发性能</h4><p>hping3 工具，测试网络包的处理能力：<a href="https://wangchujiang.com/linux-command/c/hping3.html"> hping3 手册 </a></p><h4 id="TCP-UDP-性能"><a href="#TCP-UDP-性能" class="headerlink" title="TCP/UDP 性能"></a>TCP/UDP 性能</h4><p>iperf 网络性能测试工具：<a href="https://wangchujiang.com/linux-command/c/iperf.html"> iperf 手册 </a></p><p>iperf3 是 iperf 的重写版本，一些常用参数：</p><table><thead><tr><th>主要参数</th><th>参数说明</th></tr></thead><tbody><tr><td>-s</td><td>服务端专用参数，表示 iperf3 以服务端模式运行</td></tr><tr><td>-c</td><td>客户端专用参数，表示 iperf3 以客户端模式运行</td></tr><tr><td>-i</td><td>设置每次报告之间的时间间隔，单位为秒</td></tr><tr><td>-p</td><td>服务端：指定服务端监听的端口，默认为 5201，同时监听 TCP/UDP。<br> 客户端：指定客户端连接服务端的端口，默认为 5201。如果同时有 -u 参数，表示通过 UDP 发起连接，否则默认使用 TCP 连接</td></tr><tr><td>-u</td><td>表示使用 UDP 协议发送报文。若不指定该参数则表示使用 TCP 协议</td></tr><tr><td>-l</td><td>设置读写缓冲区的长度。通常测试包转发性能时建议该值设为 16，测试带宽时建议该值设为 1400</td></tr><tr><td>-b</td><td>UDP 模式使用的带宽，单位 bit/s</td></tr><tr><td>-t</td><td>设置传输的总时间。iperf3 在指定时间内，重复发送指定长度数据包的时间，默认值为 10 秒</td></tr><tr><td>-A</td><td>设置 CPU 亲和性，可以将 iperf3 进程绑定对应编号的逻辑 CPU，避免 iperf3 进程在不同的 CPU 间被调度</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">本文介绍 Linux 网络性能指标、调优方法及 C10K/C1000K 问题的应对策略</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：I/O</title>
    <link href="https://wu3227834.github.io/2025/06/02/2025-06-02-linux-tracing-io/"/>
    <id>https://wu3227834.github.io/2025/06/02/2025-06-02-linux-tracing-io/</id>
    <published>2025-06-02T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统和磁盘的区别"><a href="#文件系统和磁盘的区别" class="headerlink" title="文件系统和磁盘的区别"></a>文件系统和磁盘的区别</h2><p>磁盘是一个存储设备（确切来说是块设备），可以划分为不同的磁盘分区。而在磁盘或者磁盘分区上，还可以在创建文件系统，并挂载到系统的某个目录。这样，系统就可以通过这个挂载目录，来读写文件。</p><p>换句话说，磁盘是存储数据的块设备，也是文件系统的载体。所以，文件系统确实还是要通过磁盘，来保证数据的持久化存储。</p><p><strong>Linux 中一切皆文件</strong>。可以通过相同的文件接口，来访问磁盘和文件（比如 open、read、write、close 等）</p><ul><li>通常说的“文件”，是指普通文件</li><li>磁盘和分区，是指块设备文件</li></ul><p>在读写普通文件时，I/O 请求会首先经过文件系统，然后由文件系统负责，来与磁盘进行交互。而读写块设备文件时，会跳过文件系统，直接与磁盘交互，也就是所谓的“裸 I/O”。文件系统管理的缓存，是 Cache 的一部分；而裸磁盘的缓存，用的正是 Buffer。</p><blockquote><p>裸磁盘，也称为原始磁盘，是一种未被任何文件系统（如NTFS、FAT32）格式化或管理的磁盘。换句话说，它是直接与磁盘硬件交互，而不通过操作系统的文件系统层进行访问。</p></blockquote><p>缓存 I/O 与直接 I/O（裸磁盘 I/O ）的对比</p><table><thead><tr><th>特性</th><th>缓存I/O（文件系统）</th><th>直接I/O（裸磁盘）</th></tr></thead><tbody><tr><td>数据流</td><td>磁盘 → 内核缓冲区 → 应用程序地址空间</td><td>磁盘 → 直接应用程序地址空间</td></tr><tr><td>缓存使用</td><td>使用文件系统管理的Cache</td><td>使用磁盘的Buffer</td></tr><tr><td>性能</td><td>适合常规文件操作，减少磁盘读写次数</td><td>适合高性能场景，如数据库，减少文件系统开销</td></tr><tr><td>应用场景</td><td>普通文件读写，系统默认方式</td><td>虚拟化、数据库优化、低级别磁盘操作</td></tr><tr><td>优点</td><td>保护系统安全，减少直接磁盘访问风险</td><td>降低数据复制开销，提高I/O效率</td></tr><tr><td>缺点</td><td>数据复制开销高，CPU和内存占用多</td><td>需要应用程序管理缓存，可能增加复杂性</td></tr></tbody></table><h2 id="Linux-文件系统如何工作"><a href="#Linux-文件系统如何工作" class="headerlink" title="Linux 文件系统如何工作"></a>Linux 文件系统如何工作</h2><h3 id="索引节点和目录项"><a href="#索引节点和目录项" class="headerlink" title="索引节点和目录项"></a>索引节点和目录项</h3><ul><li>索引节点（inode），和文件一一对应，存储在磁盘中，记录文件的元数据</li><li>目录项（dentry），记录文件的名字、索引节点以及其他目录项的关联关系</li></ul><p>举例说明，为文件创建的硬链接，会对应不同的目录项，他们都连接到同一个文件，索引节点相同。</p><p>磁盘的最小单位是<strong>扇区</strong>，文件系统将连续的扇区组成逻辑块，以逻辑块为最小单位，来读写磁盘数据。常见的逻辑块 4KB，由连续的 8 个扇区组成。</p><p><img src="/img/2025-06-02-linux_tracing_io/image.png" alt="示意图"></p><p>磁盘在执行文件系统格式化时，分为三个区域：超级块、索引节点和数据块：</p><ul><li>超级块：整个文件系统的状态</li><li>索引节点区：存储索引节点</li><li>数据块区：存储文件数据</li></ul><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><img src="/img/2025-06-02-linux_tracing_io/image2.png" alt="示意图"></p><p>文件系统分类：</p><ul><li>基于磁盘的文件系统：常见的 ext4、XFS、OverlayFS 等，都是这类文件系统</li><li>基于内存的文件系统：常说的虚拟文件系统，不需要磁盘空间，但是占用内存。比如，/proc 和 /sys</li><li>网络文件系统：用于访问其他计算机的文件系统，比如 NFS、SMB、ISCSI 等</li></ul><p><strong>注意</strong>：这些文件系统，要先挂载到 VFS 目录树中的某个子目录（称为<strong>挂载点</strong>），然后才能访问其中的文件。</p><h3 id="文件系统-I-O"><a href="#文件系统-I-O" class="headerlink" title="文件系统 I/O"></a>文件系统 I/O</h3><p>根据是否利用标准库缓存，分为<strong>缓冲 I/O 和非缓冲 I/O</strong>：</p><ul><li>缓存 I/O：利用标准库缓存，加速文件访问，标准库内部利用系统调用访问文件</li><li>非缓存 I/O：直接通过系统调用访问文件，不再经过标准库缓存</li></ul><p><strong>注意</strong>：这里的“缓冲”，是指<strong>标准库内部实现的缓存</strong>，最终还是需要通过系统调用，而系统调用还会通过<strong>页缓存</strong>，来较少磁盘的 I/O 操作</p><p>根据是否利用操作系统的<strong>页缓存</strong>，分为<strong>直接 I/O 和非直接 I/O</strong>：</p><ul><li>直接 I/O：跳过操作系统的页缓存，直接和<strong>文件系统</strong>交互来访问文件</li><li>非直接 I/O：先通过页缓存，再通过内核或者额外的系统调用，真正和磁盘交互（O_DIRECT 标志）</li></ul><p>根据应用程序是否阻塞自身，分为<strong>阻塞 I/O 和非阻塞 I/O</strong>：</p><ul><li>阻塞 I/O：是指应用程序执行 I/O 操作后，如果没有获得响应，就会阻塞当前线程</li><li>非阻塞 I/O：是指应用程序执行 I/O 操作后，不会阻塞当前的线程，可以继续执行其他的任务，随后再通过<strong>轮询或者事件通知</strong>的形式，获取调用的结果</li></ul><p>根据是否等待相应结果，分为<strong>同步 I/O 和异步 I/O</strong>：</p><ul><li>同步 I/O：应用程序执行 I/O 操作之后，要等到整个 I/O 完成后，才能获得 I/O 响应</li><li>异步 I/O：应用程序不用等待 I/O 完成，会继续执行，等到 I/O 执行完成，会以事件的方式通知应用程序</li></ul><p>设置 O_SYNC 或者 O_DSYNC，代表同步 I/O。如果是 O_DSYNC，要等到文件数据写入磁盘之后，才能返回，如果是 O_SYNC，是在 O_DSYNC 的基础上，要求文件<strong>元数据</strong>写入磁盘，才返回。</p><p>设置 O_ASYNC，代表异步 I/O，系统会再通过 SIGIO 或者 SIFPOLL 通知进程。</p><h3 id="性能观测"><a href="#性能观测" class="headerlink" title="性能观测"></a>性能观测</h3><h4 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h4><p>df 命令查看磁盘空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">df</span> -h /dev/vdb</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vdb        400G   95G  306G  24% /var/lib/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引节点所占的空间</span></span><br><span class="line">$ <span class="built_in">df</span> -i /dev/vdb</span><br><span class="line">Filesystem        Inodes  IUsed     IFree IUse% Mounted on</span><br><span class="line">/dev/vdb       209715200 546727 209168473    1% /var/lib/docker</span><br></pre></td></tr></table></figure><p>当索引节点空间不足，但是索引空间充足时，可能是过多小文件导致的。<strong>解决方法</strong>一般是删除这些小文件，或者移动到索引节点充足的其他磁盘区。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>可以使用 free 或者 vmstat，观察页缓存的大小；也可以查看 /proc/meminfo</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat <span class="keyword">/proc/</span>meminfo | grep -E <span class="string">&quot;SReclaimable|Cached&quot;</span></span><br><span class="line"><span class="symbol">Cached:</span>          <span class="number">3987272</span> kB</span><br><span class="line"><span class="symbol">SwapCached:</span>       <span class="number">109532</span> kB</span><br><span class="line"><span class="symbol">SReclaimable:</span>    <span class="number">4095228</span> kB</span><br></pre></td></tr></table></figure><p>内核使用 slab 机制，管理目录项和索引节点的缓存，/proc/meminfo 给出了整体的 slab 大小，/proc/slabinfo 可以查看每一种 slab 的缓存</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@pudding-160 ~]<span class="comment"># cat /proc/slabinfo | grep -E &#x27;^#|dentry|inode&#x27;</span></span><br><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;limit&gt; &lt;batchcount&gt; &lt;sharedfactor&gt; : slabdata &lt;active_slabs&gt; &lt;num_slabs&gt; &lt;sharedavail&gt;</span></span><br><span class="line">fuse_inode          <span class="number"> 189 </span>  <span class="number"> 189 </span>  <span class="number"> 768 </span> <span class="number"> 21 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 9 </span>    <span class="number"> 9 </span>     0</span><br><span class="line">ovl_inode         <span class="number"> 11534 </span><span class="number"> 15600 </span>  <span class="number"> 680 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 650 </span>  <span class="number"> 650 </span>     0</span><br><span class="line">xfs_inode        <span class="number"> 175054 </span>175372   <span class="number"> 960 </span> <span class="number"> 34 </span>  <span class="number"> 8 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 5158 </span> <span class="number"> 5158 </span>     0</span><br><span class="line">mqueue_inode_cache   <span class="number"> 288 </span>  <span class="number"> 288 </span>  <span class="number"> 896 </span> <span class="number"> 36 </span>  <span class="number"> 8 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 8 </span>    <span class="number"> 8 </span>     0</span><br><span class="line">hugetlbfs_inode_cache    <span class="number"> 52 </span>   <span class="number"> 52 </span>  <span class="number"> 608 </span> <span class="number"> 26 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata     <span class="number"> 2 </span>    <span class="number"> 2 </span>     0</span><br><span class="line">sock_inode_cache   <span class="number"> 2255 </span> <span class="number"> 2475 </span>  <span class="number"> 640 </span> <span class="number"> 25 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata    <span class="number"> 99 </span>   <span class="number"> 99 </span>     0</span><br><span class="line">shmem_inode_cache  <span class="number"> 6783 </span> <span class="number"> 7056 </span>  <span class="number"> 680 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 294 </span>  <span class="number"> 294 </span>     0</span><br><span class="line">proc_inode_cache  <span class="number"> 28816 </span><span class="number"> 29688 </span>  <span class="number"> 656 </span> <span class="number"> 24 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 1237 </span> <span class="number"> 1237 </span>     0</span><br><span class="line">inode_cache       <span class="number"> 34463 </span><span class="number"> 35208 </span>  <span class="number"> 592 </span> <span class="number"> 27 </span>  <span class="number"> 4 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata  <span class="number"> 1304 </span> <span class="number"> 1304 </span>     0</span><br><span class="line">dentry           <span class="number"> 20014134 </span>20014134   <span class="number"> 192 </span> <span class="number"> 21 </span>  <span class="number"> 1 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata<span class="number"> 953054 </span>953054      0</span><br><span class="line">selinux_inode_security <span class="number"> 15708 </span><span class="number"> 15708 </span>   <span class="number"> 40 </span><span class="number"> 102 </span>  <span class="number"> 1 </span>: tunables   <span class="number"> 0 </span>  <span class="number"> 0 </span>  <span class="number"> 0 </span>: slabdata   <span class="number"> 154 </span>  <span class="number"> 154 </span>     0</span><br></pre></td></tr></table></figure><p>其中 dentry 代表目录项缓存，inode_cache 代表 VFS 索引节点缓存，其他的就是各种文件系统的索引节点缓存。</p><p>实际性能分析中，更常使用 slabtop 命令，来找出占用内存最多的缓存类型。</p><p>示例如下：可以看到，目录项占用了最多的 Slab 缓存，大约 3.91 G</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按下c按照缓存大小排序，按下a按照活跃对象数排序 </span></span><br><span class="line">$ slabtop</span><br><span class="line"> Active / Total Objects (% used)    :<span class="number"> 22757396 </span>/<span class="number"> 23018218 </span>(98.9%)</span><br><span class="line"> Active / Total Slabs (% used)      :<span class="number"> 1067320 </span>/<span class="number"> 1067320 </span>(100.0%)</span><br><span class="line"> Active / Total Caches (% used)     :<span class="number"> 72 </span>/<span class="number"> 103 </span>(69.9%)</span><br><span class="line"> Active / Total Size (% used)       : 4462258.28K / 4545420.86K (98.2%)</span><br><span class="line"> Minimum / Average / Maximum Object : 0.01K / 0.20K / 8.00K</span><br><span class="line"></span><br><span class="line">  OBJS ACTIVE  USE OBJ SIZE  SLABS OBJ/SLAB CACHE SIZE NAME</span><br><span class="line">21574896<span class="number"> 21574735 </span> 99%    0.19K<span class="number"> 1027376 </span>     <span class="number"> 21 </span>  4109504K dentry</span><br><span class="line">355914<span class="number"> 286236 </span> 80%    0.10K  <span class="number"> 9126 </span>     <span class="number"> 39 </span>    36504K buffer_head</span><br><span class="line">223872<span class="number"> 205323 </span> 91%    0.06K  <span class="number"> 3498 </span>     <span class="number"> 64 </span>    13992K kmalloc-64</span><br><span class="line">175372<span class="number"> 175125 </span> 99%    0.94K  <span class="number"> 5158 </span>     <span class="number"> 34 </span>   165056K xfs_inode</span><br><span class="line"><span class="number"> 57600 </span><span class="number"> 57529 </span> 99%    0.16K  <span class="number"> 2400 </span>     <span class="number"> 24 </span>     9600K xfs_ili</span><br><span class="line">136528 <span class="number"> 53170 </span> 38%    0.57K  <span class="number"> 4876 </span>     <span class="number"> 28 </span>    78016K radix_tree_node</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Linux-磁盘-I-O-工作原理"><a href="#Linux-磁盘-I-O-工作原理" class="headerlink" title="Linux 磁盘 I/O 工作原理"></a>Linux 磁盘 I/O 工作原理</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><p>根据存储介质，磁盘分为：</p><ul><li>机械磁盘，也称为硬盘驱动器（Hard Disk Driver），通常缩写为 HDD。机械磁盘主要有盘片和读写磁头组成，数据就存储在盘片的环状磁道中。在读写数据前，需要移动读写磁头，定位数据所在的磁道，才能访问数据。如果 I/O 请求刚好连续，就不需要磁道寻址，可以获得最佳性能。这就是连续 I/O 的工作原理。与之对应的是随机 I/O，它需要不停地移动磁头，来定位数据位置，读写速度就会比较慢。</li><li>固态磁盘（Silid State Disk），通常缩写为 SSD，由固态电子元件组成。固态磁盘不需要磁盘寻址，不管是连续 I/O，还是随机 I/O 的性能，都比机械磁盘要好得多。</li></ul><p>无论是机械磁盘，还是固态磁盘，相同磁盘的随机 I/O 都要比连续 I/O 慢得多，原因是：</p><ul><li>随机 I/O 需要更多的磁头寻道和盘片旋转，它的性能自然要比连续 I/O 慢</li><li>对于固态硬盘来说，虽然它的随机性能比机械磁盘好很多，但同样存在“先擦除再写入”的限制。随机读写会导致大量的垃圾回收，所以相对应的，随机 I/O 的性能比起连续 I/O 来，也还差了很多</li><li>连续 I/O 还可以通过预读的方式，来减少 I/O 请求的次数，这也是其性能优异的一个原因</li></ul><p>最小读写单位：</p><ul><li>机械硬盘的最小读写单位是扇区，一般是 512 字节</li><li>固态硬盘的最小读写单位是页，一般是 4KB 或者 8KB</li></ul><p>按照接口，磁盘可分为 IDE（Integrated Drive Electronics）、SCSI（Small Computer System Interface） 、SAS（Serial Attached SCSI） 、SATA（Serial ATA） 、FC（Fibre Channel）等。</p><p>磁盘介入服务器时，按照不通的使用方式，会划分为不用的架构：</p><ul><li>最简单的直接作为独立磁盘设备来使用</li><li>将多块磁盘组合成一个逻辑磁盘，构成冗余独立磁盘阵列（RAID），提高数据访问的性能，并增强数据存储的可靠性</li><li>最后一种，是将磁盘组合成网络存储集群，再通过 NFS、SMB、ISCSI 等网络存储协议，暴露给服务器使用</li></ul><p>在 Linux 中，磁盘是作为一个块设备来管理，以块为单位来读写，支持随机读写。每个块设备赋予两个设备号，分别是主、次设备号，主设备号用在驱动程序中，用来区分设备类型；次设备号用来在多个同类设备编号。</p><h3 id="通用块层"><a href="#通用块层" class="headerlink" title="通用块层"></a>通用块层</h3><p>和 VFS 类似，为了减少不同设备的差异带来的影响，Linux 通过统一的通用块（块 I/O 层），管理不同的块设备。</p><p>块设备层是处在文件系统和磁盘驱动中间的一个块设备抽象层，主要功能是：</p><ul><li>向上为文件系统和应用程序提供访问块设备的标准接口；向下，把各种异构的磁盘块设备抽象为统一的块设备，提供统一框架管理这些设备的驱动程序</li><li>通用块层还会给文件系统和应用程序发来 I/O 请求排队，并通过重新排序、请求合并等方式，提高磁盘读写的效率</li></ul><p>对 I/O 请求排序的过程就是 I/0 调度，Linux 支持的四种 I/O 调度算法，分别是 NONE、NOOP、CFQ 以及 DeadLine：</p><ul><li>NONE，不适用任何调度，对 I/O 不做任何处理（常用在虚拟机，此时磁盘 I/O 完全由物理机复杂）</li><li>NOOP，先入先出调度（常用在 SSD）</li><li>CFQ（Completely Fair Schedule）完全公平调度器，很多 Linux 发行版的默认调度器，它为每个进程维护了一个 I/O 调度队列，按照时间片来均匀分配每个进程的 I/O 请求；还支持优先级调度，适用于大量进程的系统（如桌面、多媒体应用等）</li><li>DeadLine 调度算法，分别为读、写请求创建了不同的 I/O 队列，可以提高机械磁盘的吞吐量，并确保打到最终期限（deadline）的请求被优化处理，多用在 I/O 压力比较重的场景，比如数据库等</li></ul><h3 id="I-O-栈"><a href="#I-O-栈" class="headerlink" title="I/O 栈"></a>I/O 栈</h3><p><img src="/img/2025-06-02-linux_tracing_io/image3.png" alt="示意图"></p><p>根据这张 I/O 栈的全景图，可以看出存储系统 I/O 的工作原理</p><ul><li>文件系统层，包括虚拟文件系统和其他文件系统的具体实现。它为上层的应用程序，提供标准的文件访问接口；对下会通过快层，来存储和管理磁盘资源</li><li>通用块层，包括块设备 I/O 队列和 I/O 调度器。他会对文件系统的 I/O 请求进行排队，再通过重新排序和请求合并，然后才要发给下一级的设备层</li><li>设备层，包括存储设备和相应的驱动程序，负责最终物理设备的 I/O 操作</li></ul><p>存储系统的 I/O，通常是整个系统最慢的一环。</p><p>Linux 通过多种缓存机制来优化 I/O 效率。为了优化文件访问的性能，会使用页缓存、索引节点缓存等多种机制，以减少对下层块设配的直接调用。同样，为了优化块设备，会使用缓冲区，来缓存块设备的数据。</p><h3 id="磁盘性能指标"><a href="#磁盘性能指标" class="headerlink" title="磁盘性能指标"></a>磁盘性能指标</h3><p>使用率、饱和度、IOPS、吞吐量以及响应时间五个指标，是磁盘性能的基本指标</p><ul><li>使用率，是指磁盘处理 I/O 的时间百分比。过高的使用率（比如超过 80%），通常意味着磁盘 I/O 存在性能瓶颈</li><li>饱和度，是指磁盘处理 I/O 的繁忙程度。过高的饱和度，意味着存在严重的性能瓶颈。当饱和度为 100% 时，磁盘无法接受新的 I/O 请求</li><li>IOPS（Input/Output Per Second），是指每秒的 I/O 请求数</li><li>吞吐量，是指每秒 I/O 请求大小</li><li>响应时间，是指 I/O 请求从发出到收到响应的间隔时间</li></ul><p>注意：</p><ol><li>使用率只考虑有没有 I/O，而不考虑 I/O 的大小。换句话说，当使用率是 100% 的时候，磁盘依然有可能接受到新的 I/O 请求</li><li>随即读写多（如数据库、大量小文件）的情况下主要关注 IOPS，而顺序读写（如流媒体）的情况下，主要关注吞吐量</li></ol><p>在为应用程序的服务器选型时，要先对磁盘的 I/O 性能进行基准测试，以便可以准确评估，磁盘性能是否可以满足应用程序的需求</p><h3 id="磁盘-I-O-观测"><a href="#磁盘-I-O-观测" class="headerlink" title="磁盘 I/O 观测"></a>磁盘 I/O 观测</h3><p>使用 iostat 观测每块磁盘的使用情况，提供了每个磁盘的使用率、IOPS、吞吐量等各种常见的性能指标，这些指标实际上来自 /proc/diskstats</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ iostat <span class="operator">-</span>dx <span class="number">1</span></span><br><span class="line">Linux <span class="number">3.10</span>.<span class="number">0</span><span class="operator">-</span><span class="number">1160.76</span>.<span class="number">1</span>.el7.x86_64 (idc16)       <span class="number">2025</span>年<span class="number">06</span>月<span class="number">16</span>日  _x86_64_        (<span class="number">40</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="params">Device:</span>         rrqm<span class="symbol">/s</span>   wrqm<span class="symbol">/s</span>     r<span class="symbol">/s</span>     w<span class="symbol">/s</span>    rkB<span class="symbol">/s</span>    wkB<span class="symbol">/s</span> avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br><span class="line">sda               <span class="number">0.00</span>     <span class="number">0.69</span>    <span class="number">1.56</span>   <span class="number">25.12</span>    <span class="number">62.56</span>   <span class="number">270.97</span>    <span class="number">25.01</span>     <span class="number">0.27</span>   <span class="number">10.01</span>    <span class="number">0.84</span>   <span class="number">10.58</span>   <span class="number">1.18</span>   <span class="number">3.14</span></span><br><span class="line">sdd               <span class="number">0.00</span>     <span class="number">0.27</span>    <span class="number">0.17</span>    <span class="number">1.33</span>    <span class="number">10.66</span>    <span class="number">42.08</span>    <span class="number">70.12</span>     <span class="number">0.01</span>    <span class="number">8.48</span>    <span class="number">6.95</span>    <span class="number">8.68</span>   <span class="number">0.26</span>   <span class="number">0.04</span></span><br><span class="line">sdc               <span class="number">0.00</span>     <span class="number">0.61</span>    <span class="number">0.27</span>    <span class="number">9.80</span>    <span class="number">13.02</span>   <span class="number">193.43</span>    <span class="number">41.03</span>     <span class="number">0.04</span>    <span class="number">3.52</span>    <span class="number">0.82</span>    <span class="number">3.59</span>   <span class="number">0.06</span>   <span class="number">0.06</span></span><br><span class="line">sde               <span class="number">0.00</span>     <span class="number">0.22</span>    <span class="number">0.21</span>    <span class="number">1.38</span>    <span class="number">11.79</span>    <span class="number">43.80</span>    <span class="number">70.07</span>     <span class="number">0.01</span>    <span class="number">8.43</span>    <span class="number">7.23</span>    <span class="number">8.61</span>   <span class="number">0.26</span>   <span class="number">0.04</span></span><br><span class="line">sdf               <span class="number">0.00</span>     <span class="number">0.24</span>    <span class="number">0.07</span>    <span class="number">1.29</span>    <span class="number">13.02</span>    <span class="number">18.95</span>    <span class="number">47.09</span>     <span class="number">0.00</span>    <span class="number">3.29</span>   <span class="number">17.06</span>    <span class="number">2.56</span>   <span class="number">0.20</span>   <span class="number">0.03</span></span><br><span class="line">sdh               <span class="number">0.00</span>     <span class="number">0.26</span>    <span class="number">0.01</span>    <span class="number">1.32</span>     <span class="number">1.49</span>    <span class="number">19.72</span>    <span class="number">31.78</span>     <span class="number">0.00</span>    <span class="number">1.70</span>    <span class="number">9.23</span>    <span class="number">1.63</span>   <span class="number">0.09</span>   <span class="number">0.01</span></span><br><span class="line">sdg               <span class="number">0.00</span>     <span class="number">0.23</span>    <span class="number">0.05</span>    <span class="number">1.30</span>    <span class="number">11.18</span>    <span class="number">21.33</span>    <span class="number">48.10</span>     <span class="number">0.01</span>    <span class="number">4.07</span>   <span class="number">24.12</span>    <span class="number">3.28</span>   <span class="number">0.21</span>   <span class="number">0.03</span></span><br><span class="line">sdi               <span class="number">0.00</span>     <span class="number">0.28</span>    <span class="number">0.04</span>    <span class="number">1.67</span>     <span class="number">9.65</span>    <span class="number">19.50</span>    <span class="number">33.96</span>     <span class="number">0.00</span>    <span class="number">1.86</span>   <span class="number">25.33</span>    <span class="number">1.26</span>   <span class="number">0.15</span>   <span class="number">0.03</span></span><br><span class="line">sdj               <span class="number">0.00</span>     <span class="number">0.24</span>    <span class="number">0.36</span>    <span class="number">2.35</span>    <span class="number">21.61</span>   <span class="number">247.35</span>   <span class="number">198.58</span>     <span class="number">0.14</span>   <span class="number">51.46</span>    <span class="number">4.47</span>   <span class="number">58.60</span>   <span class="number">0.49</span>   <span class="number">0.13</span></span><br><span class="line">sdb               <span class="number">0.00</span>     <span class="number">0.46</span>    <span class="number">1.66</span>    <span class="number">8.00</span>   <span class="number">180.35</span>   <span class="number">210.13</span>    <span class="number">80.81</span>     <span class="number">0.08</span>    <span class="number">8.74</span>    <span class="number">2.84</span>    <span class="number">9.97</span>   <span class="number">0.20</span>   <span class="number">0.19</span></span><br><span class="line">dm-<span class="number">0</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.85</span>   <span class="number">18.11</span>    <span class="number">38.11</span>   <span class="number">144.32</span>    <span class="number">19.24</span>     <span class="number">0.17</span>    <span class="number">8.82</span>    <span class="number">0.56</span>    <span class="number">9.21</span>   <span class="number">1.14</span>   <span class="number">2.16</span></span><br><span class="line">dm-<span class="number">1</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">49.16</span>     <span class="number">0.00</span>   <span class="number">11.10</span>   <span class="number">11.10</span>    <span class="number">0.00</span>   <span class="number">9.62</span>   <span class="number">0.00</span></span><br><span class="line">scd0              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.00</span>     <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">80.31</span>     <span class="number">0.00</span>  <span class="number">813.35</span>  <span class="number">813.35</span>    <span class="number">0.00</span> <span class="number">809.27</span>   <span class="number">0.00</span></span><br><span class="line">dm-<span class="number">2</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.00</span>    <span class="number">0.21</span>     <span class="number">0.04</span>    <span class="number">16.16</span>   <span class="number">155.78</span>     <span class="number">0.02</span>   <span class="number">99.54</span>    <span class="number">2.63</span>  <span class="number">100.60</span>   <span class="number">1.79</span>   <span class="number">0.04</span></span><br><span class="line">dm-<span class="number">3</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.68</span>    <span class="number">4.54</span>    <span class="number">22.80</span>    <span class="number">72.63</span>    <span class="number">36.54</span>     <span class="number">0.07</span>   <span class="number">14.35</span>    <span class="number">1.04</span>   <span class="number">16.35</span>   <span class="number">1.31</span>   <span class="number">0.69</span></span><br><span class="line">dm-<span class="number">4</span>              <span class="number">0.00</span>     <span class="number">0.00</span>    <span class="number">0.02</span>    <span class="number">2.93</span>     <span class="number">0.38</span>    <span class="number">37.73</span>    <span class="number">25.90</span>     <span class="number">0.03</span>   <span class="number">10.70</span>    <span class="number">4.72</span>   <span class="number">10.73</span>   <span class="number">1.32</span>   <span class="number">0.39</span></span><br></pre></td></tr></table></figure><p>各个指标解读如下</p><p><img src="/img/2025-06-02-linux_tracing_io/image4.png" alt="iostat 指标解读图"></p><p>注意：</p><ul><li>%util，就是我们前面提到的磁盘 I/O 使用率</li><li>r/s + w/s，就是 IOPS</li><li>rkB/s + wkB/s，就是吞吐量</li><li>r_await+w_await，就是响应时间</li></ul><p>在观测指标时，可以结合请求的大小（rareq-sz 和 wareq-sz）一起分析。</p><h3 id="进程-I-O-观测"><a href="#进程-I-O-观测" class="headerlink" title="进程 I/O 观测"></a>进程 I/O 观测</h3><p>pidstat 可以实时查看某个进程的 I/O 情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -d 1</span><br><span class="line">Linux 3.10.0-957.el7.x86_64 (xxx)       06/17/2025      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">07:12:18 PM   UID       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command</span><br><span class="line">07:12:19 PM   <span class="number"> 27 </span>  <span class="number"> 362006 </span>     0.00    594.17    590.29  mysqld</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362323 </span>     0.00      3.88      3.88  docker-containe</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362403 </span>     0.00      7.77      0.00  kundb-meta-serv</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 362518 </span>     0.00      3.88      0.00  java</span><br><span class="line">07:12:19 PM<span class="number"> 65534 </span>  <span class="number"> 363123 </span>     0.00      3.88      0.00  prometheus</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 372218 </span>     0.00      7.77      0.00  java</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 383196 </span>     0.00     19.42      0.00  dockerd</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 389626 </span>     0.00     23.30      0.00  kube-apiserver</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 389731 </span>     0.00     62.14      0.00  etcd</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 391157 </span>     0.00     11.65      0.00  kubelet</span><br><span class="line">07:12:19 PM    <span class="number"> 0 </span>  <span class="number"> 760300 </span>     0.00     11.65      0.00  kundb-meta-serv</span><br></pre></td></tr></table></figure><p>指标如下：</p><ul><li>用户 ID（UID）和进程 ID（PID）</li><li>每秒读取的数据大小（kB_rd/s），单位是 KB</li><li>每秒发出的写请求数据大小（kB_wr/s），单位是 KB</li><li>每秒取消的写请求数据大小（KB_ccwr/s），单位是 KB</li></ul>]]></content>
    
    
    <summary type="html">本文深入探讨Linux文件系统与磁盘I/O的工作原理，分析缓存I/O与直接I/O的差异，详解索引节点、虚拟文件系统及I/O调度算法，并提供df、iostat等工具的性能观测方法，助力系统性能调优。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何“快准狠”找到系统内存的问题</title>
    <link href="https://wu3227834.github.io/2025/05/30/2025-05-30-ru-he-kuai-zhun-hen-de-zhao-dao-xi-tong-nei-cun-wen-ti/"/>
    <id>https://wu3227834.github.io/2025/05/30/2025-05-30-ru-he-kuai-zhun-hen-de-zhao-dao-xi-tong-nei-cun-wen-ti/</id>
    <published>2025-05-30T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存性能指标"><a href="#内存性能指标" class="headerlink" title="内存性能指标"></a>内存性能指标</h2><p>系统调用内存分配请求后，并不会立刻为其分配物理内存，而是在请求首次访问时，通过缺页异常来分配</p><p>缺页异常又分为以下两种场景：</p><ul><li>可以直接从物理内存中分配时，被称为<strong>次缺页异常</strong></li><li>需要磁盘 I/O 介入（比如 Swap）时，被称为<strong>主缺页异常</strong></li></ul><p><img src="/img/2025-05-30-%E5%A6%82%E4%BD%95%E5%BF%AB%E5%87%86%E7%8B%A0%E7%9A%84%E6%89%BE%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/image.png" alt="内存性能指标"></p><h2 id="分析内存性能瓶颈"><a href="#分析内存性能瓶颈" class="headerlink" title="分析内存性能瓶颈"></a>分析内存性能瓶颈</h2><p>分析过程如下图</p><ul><li>先用 free 和 top，查看系统整体的内存使用情况</li><li>再用 vmstat 和 pidstat，查看一段时间的趋势，从而判断出内存问题的类型</li><li>最后进行详细分析，比如内存分配分析、缓存/缓冲区分析、具体进程的内存使用分析等</li></ul><p><img src="/img/2025-05-30-%E5%A6%82%E4%BD%95%E5%BF%AB%E5%87%86%E7%8B%A0%E7%9A%84%E6%89%BE%E5%88%B0%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98/image2.png" alt="分析内存性能"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>内存常见的优化思路有这么几种</p><ul><li>最好禁止 Swap。如果必须开启 Swap，降低 swappiness 的值，减少内存回收时 Swap 的使用倾向</li><li>减少内存的动态分配。比如，可以使用内存池、大页（HugePage）等</li><li>尽量使用缓存和缓冲区来访问数据。比如，可以使用堆栈明确声明内存空间，来存储需要缓存的数据；或者用 Redis 这类的外部缓存组件，优化数据的访问</li><li>使用 cgroups 等方式限制进程的内存使用情况。这样，可以确保系统内存不会被异常进程耗尽</li><li>通过 /proc/pid/oom_adj，调整核心应用的 oom_score。这样，可以保证即使内存紧张，核心应用也不会被 OOM 杀死</li></ul>]]></content>
    
    
    <summary type="html">本文介绍如何通过工具快速定位 Linux 系统内存瓶颈并提供优化建议</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：内存</title>
    <link href="https://wu3227834.github.io/2025/05/28/2025-05-28-linux-tracing-mem/"/>
    <id>https://wu3227834.github.io/2025/05/28/2025-05-28-linux-tracing-mem/</id>
    <published>2025-05-28T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux内存工作原理"><a href="#Linux内存工作原理" class="headerlink" title="Linux内存工作原理"></a>Linux内存工作原理</h2><h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。</p><p>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。</p><p>对大块内存（大于 128K），则使用内存映射 mmap() 来分配，也就是在文件映射找一块空闲内存分配出去。</p><p>各自的<strong>优缺点</strong>：</p><ul><li>brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率；不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片</li><li>mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大</li></ul><p>整体来说，Linux 使用<strong>伙伴系统</strong>来管理内存分配。前面我们提到过，这些内存在 MMU 中以页为单位进行管理，伙伴系统也一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如 brk 方法造成的内存碎片）。</p><p>在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 通过 slab 分配器来管理小内存，可以把 slab 堪称构建在<strong>伙伴系统上的一个缓存</strong>，主要作用就是分配并释放内核中的小对象。</p><p>系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统会通过一系列机制来回收内存：</p><ul><li>回收内存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面</li><li>回收不常访问的内存，把不常用的内存交换分区直接写到磁盘中（会用到交换分区）</li><li>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程</li></ul><p>OOM 是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：</p><ul><li>进程消耗的内存越大，oom_score 就越大</li><li>进程运行占用的 CPU 越多，oom_score 就越小</li></ul><p>可以手动设置进程的 oom_adj 来调整 oom_score。oom_adj 的范围是 [-17, 15]，数值越大，进程越容易被杀死；反之，越不容易被杀死。</p><h3 id="如何查看内存使用情况"><a href="#如何查看内存使用情况" class="headerlink" title="如何查看内存使用情况"></a>如何查看内存使用情况</h3><p>1、free 命令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:     <span class="number"> 262695500 </span> <span class="number"> 106731876 </span> <span class="number"> 141173212 </span>   <span class="number"> 4257008 </span>  <span class="number"> 14790412 </span>  149168720</span><br><span class="line">Swap:            <span class="number"> 0 </span>         <span class="number"> 0 </span>          0</span><br></pre></td></tr></table></figure><ul><li>total：总内存</li><li>used：已使用内存，包括共享内存</li><li>free：空闲内存</li><li>shared：共享内存</li><li>buff/cache：缓存内存，包括缓冲区和缓存</li><li>available：可用内存，包括空闲内存和缓存内存</li></ul><p><strong>注意</strong>：available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>2、top 命令</p><p>可以查看每个进程的内存使用情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top - 19:28:02 up<span class="number"> 201 </span>days,  2:48, <span class="number"> 2 </span>users,  load average: 134.36, 136.81, 111.38</span><br><span class="line">Tasks:<span class="number"> 1284 </span>total,  <span class="number"> 6 </span>running,<span class="number"> 1278 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s): 87.2 us,  8.9 sy,  0.0 ni,  0.9 id,  0.0 wa,  1.8 hi,  1.1 si,  0.0 st</span><br><span class="line">MiB Mem : 256538.6 total, 137892.3 free, 104201.3 used,  14445.0 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used. 145701.9 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number"> 607070 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> 266.3g  82.5g <span class="number"> 79228 </span>S <span class="number"> 4861 </span> 33.0  40025:32 tabletserver_ma</span><br><span class="line"><span class="number"> 835494 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>8557368<span class="number"> 207048 </span><span class="number"> 10872 </span>S 121.7   0.1 357:04.40 java</span><br><span class="line"><span class="number"> 842048 </span>1001     <span class="number"> 20 </span> <span class="number"> 0 </span>  32.8g <span class="number"> 31168 </span><span class="number"> 14888 </span>S 113.0   0.0   0:03.41 java</span><br><span class="line"><span class="number"> 840498 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 727932 </span><span class="number"> 31336 </span> <span class="number"> 7304 </span>R  91.3   0.0   2164:46 node_exporter</span><br><span class="line"><span class="number"> 653917 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>  12.3g<span class="number"> 997944 </span><span class="number"> 46948 </span>S  78.3   0.4  15877:42 kubelet</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>VIRT：虚拟内存，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内</li><li>RES：实际内存，也就是进程<strong>实际使用的物理内存</strong>大小，但<strong>不包括 Swap 和共享内存</strong></li><li>SHR：共享内存，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等</li><li>%MEM：进程占用的物理内存占系统总内存的百分比</li></ul><p><strong>注意</strong>：</p><ul><li>虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都大于实际内存，这是因为虚拟内存是进程申请的内存，即使进程没有真正分配物理内存，也会计算在内。</li><li>共享内存 SHR 并不一定是共享的，比方说，<strong>程序的代码段、非共享的动态内存链接库</strong>，也都在 SHR 里。SHR 也包括了<strong>进程间真正共享的内存</strong>。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果</li></ul><h2 id="内存的-Buffer-和-Cache"><a href="#内存的-Buffer-和-Cache" class="headerlink" title="内存的 Buffer 和 Cache"></a>内存的 Buffer 和 Cache</h2><h3 id="free-的数据来源"><a href="#free-的数据来源" class="headerlink" title="free 的数据来源"></a>free 的数据来源</h3><p>man free 查看</p><p><img src="/img/2025-05-28-linux_tracing_mem/image.png" alt="man free"></p><p>从手册看到：</p><ul><li>Buffers：Memory used by kernel buffers (Buffers in /proc/meminfo)</li><li>Cache：Memory used by the page cache and slabs (Cached and Slab in /proc/meminfo)</li></ul><h3 id="proc-文件系统"><a href="#proc-文件系统" class="headerlink" title="proc 文件系统"></a>proc 文件系统</h3><p>man proc 查看</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Buffers %lu</span><br><span class="line">       Relatively temporary storage <span class="keyword">for</span> raw disk blocks <span class="keyword">that</span> shouldn&#x27;t <span class="keyword">get</span> tremendously large (<span class="number">20</span>MB <span class="keyword">or</span> so).</span><br><span class="line"></span><br><span class="line">Cached %lu</span><br><span class="line">       In-memory cache <span class="keyword">for</span> files <span class="built_in">read</span> <span class="keyword">from</span> <span class="keyword">the</span> disk (<span class="keyword">the</span> page cache).  Doesn&#x27;t include SwapCached.</span><br><span class="line">...</span><br><span class="line">SReclaimable %lu (<span class="keyword">since</span> Linux <span class="number">2.6</span><span class="number">.19</span>)</span><br><span class="line">       Part <span class="keyword">of</span> Slab, <span class="keyword">that</span> might be reclaimed, such <span class="keyword">as</span> caches.</span><br><span class="line"></span><br><span class="line">SUnreclaim %lu (<span class="keyword">since</span> Linux <span class="number">2.6</span><span class="number">.19</span>)</span><br><span class="line">       Part <span class="keyword">of</span> Slab, <span class="keyword">that</span> cannot be reclaimed <span class="keyword">on</span> memory pressure.</span><br></pre></td></tr></table></figure><p>通过文档可以看到：</p><ul><li>Buffers 是对原始磁盘的临时存储，也就是用来缓存磁盘的数据，通常不会特别大（20MB 左右）。这样，内核就可以把分散的写集中起来，统一优化磁盘的写入，比如可以把多次小的写入合并成单次大的写等等。</li><li>Cached 是从单磁盘读取文件的页缓存，也就是用来缓存从文件读取的数据。这样，下次访问这些文件数据时，就可以直接从内存中快速获取，而不需要再次访问缓慢的磁盘。</li><li>Slab 代表内核数据结构缓存，包括两部分，其中的可回收部分，用 SReclaimable 记录；而不可回收部分，用 SUnreclaim 记录。</li></ul><h2 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h2><h3 id="场景一：磁盘和文件写"><a href="#场景一：磁盘和文件写" class="headerlink" title="场景一：磁盘和文件写"></a>场景一：磁盘和文件写</h3><p>运行 vmstat 命令</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16790772</span>     <span class="number">60 8758252</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218088</span> <span class="number">16779960</span>     <span class="number">60 8762060</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">159 15274</span> <span class="number">28820 16</span>  <span class="number">9</span> <span class="number">75</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">16779968</span>     <span class="number">60 8761840</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">154 13467</span> <span class="number">26984</span>  <span class="number">9</span>  <span class="number">4</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16778620</span>     <span class="number">60 8762068</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">212 13980</span> <span class="number">26715</span>  <span class="number">6</span>  <span class="number">5</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">0 1218088</span> <span class="number">16773376</span>     <span class="number">60 8762136</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">170 12838</span> <span class="number">25315</span>  <span class="number">4</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">16780544</span>     <span class="number">60 8762164</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">343 13195</span> <span class="number">25313</span>  <span class="number">5</span>  <span class="number">4</span> <span class="number">91</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16783260</span>     <span class="number">60 8762392</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">116 18099</span> <span class="number">33200 13 10</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16782896</span>     <span class="number">60 8762400</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">40 10645</span> <span class="number">21760</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16780616</span>     <span class="number">60 8762412</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">97 12603</span> <span class="number">24496</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16780708</span>     <span class="number">60 8762436</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">90 14724</span> <span class="number">27729</span>  <span class="number">9</span>  <span class="number">4</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">16779376</span>     <span class="number">60 8762472</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">116 12702</span> <span class="number">25101</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16775968</span>     <span class="number">60 8765976</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">133 16290</span> <span class="number">29873 19 10</span> <span class="number">71</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16783224</span>     <span class="number">60 8765996</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">89 13359</span> <span class="number">25299</span>  <span class="number">4</span>  <span class="number">3</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">16782604</span>     <span class="number">60 8766016</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">73 10976</span> <span class="number">22399</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">16775272</span>     <span class="number">60 8766032</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">122 13109</span> <span class="number">26159</span>  <span class="number">4</span>  <span class="number">2</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>buff 和 cache 就是我们前面看到的 Buffers 和 Cache，单位是 KB</li><li>bi 和 bo 则分别表示块设备读取和写入的大小，单位为 块/秒。因为 Linux 中块的大小是 1KB，所以这个单位也就等价于 KB/s</li></ul><p>在另一中端执行 dd 命令通过读取随机设备，生成一个 500MB 大小的文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/urandom <span class="attribute">of</span>=/mnt/disk1/log <span class="attribute">bs</span>=1M <span class="attribute">count</span>=500</span><br></pre></td></tr></table></figure><p>继续观察 buff 和 cache 的变化如下：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat 1</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu--<span class="language-yaml"><span class="meta">---</span></span></span><br><span class="line"><span class="language-yaml"> <span class="string">r</span>  <span class="string">b</span>   <span class="string">swpd</span>   <span class="string">free</span>   <span class="string">buff</span>  <span class="string">cache</span>   <span class="string">si</span>   <span class="string">so</span>    <span class="string">bi</span>    <span class="string">bo</span>   <span class="string">in</span>   <span class="string">cs</span> <span class="string">us</span> <span class="string">sy</span> <span class="string">id</span> <span class="string">wa</span> <span class="string">st</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">6</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16808024</span>     <span class="number">60</span> <span class="number">8706284</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">135</span> <span class="number">17194</span> <span class="number">30511</span> <span class="number">12</span>  <span class="number">5</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">2</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16812680</span>     <span class="number">60</span> <span class="number">8706316</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">108</span> <span class="number">14214</span> <span class="number">27386</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">0</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16822344</span>     <span class="number">60</span> <span class="number">8706268</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">82</span> <span class="number">12608</span> <span class="number">25281</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">96</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"> <span class="number">0</span>  <span class="number">0</span> <span class="number">1218088</span> <span class="number">16828356</span>     <span class="number">60</span> <span class="number">8706284</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">65</span> <span class="number">16971</span> <span class="number">31578</span>  <span class="number">6</span>  <span class="number">5</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span></span><br><span class="line"><span class="language-yaml"><span class="string">...</span></span></span><br><span class="line"><span class="number"> 1 </span><span class="number"> 2 </span>1218088<span class="number"> 16438876 </span>   <span class="number"> 60 </span>9110220   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>264629<span class="number"> 19007 </span>27977 <span class="number"> 5 </span>20<span class="number"> 73 </span><span class="number"> 1 </span> 0</span><br><span class="line"><span class="number"> 8 </span><span class="number"> 1 </span>1218088<span class="number"> 16324916 </span>   <span class="number"> 60 </span>9227456   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>22966<span class="number"> 20049 </span>31235<span class="number"> 13 </span>21<span class="number"> 61 </span><span class="number"> 5 </span> 0</span><br><span class="line"><span class="number"> 2 </span><span class="number"> 0 </span>1218088<span class="number"> 16329904 </span>   <span class="number"> 60 </span>9227244   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 327 </span>11770<span class="number"> 24005 </span><span class="number"> 4 </span><span class="number"> 3 </span>87 <span class="number"> 7 </span> 0</span><br><span class="line"><span class="number"> 0 </span><span class="number"> 0 </span>1218088<span class="number"> 16329340 </span>   <span class="number"> 60 </span>9227248   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>  <span class="number"> 91 </span>11558<span class="number"> 22878 </span><span class="number"> 3 </span><span class="number"> 2 </span>95 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 5 </span><span class="number"> 0 </span>1218088<span class="number"> 16329532 </span>   <span class="number"> 60 </span>9227264   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>  <span class="number"> 88 </span>14350<span class="number"> 28661 </span>10 <span class="number"> 5 </span>85 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 1 </span><span class="number"> 0 </span>1218088<span class="number"> 16325480 </span>   <span class="number"> 60 </span>9227056   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 162 </span>16735<span class="number"> 30309 </span>11 <span class="number"> 8 </span>81 <span class="number"> 0 </span> 0</span><br><span class="line"><span class="number"> 2 </span><span class="number"> 1 </span>1218088<span class="number"> 16325424 </span>   <span class="number"> 60 </span>9230360   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span>225680<span class="number"> 15589 </span>31332<span class="number"> 15 </span>10<span class="number"> 72 </span><span class="number"> 2 </span> 1</span><br><span class="line"><span class="number"> 1 </span><span class="number"> 0 </span>1218088<span class="number"> 16325160 </span>   <span class="number"> 60 </span>9231060   <span class="number"> 0 </span>  <span class="number"> 0 </span>   <span class="number"> 0 </span> <span class="number"> 124 </span>14815<span class="number"> 26517 </span>10 <span class="number"> 6 </span>79 <span class="number"> 5 </span> 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到：</p><ul><li>在 dd 命令运行时，Cache 在不停地增长，而 Buffer 基本保持不变</li><li>在 dd 命令结束后，Cache 不再增长，但是块设备写还会持续一段时间，并且，多次 1/0 写的结果加起来，才是 dd 要写的 500M 的数据</li></ul><p>下面的命令对环境要求很高，需要你的系统配置多块磁盘，并且磁盘分区 /dev/sdb1 还要处于未使用状态。<strong>如果你只有一块磁盘，千万不要尝试，否则将会对你的磁盘分区造成损坏</strong>。</p><p>如果你的系统符合标准，就可以继续在第二个终端中，运行下面的命令。清理缓存后，向磁盘分区 /dev/sdb1 写入 2GB 的随机数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">首先清理缓存</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 3 &gt; /proc/sys/vm/drop_caches</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后运行 <span class="built_in">dd</span> 命令向磁盘分区 /dev/sdb1 写入 2G 数据$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/urandom of=/dev/sdb1 bs=1M count=2048</span></span><br></pre></td></tr></table></figure><p>然后，再回到终端一，观察内存和 I/O 的变化情况：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">procs</span> -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> <span class="attribute">r</span> b swpd free buff cache si so bi bo in cs us sy id wa st</span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7584780</span> <span class="number">153592</span> <span class="number">97436</span> <span class="number">0</span> <span class="number">0</span> <span class="number">684</span> <span class="number">0</span> <span class="number">31</span> <span class="number">423</span> <span class="number">1</span> <span class="number">48</span> <span class="number">50</span> <span class="number">2</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7418580</span> <span class="number">315384</span> <span class="number">101668</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">32</span> <span class="number">144</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7253664</span> <span class="number">475844</span> <span class="number">106208</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">20</span> <span class="number">137</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">7093352</span> <span class="number">631800</span> <span class="number">110520</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">23</span> <span class="number">223</span> <span class="number">0</span> <span class="number">50</span> <span class="number">50</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6930056</span> <span class="number">790520</span> <span class="number">114980</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12804</span> <span class="number">23</span> <span class="number">168</span> <span class="number">0</span> <span class="number">50</span> <span class="number">42</span> <span class="number">9</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6757204</span> <span class="number">949240</span> <span class="number">119396</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">183804</span> <span class="number">24</span> <span class="number">191</span> <span class="number">0</span> <span class="number">53</span> <span class="number">26</span> <span class="number">21</span> <span class="number">0</span> </span><br><span class="line"> <span class="attribute">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">6591516</span> <span class="number">1107960</span> <span class="number">123840</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">77316</span> <span class="number">22</span> <span class="number">232</span> <span class="number">0</span> <span class="number">52</span> <span class="number">16</span> <span class="number">33</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>从这里你会看到，虽然同是写数据，写磁盘跟写文件的现象还是不同的。写磁盘时（也就是 bo 大于 0 时），Buffer 和 Cache 都在增长，但显然 Buffer 的增长快得多。</p><h3 id="场景二：磁盘和文件读"><a href="#场景二：磁盘和文件读" class="headerlink" title="场景二：磁盘和文件读"></a>场景二：磁盘和文件读</h3><p>运行文件读的命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件读</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">dd</span> <span class="keyword">if</span>=/mnt/disk1/log of=/dev/null</span></span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ echo <span class="number">3</span> &gt; /proc/sys/vm/drop_caches</span><br><span class="line">$ mstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">22631652</span>      <span class="number">0 3037032</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">792</span>   <span class="number">225 15443</span> <span class="number">29060 17</span>  <span class="number">8</span> <span class="number">75</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">22629780</span>      <span class="number">0 3037096</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">48</span>    <span class="number">33 13210</span> <span class="number">25184</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">94</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">22474456</span>      <span class="number">0 3192744</span>    <span class="number">0</span>    <span class="number">0 155593</span>   <span class="number">379 11851</span> <span class="number">21896</span>  <span class="number">4</span>  <span class="number">6</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">0 1218088</span> <span class="number">22184464</span>      <span class="number">0 3471364</span>    <span class="number">0</span>    <span class="number">0 282644</span>   <span class="number">181 13324</span> <span class="number">22371</span>  <span class="number">5</span> <span class="number">12</span> <span class="number">83</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">22119672</span>      <span class="number">0 3549248</span>    <span class="number">0</span>    <span class="number">0 73920</span>    <span class="number">82 14720</span> <span class="number">26164</span>  <span class="number">7</span>  <span class="number">8</span> <span class="number">84</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">22118224</span>      <span class="number">0 3549468</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">136</span>    <span class="number">29 17030</span> <span class="number">32835 13</span>  <span class="number">9</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">22116736</span>      <span class="number">0 3549488</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">80</span>   <span class="number">327 11854</span> <span class="number">23476</span>  <span class="number">4</span>  <span class="number">2</span> <span class="number">93</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>运行磁盘读的命令如下</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 磁盘读</span></span><br><span class="line">$ dd <span class="attribute">if</span>=/dev/vdc <span class="attribute">of</span>=/dev/null <span class="attribute">bs</span>=1M <span class="attribute">count</span>=1024</span><br></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ dvmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">6</span>  <span class="number">0 1218088</span> <span class="number">21827684</span>      <span class="number">0 3716568</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218088</span> <span class="number">21816680</span>      <span class="number">0 3721036</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>   <span class="number">117 16130</span> <span class="number">30199 16 11</span> <span class="number">73</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">0 1218088</span> <span class="number">21819240</span>      <span class="number">0 3720212</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">9</span>   <span class="number">195 14200</span> <span class="number">26901</span>  <span class="number">6</span>  <span class="number">4</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">21818228</span>      <span class="number">0 3720252</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">4</span>   <span class="number">123 11836</span> <span class="number">23517</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">95</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218088</span> <span class="number">21802832</span>  <span class="number">14336</span> <span class="number">3720200</span>    <span class="number">0</span>    <span class="number">0 17369</span>   <span class="number">248 10953</span> <span class="number">21760</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">91</span>  <span class="number">4</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21740512</span>  <span class="number">75776</span> <span class="number">3720308</span>    <span class="number">0</span>    <span class="number">0 58416</span>    <span class="number">77 14897</span> <span class="number">27732</span>  <span class="number">4</span>  <span class="number">5</span> <span class="number">79</span> <span class="number">11</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">3</span>  <span class="number">1 1218088</span> <span class="number">21696460</span> <span class="number">133120</span> <span class="number">3720692</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">76 20717</span> <span class="number">40621 14 10</span> <span class="number">66</span>  <span class="number">9</span>  <span class="number">0</span></span><br><span class="line"><span class="number">10</span>  <span class="number">0 1218088</span> <span class="number">21639256</span> <span class="number">190464</span> <span class="number">3720328</span>    <span class="number">0</span>    <span class="number">0 57372</span>   <span class="number">349 18512</span> <span class="number">29321 11</span>  <span class="number">5</span> <span class="number">75</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21600056</span> <span class="number">247808</span> <span class="number">3720308</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">72 17332</span> <span class="number">28977 10</span>  <span class="number">5</span> <span class="number">74</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">1 1218088</span> <span class="number">21539120</span> <span class="number">296960</span> <span class="number">3720340</span>    <span class="number">0</span>    <span class="number">0 49152</span>   <span class="number">688 22618</span> <span class="number">37060 16</span>  <span class="number">8</span> <span class="number">66</span>  <span class="number">9</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">1 1218088</span> <span class="number">21473532</span> <span class="number">354304</span> <span class="number">3720184</span>    <span class="number">0</span>    <span class="number">0 57348</span>   <span class="number">109 18331</span> <span class="number">30615</span>  <span class="number">9</span>  <span class="number">5</span> <span class="number">74</span> <span class="number">11</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">1 1218088</span> <span class="number">21414276</span> <span class="number">407552</span> <span class="number">3723624</span>    <span class="number">0</span>    <span class="number">0 53248</span>   <span class="number">150 16057</span> <span class="number">29868 17</span>  <span class="number">9</span> <span class="number">64</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>  <span class="number">1 1218088</span> <span class="number">21356020</span> <span class="number">464896</span> <span class="number">3723924</span>    <span class="number">0</span>    <span class="number">0 57344</span>    <span class="number">29 14159</span> <span class="number">25301 12</span>  <span class="number">4</span> <span class="number">74</span> <span class="number">10</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">1 1218088</span> <span class="number">21302964</span> <span class="number">518144</span> <span class="number">3723736</span>    <span class="number">0</span>    <span class="number">0 53248</span>   <span class="number">147 10678</span> <span class="number">21725</span>  <span class="number">3</span>  <span class="number">2</span> <span class="number">84</span> <span class="number">12</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218088</span> <span class="number">21278632</span> <span class="number">542720</span> <span class="number">3724092</span>    <span class="number">0</span>    <span class="number">0 24576</span>   <span class="number">428 10163</span> <span class="number">21080</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">91</span>  <span class="number">5</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0 1218088</span> <span class="number">21269044</span> <span class="number">542720</span> <span class="number">3724072</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">73 15601</span> <span class="number">29313</span>  <span class="number">7</span>  <span class="number">5</span> <span class="number">88</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">23</span>  <span class="number">0 1218088</span> <span class="number">21272568</span> <span class="number">542720</span> <span class="number">3724488</span>    <span class="number">0</span>    <span class="number">0</span>     <span class="number">0</span>    <span class="number">33 20061</span> <span class="number">36123 22 12</span> <span class="number">67</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到，读取文件时（也就是 bi 大于 0 时），Buffer 保持不变，而 Cache 则在不停增长；而读取磁盘时，Cache 保持不变，Buffer 不断增长。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。</p>]]></content>
    
    
    <summary type="html">深入剖析 Linux 内存管理机制，涵盖 malloc、brk、mmap、slab 分配器、OOM 杀手原理，并结合 free、top、vmstat 等命令，详解内存分析与调优实践，助你高效定位系统内存瓶颈。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>系统的Swap机制</title>
    <link href="https://wu3227834.github.io/2025/05/16/2025-05-16-xi-tong-de-swap-ji-zhi/"/>
    <id>https://wu3227834.github.io/2025/05/16/2025-05-16-xi-tong-de-swap-ji-zhi/</id>
    <published>2025-05-16T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.051Z</updated>
    
    <content type="html"><![CDATA[<p><strong>文件页</strong>：代表可回收内存，文件页的大部分可以直接回收，以后有需要时，再从磁盘重新读取；而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放</p><p>脏页一般以两个方式写入磁盘：</p><ul><li>在应用程序中，通过系统调用 fync，把脏页同步到磁盘中</li><li>由内核线程 pdflush 负载这些脏页的刷新</li></ul><p><strong>匿名页</strong>：应用程序动态分配的<strong>堆空间</strong>，使用 swap 机制回收</p><h2 id="Swap-原理"><a href="#Swap-原理" class="headerlink" title="Swap 原理"></a>Swap 原理</h2><p>Swap 简单来说就是把一块磁盘空间或者一个本地文件夹，当成内存来使用。它包括换出和换入两个过程：</p><ul><li><strong>换出</strong>，就是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存</li><li><strong>换入</strong>，则是把进程再次访问这些内存的时候，把它们从磁盘读到内存中来</li></ul><p>常见的笔记本电脑的休眠和快速开机功能，也基于 Swap。休眠时，把系统的内存存入磁盘，这样等到再次开机时，只要从磁盘中加载内存就可以。这样省去了很多应用程序的初始化过程，加快了开机速度。</p><p>内存回收的时机：</p><p>1、<strong>直接内存回收</strong>：当有新的大块内存分配请求，但是剩余内存不足，这个时候系统就需要回收一部分内存</p><p>2、<strong>内核线程 kswapd0</strong>来定期回收内存，它定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页最低阈值（pages_low）和页最高阈值（pages_high）。剩余内存，则使用 pages_free 表示</p><p><img src="/img/2025-05-16-%E7%B3%BB%E7%BB%9F%E7%9A%84Swap%E6%9C%BA%E5%88%B6/image.png" alt="pages_free"></p><p>kswapd0 定期扫描内存的使用情况，并根据剩余内存落在这三个阈值的空间位置，进行内存的会后操作：</p><ul><li>剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配空间</li><li>剩余内存落在页最小阈值和页最低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止</li><li>剩余内存落在页最低阈值和页最高阈值中间，说明内存有一定压力，但还可以满足新压力请求</li><li>剩余内存大于页内存阈值，说明剩余内存比较多，没有内存压力</li></ul><p><strong>页低阈值</strong>是由内核选项 /proc/sys/vm/min_free_kbytes 设置，其他两个阈值，都是根据页最小阈值计算生成的</p><h2 id="NUMA-和-Swap"><a href="#NUMA-和-Swap" class="headerlink" title="NUMA 和 Swap"></a>NUMA 和 Swap</h2><p>在 NUMA 架构下，多个处理器被划分到不同 Node 上，且每个 Node 都拥有自己的本地内存空间。而同一个 Node 内部的内存空间，实际上又可以在进一步分为不同的内存域（Zone），比如直接内存访问区（DMA）、普通内存区（NORMAL）、伪内存区（MOVABLE）等，如下图所示：</p><p><img src="/img/2025-05-16-%E7%B3%BB%E7%BB%9F%E7%9A%84Swap%E6%9C%BA%E5%88%B6/image2.png" alt="Node 内部的内存空间"></p><p>使用 numactl 命令查看 Node 的分布情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ numactl --hardware</span><br><span class="line">available:<span class="number"> 2 </span>nodes (0-1)</span><br><span class="line">node<span class="number"> 0 </span>cpus:<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 6 </span>7<span class="number"> 8 </span>9<span class="number"> 20 </span>21<span class="number"> 22 </span>23<span class="number"> 24 </span>25<span class="number"> 26 </span>27<span class="number"> 28 </span>29</span><br><span class="line">node<span class="number"> 0 </span>size:<span class="number"> 130960 </span>MB</span><br><span class="line">node<span class="number"> 0 </span>free:<span class="number"> 7308 </span>MB</span><br><span class="line">node<span class="number"> 1 </span>cpus:<span class="number"> 10 </span>11<span class="number"> 12 </span>13<span class="number"> 14 </span>15<span class="number"> 16 </span>17<span class="number"> 18 </span>19<span class="number"> 30 </span>31<span class="number"> 32 </span>33<span class="number"> 34 </span>35<span class="number"> 36 </span>37<span class="number"> 38 </span>39</span><br><span class="line">node<span class="number"> 1 </span>size:<span class="number"> 131072 </span>MB</span><br><span class="line">node<span class="number"> 1 </span>free:<span class="number"> 17581 </span>MB</span><br><span class="line">node distances:</span><br><span class="line">node  <span class="number"> 0 </span>  1</span><br><span class="line">  0: <span class="number"> 10 </span> 21</span><br><span class="line">  1: <span class="number"> 21 </span> 10</span><br></pre></td></tr></table></figure><p>前面提到的三个内存阈值（页最小阈值、页低阈值和页高阈值），都可以通过内存域在 proc 文件系统中的接口 /proc/zoneinfo 来查看</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat /<span class="keyword">proc</span>/zoneinfo|<span class="title"> head</span> -n 20<span class="title"></span></span><br><span class="line"><span class="title">Node</span> 0,<span class="title"> zone</span> <span class="title">     DMA</span></span><br><span class="line"><span class="title">  pages</span> free     3957<span class="title"></span></span><br><span class="line"><span class="title">        min</span>      7<span class="title"></span></span><br><span class="line"><span class="title">        low</span>      8<span class="title"></span></span><br><span class="line"><span class="title">        high</span>     10<span class="title"></span></span><br><span class="line"><span class="title">        scanned</span>  0<span class="title"></span></span><br><span class="line"><span class="title">        spanned</span>  4095<span class="title"></span></span><br><span class="line"><span class="title">        present</span>  3992<span class="title"></span></span><br><span class="line"><span class="title">        managed</span>  3971<span class="title"></span></span><br><span class="line"><span class="title">    nr_free_pages</span> 3957<span class="title"></span></span><br><span class="line"><span class="title">    nr_alloc_batch</span> 2<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_anon</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_anon</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_file</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_file</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_unevictable</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mlock</span>     0<span class="title"></span></span><br><span class="line"><span class="title">    nr_anon_pages</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mapped</span>    0<span class="title"></span></span><br><span class="line"><span class="title">    nr_file_pages</span> 0</span><br></pre></td></tr></table></figure><p>主要指标包括：</p><ul><li>pages 处的 min、low、high，就是上面提到的三个内存阈值，而 free 是<strong>剩余内存页数</strong>，它跟后边的 nr_free_pages 相同</li><li>nr_zone_active_anon 和 nr_zone_inactive_anon，分别代表<strong>活跃匿名页</strong>和<strong>不活跃匿名页</strong>的数量</li><li>nr_zone_active_file 和 nr_zone_inactive_file，分别代表<strong>活跃文件页</strong>和<strong>不活跃文件页</strong>的数量</li></ul><p>某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存种回收内存。具体选哪种模式，你可以通过 /proc/sys/vm/zone_reclaim_mode 来调整。它支持以下几个选项：</p><ul><li>默认的是 0，也就是刚刚提到的模式，表示既可以从其他 Node 寻找空闲内存，也可以从本地内存中回收</li><li>1、2、4 都表示只回收本地内存，2 表示可以回写脏数据来回收内存，4 表示可以用 Swap 方式回收内存</li></ul><h2 id="swapness"><a href="#swapness" class="headerlink" title="swapness"></a>swapness</h2><p>内存回收包括文件页和匿名页：</p><ul><li>对文件页的回收，是直接回收缓存，或者把脏页写回磁盘后再回收</li><li>对匿名页的回收，是通过 Swap 机制，把它们写入磁盘后再释放内存</li></ul><p>Linux 提供了一个 /proc/sys/vm/swapiness 选项，用来调整使用 Swap 的积极程度；swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。</p><h2 id="系统-Swap-升高的原因"><a href="#系统-Swap-升高的原因" class="headerlink" title="系统 Swap 升高的原因"></a>系统 Swap 升高的原因</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>Linux 本身支持两种类型的 Swap，即 Swap 分区和 Swap 文件，以 Swap 文件为例子，例如如下命令开启 Swap 文件</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 创建swap文件</span></span><br><span class="line"><span class="title">fallocate</span> -l 500M /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 修改权限，仅root用户可读写</span></span><br><span class="line"><span class="title">chmod</span> <span class="number">600</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 配置swap文件</span></span><br><span class="line"><span class="title">mkswap</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br><span class="line"><span class="meta"># 开启swap</span></span><br><span class="line"><span class="title">swapon</span> /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br></pre></td></tr></table></figure><p>执行 free 看到 swap 添加成功</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      <span class="number"> 16092196 </span>    <span class="number"> 562160 </span>    <span class="number"> 613616 </span>    <span class="number"> 295992 </span>  <span class="number"> 14916420 </span>   15135272</span><br><span class="line">Swap:       <span class="number"> 511996 </span>         <span class="number"> 0 </span>     511996</span><br></pre></td></tr></table></figure><p>执行 dd 命令，模拟大文件的读取</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="attribute">if</span>=/dev/vdb1 <span class="attribute">of</span>=/dev/null <span class="attribute">bs</span>=1G <span class="attribute">count</span>=400</span><br></pre></td></tr></table></figure><p>执行 sar 查看内存和 swap 指标</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">$ sar -rS 3</span><br><span class="line">Linux 3.10.107-1-tlinux2_kvm_guest-0051 (VM_194_74_centos)      07/05/20        _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">20:16:14    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:17    <span class="number"> 12016228 </span> <span class="number"> 4075968 </span>    25.33  <span class="number"> 1944876 </span>  <span class="number"> 394804 </span> <span class="number"> 3089884 </span>    18.61  <span class="number"> 2364636 </span> <span class="number"> 1364468 </span>       88</span><br><span class="line"></span><br><span class="line">20:16:14    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:17      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line"></span><br><span class="line">20:16:17    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:20    <span class="number"> 11542068 </span> <span class="number"> 4550128 </span>    28.28  <span class="number"> 2405684 </span>  <span class="number"> 394868 </span> <span class="number"> 3089856 </span>    18.61  <span class="number"> 2364984 </span> <span class="number"> 1825212 </span>      120</span><br><span class="line"></span><br><span class="line">20:16:17    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:20      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:16:50    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:16:53     <span class="number"> 6331744 </span> <span class="number"> 9760452 </span>    60.65  <span class="number"> 7474548 </span>  <span class="number"> 395052 </span> <span class="number"> 3089736 </span>    18.61  <span class="number"> 2364948 </span> <span class="number"> 6894124 </span>       84</span><br><span class="line"></span><br><span class="line">20:16:50    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:16:53      <span class="number"> 511996 </span>       <span class="number"> 0 </span>     0.00        <span class="number"> 0 </span>     0.00</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:17:44    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:17:47       <span class="number"> 90140 </span><span class="number"> 16002056 </span>    99.44 <span class="number"> 13573540 </span>  <span class="number"> 392440 </span> <span class="number"> 3089728 </span>    18.61  <span class="number"> 2180308 </span><span class="number"> 13149900 </span>      164</span><br><span class="line"></span><br><span class="line">20:17:44    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:17:47      <span class="number"> 486836 </span>   <span class="number"> 25160 </span>     4.91      <span class="number"> 120 </span>     0.48</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">20:18:44    kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">20:18:47       <span class="number"> 87988 </span><span class="number"> 16004208 </span>    99.45 <span class="number"> 13658536 </span>  <span class="number"> 354504 </span> <span class="number"> 3089760 </span>    18.61  <span class="number"> 2112144 </span><span class="number"> 13218932 </span>      140</span><br><span class="line"></span><br><span class="line">20:18:44    kbswpfree kbswpused  %swpused  kbswpcad   %swpcad</span><br><span class="line">20:18:47      <span class="number"> 403652 </span>  <span class="number"> 108344 </span>    21.16      <span class="number"> 140 </span>     0.13</span><br></pre></td></tr></table></figure><p>可以看到，总的内存使用率（%memused）在不断增长，从开始的 25% 一直涨到了 99%，并且主要内存都被缓冲区（kbbuffers）占用，大致的变化过程为：</p><ul><li>刚开始，剩余内存（kbmemfree）不断减少，而缓冲区（kbbuffers）则不断增大，由此可知，剩余内存不断分配给了缓冲区</li><li>一段时间后，剩余内存已经很小了，而缓存区占用了大部分内存。此时，Swap 的使用开始逐渐增大，缓冲区和剩余内存则只在小范围内波动</li></ul><p>为什么 Swap 会升高呢？（按理来说，应该先回收缓冲区的内存，这属于可回收内存），观察 /proc/zoneinfo 指标如下</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d grep -A <span class="number">15</span> &#x27;Normal&#x27; /<span class="keyword">proc</span>/zoneinfo<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">Every</span> 2.0s:<span class="title"> grep</span> -A 15<span class="title"> Normal</span> /<span class="keyword">proc</span>/zoneinfo<span class="title">                                                             Sun</span> Jul  5 20:19:39 2020<span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">Node</span> 0,<span class="title"> zone</span> <span class="title">  Normal</span></span><br><span class="line"><span class="title">  pages</span> free     5200<span class="title"></span></span><br><span class="line"><span class="title">        min</span>      3268<span class="title"></span></span><br><span class="line"><span class="title">        low</span>      4085<span class="title"></span></span><br><span class="line"><span class="title">        high</span>     4902<span class="title"></span></span><br><span class="line"><span class="title">        scanned</span>  24<span class="title"></span></span><br><span class="line"><span class="title">        spanned</span>  3407872<span class="title"></span></span><br><span class="line"><span class="title">        present</span>  3407872<span class="title"></span></span><br><span class="line"><span class="title">        managed</span>  3276302<span class="title"></span></span><br><span class="line"><span class="title">    nr_free_pages</span> 5200<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_anon</span> 134532<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_anon</span> 246943<span class="title"></span></span><br><span class="line"><span class="title">    nr_inactive_file</span> 2466171<span class="title"></span></span><br><span class="line"><span class="title">    nr_active_file</span> 280987<span class="title"></span></span><br><span class="line"><span class="title">    nr_unevictable</span> 0<span class="title"></span></span><br><span class="line"><span class="title">    nr_mlock</span>     0</span><br></pre></td></tr></table></figure><p>可以看到，剩余内存（pages free）在一个很小范围内不停地波动。当它小于页低阈值（pages low）时，又会突然增大到一个大于页高阈值（pages high）的数值</p><ul><li>当剩余内存小于页低阈值时，系统会回收一些缓存和匿名内存，使剩余内存增大。其中，缓存的回收导致 sar 中的缓冲区减少，而匿名内存的回收导致了 Swap 的使用增大。其中，缓存的回收导致 sar 中的缓冲区减少，而匿名内存的回收导致了 Swap 的使用增大。</li><li>同事由于 dd 还在继续，剩余内存又会重新分配给缓存，导致剩余内存减少，缓冲区增大</li></ul><p>利用 proc 文件系统，可以查看 Swap 换出的虚拟内存大小，它保存在 /proc/pid/status 中 VmSwap</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ for file in /proc/*/status ; do awk &#x27;/VmSwap|Name|^Pid/&#123;printf $2 &quot; &quot; $3&#125;END&#123; print &quot;&quot;&#125;&#x27; $file; done | sort -k<span class="number"> 3 </span>-n -r | head</span><br><span class="line">systemd-journal<span class="number"> 3048 </span>86160 kB</span><br><span class="line">writeback<span class="number"> 50 </span></span><br><span class="line">watchdog/7<span class="number"> 41 </span></span><br><span class="line">watchdog/6<span class="number"> 36 </span></span><br><span class="line">watchdog/5<span class="number"> 31 </span></span><br><span class="line">watchdog/4<span class="number"> 26 </span></span><br><span class="line">watchdog/3<span class="number"> 21 </span></span><br><span class="line">watchdog/2<span class="number"> 16 </span></span><br><span class="line">watchdog/1<span class="number"> 11 </span></span><br><span class="line">watchdog/0<span class="number"> 10 </span></span><br></pre></td></tr></table></figure><p>可以看到，使用 swap 较多的是 systemd-journal</p><p>结束之后，需要关闭 swap</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -<span class="selector-tag">a</span></span><br></pre></td></tr></table></figure><p>一般关闭 swap 并重新打开，可以这么执行（是一种常见的 swap 清理方法）</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">swapoff</span> -a &amp;&amp; swapon /<span class="class"><span class="keyword">data</span>/swapfile</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在内存资源紧张时，Linux 会通过 Swap，把不常访问的匿名页换出到磁盘中，下次访问的时候再从磁盘换入到内存中来。你可以设置 /proc/sys/vm/min_free_kbytes，来调整系统定期回收内存的阈值；也可以设置 /proc/sys/vm/swappiness，来调整文件页和匿名页的回收倾向。</p><p>当 Swap 变高时，你可以用 sar、/proc/zoneinfo、/proc/pid/status 等方法，查看系统和进程的内存使用情况，进而找出 Swap 升高的根源和受影响的进程。</p><p>通常，降低 Swap 的使用，可以提高系统的整体性能。有几种常见的降低方法：</p><ul><li>禁用 Swap，现在服务器的内存走足够大，所有除非有必要，一般会<strong>禁用 Swap</strong>，大部分云平台中的虚拟机都默认禁用 Swap</li><li>如果实在需要用到 Swap，可以尝试<strong>降低 swappiness</strong>值，减少内存回收时 Swap 的使用倾向</li><li>响应延迟敏感的应用，如果它们可能在开启 Swap 的服务器中运行，你还可以使用库函数 mlock() 或者 mlockall() <strong>锁定内存</strong>，阻止它们的内存换出</li></ul><p>常见的三种清理缓存的方法：</p><p>1、清理 pagecache</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 1</span></span><br></pre></td></tr></table></figure><p>2、清理 dentries 和 inodes</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">2</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 2</span></span><br></pre></td></tr></table></figure><p>3、清理 pagecache、dentries 和 inodes</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">3</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/vm/</span>drop_caches  <span class="comment"># 或者 sysctl -w vm.drop_caches = 3</span></span><br></pre></td></tr></table></figure><p>4、使用 sync 命令来清理文件系统内存，还会清理僵尸（zombie）对象和它们占用的内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sync</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux 的 Swap 机制通过将磁盘空间用作虚拟内存，缓解物理内存不足的问题。Swap 包括换出（将不常用内存数据存至磁盘，释放内存）和换入（再次访问时从磁盘读回内存）两个过程。内存回收分为文件页和匿名页：文件页可直接回收或写入磁盘后释放，匿名页则通过 Swap 回收。内核线程 kswapd0 根据页最小、最低和最高阈值定期回收内存，当剩余内存低于阈值时触发回收。NUMA 架构下，内存分为不同 Node 和 Zone，回收策略可通过 /proc/sys/vm/zone_reclaim_mode 调整。Swap 使用倾向由 /proc/sys/vm/swappiness 控制，值越大越倾向回收匿名页。Swap 升高可能因缓存占用或匿名页回收，需用 sar、/proc/zoneinfo 等工具分析。优化方法包括禁用 Swap、降低 swappiness、锁定内存，或清理缓存（如 pagecache、dentries）。合理配置 Swap 可提升性能，但需避免过度使用以降低延迟。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能调优：cpu</title>
    <link href="https://wu3227834.github.io/2025/05/15/2025-05-15-linux-tracing-cpu/"/>
    <id>https://wu3227834.github.io/2025/05/15/2025-05-15-linux-tracing-cpu/</id>
    <published>2025-05-15T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="怎么理解“平均负载”"><a href="#怎么理解“平均负载”" class="headerlink" title="怎么理解“平均负载”"></a>怎么理解“平均负载”</h2><p>简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它和 CPU 使用率没有直接关系，因为 CPU 使用率是指单位时间内 CPU 繁忙程度的百分比。</p><blockquote><p>可运行状态：进程正在运行或准备运行。也就是我们常用 ps 命令看到的处于 R 状态的进程<br>不可中断状态：进程正在等待某个事件的完成，例如 I/O 操作、等待锁、等待信号量等。也就是我们常用 ps 命令看到的处于 D 状态的进程</p></blockquote><p>那么，在实际生产环境中，平均负载多高时，需要我们重点关注呢？</p><p>在我看来，当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但是平均负载本身，我们不能直接发现到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</p><ul><li>平均负载高可能是 CPU 密集型进程导致的</li><li>平均负载高不一定代表 CPU 利用率高，还有可能是 I/0 更繁忙了</li><li>当发现负载高的时候，你可看到使用 mpstat、pidstat 等工具，辅助分析负载的来源</li></ul><h2 id="CPU-上下文切换（上）"><a href="#CPU-上下文切换（上）" class="headerlink" title="CPU 上下文切换（上）"></a>CPU 上下文切换（上）</h2><ul><li>CPU 上下文：包括 CPU 寄存器和程序计数器</li><li>CPU 寄存器：是 CPU 内置的容量小、但速度极快的内存</li><li>程序计数器：是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置的寄存器</li></ul><p><img src="/img/2025-05-15-linux_tracing_cpu/image.png" alt="cpu 架构"></p><ul><li>CPU 上下文切换：是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载到新任务的上下文到这些寄存器和程序计数器，然后再跳转到程序计数器指向的新位置，运行新任务</li><li>这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载出来</li></ul><p>根据任务的不同，CPU 的上下文切换可分为进程上下文切换、线程上下文切换和中断上下文切换。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，对应着下图，CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源</li></ul><p><img src="/img/2025-05-15-linux_tracing_cpu/image2.png" alt="运行空间"></p><p>从进程用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，系统调用的过程中会发生<strong>两次 CPU 上下文切换</strong>。CPU 里原本用户态指令的执行位置需要先保存起来，然后更新为内核态的指令位置，最后跳转到内核态运行内核任务；在系统调用结束后，CPU 寄存器需要恢复原本保存的用户态，然后再切换到用户空间，继续执行进程。</p><p><strong>注意：</strong></p><ol><li>系统调用的过程中，不会涉及到虚拟内存等进程态的资源，不会切换进程，系统调用过程和进程上下文切换不一样，整个过程都是同一个进程</li><li>系统调用称为特权模式切换，不是上下文切换</li></ol><p>进程上下文切换和系统调用的区别是，进程的上下文切换比系统调用多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p><img src="/img/2025-05-15-linux_tracing_cpu/image3.png" alt="进程上下文切换"></p><p><strong>保存上下文和恢复上下文的过程需要内核在 CPU 上运行才能完成</strong>（上下文切换过程是 CPU 密集型），每次上下文切换都需要几十纳秒到数微妙的 CPU 时间。</p><p>在进程上下文切换次数过多的情况下，很容易导致 CPU 将大量时间耗费在<strong>寄存器、内核栈以及虚拟内存</strong>等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，从而导致系统平均负载升高。</p><p>Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在<strong>多处理器系统</strong>上，缓存是被多个处理器<strong>共享</strong>的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选在最需要 CPU 的进程，也就是<strong>优先级最高和等待 CPU 时间最长</strong>的进程来运行。</p><p>进程被 CPU 重新调度的时机：</p><ol><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其它进程运行</li><li>进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度</li><li>有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序</li></ol><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程和进程的区别：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p><p>所谓内核中的任务调度，实际上的调度对象是<strong>线程</strong>；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul><p>因此，线程的上下文切换分为两种情况：</p><ul><li>前后两个进程属于不同进程。此时，因为资源部共享，所以切换过程就跟进程上下文切换是一样的</li><li>前后两个线程属于用一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<strong>私有数据、寄存器</strong>等不共享的资源</li></ul><p><strong>注意：</strong>同进程的线程切换要比进程间的切换消耗更少的资源，更加轻量级</p><h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>为了响应硬件事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p><p>中断上下文切换不会涉及进程的用户态，它其实只包括内核态中断服务程序执行所必需的状态，包括 <strong>CPU 寄存器、内核堆栈、硬件中断参数</strong>等</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以<strong>中断上下文切换不会与进程上下文切换同步发生</strong></p><p>大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>中断上下文切换也需要消耗 CPU，切换次数过多也会消耗大量的 CPU，甚至严重降低系统的整体性能</p><h2 id="CPU上下文切换（下）"><a href="#CPU上下文切换（下）" class="headerlink" title="CPU上下文切换（下）"></a>CPU上下文切换（下）</h2><h3 id="查看上下文切换"><a href="#查看上下文切换" class="headerlink" title="查看上下文切换"></a>查看上下文切换</h3><p>1、查看系统的总体情况</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">5</span> <span class="number">5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218196</span> <span class="number">17324820</span>     <span class="number">60 8417344</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">25</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218196</span> <span class="number">17311424</span>     <span class="number">60 8426964</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">900</span>    <span class="number">97 15273</span> <span class="number">28505 11</span>  <span class="number">6</span> <span class="number">83</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218196</span> <span class="number">17399080</span>     <span class="number">60 8343224</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">410</span>   <span class="number">310 15800</span> <span class="number">29604</span>  <span class="number">8</span>  <span class="number">6</span> <span class="number">86</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">0 1218196</span> <span class="number">17385124</span>     <span class="number">60 8350312</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">787</span>   <span class="number">300 13754</span> <span class="number">26351</span>  <span class="number">7</span>  <span class="number">4</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218196</span> <span class="number">17415052</span>     <span class="number">60 8336488</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">276</span>   <span class="number">132 15567</span> <span class="number">29585</span>  <span class="number">8</span>  <span class="number">5</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cs：context switch，每秒上下文切换的次数</li><li>in：interrupt，每秒中断的次数</li><li>r：运行队列的长度（正在运行和等待CPU的进程数）</li><li>b：处于阻塞状态的进程数</li></ul><p>2、查看进程的详细信息</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -w 5</span><br><span class="line">Linux 3.10.0-957.el7.x86_64 (xxx)       05/27/2025      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">07:35:35 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 1 </span>     3.77      0.40  systemd</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 3 </span>     2.58      0.00  ksoftirqd/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 7 </span>     7.34      0.00  migration/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 9 </span>   218.45      0.00  rcu_sched</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 11 </span>     0.40      0.00  watchdog/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 12 </span>     0.40      0.00  watchdog/1</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 13 </span>     3.57      0.00  migration/1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cswch/s：每秒自愿上下文切换的次数</li><li>nvcswch/s：每秒非自愿上下文切换的次数</li></ul><blockquote><p>自愿上下文切换：进程无法获取所需资源导致的上下文切换，比如 I/O，内存等系统资源不足时发生的上下文切换<br>非自愿上下文切换：进程因时间片已到等原因，被系统强制调度发生的上下文切换，比如多个进程竞争 CPU 是发生的上下文切换</p></blockquote><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>sysbench 模拟多线程调度切换</p><p>1、运行 sysbench</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line">$ sysbench <span class="attribute">--threads</span>=10 <span class="attribute">--max-time</span>=300 threads run</span><br></pre></td></tr></table></figure><p>2、运行 vmstat</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">9</span>  <span class="number">0</span>      <span class="number">0 107736672</span>     <span class="number">64 88038080</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>   <span class="number">199</span>    <span class="number">0</span>    <span class="number">1</span>  <span class="number">2</span>  <span class="number">1</span> <span class="number">97</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0</span>      <span class="number">0 107731792</span>     <span class="number">64 88045280</span>    <span class="number">0</span>    <span class="number">0 16384</span>    <span class="number">40 105267</span> <span class="number">1167081 12</span> <span class="number">15</span> <span class="number">72</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">0</span>      <span class="number">0 107733720</span>     <span class="number">64 88038080</span>    <span class="number">0</span>    <span class="number">0</span>  <span class="number">4192</span>    <span class="number">20 100233</span> <span class="number">1237404</span>  <span class="number">6</span> <span class="number">16</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">0</span>      <span class="number">0 107726368</span>     <span class="number">64 88045280</span>    <span class="number">0</span>    <span class="number">0 14464</span>    <span class="number">68 128551</span> <span class="number">1548455</span>  <span class="number">6</span> <span class="number">17</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">10</span>  <span class="number">0</span>      <span class="number">0 107735168</span>     <span class="number">64 88039216</span>    <span class="number">0</span>    <span class="number">0</span>  <span class="number">4096</span>    <span class="number">64 111126</span> <span class="number">1468157</span>  <span class="number">6</span> <span class="number">16</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>指标观察：</p><ul><li>cs 列：上升到 100w</li><li>r 列：就绪队列长度上升到 10</li><li>in 列：终端次数上升到 10w</li><li>us（user）和sy（system）列：使用率加起来接近 100%，sy 为 78%，主要被内核占用</li></ul><p>3、查看进程情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line">$ pidstat -w -u 1</span><br><span class="line">19时34分55秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 561077 </span>   0.00    1.00    0.00    1.00    <span class="number"> 2 </span> sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 562599 </span> 100.00  100.00    0.00  100.00   <span class="number"> 13 </span> sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 566600 </span>   0.00    2.00    0.00    2.00   <span class="number"> 32 </span> pidstat</span><br><span class="line"></span><br><span class="line">19时34分55秒   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 256312 </span>     1.00      0.00  kworker/37:31</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 263655 </span>     1.00      0.00  kworker/33:2</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 299865 </span>     1.00      0.00  kworker/21:2</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 562931 </span>     1.00      2.00  vmstat</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 560904 </span>     1.00      0.00  sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 561077 </span>    78.00      0.00  sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 566600 </span>     1.00    671.00  pidstat</span><br></pre></td></tr></table></figure><p>分析：CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd</p><p><strong>注意：</strong>pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 100 万明显小了太多？</p><table><thead><tr><th>工具</th><th>统计粒度</th><th>上下文切换数据来源</th><th>显示内容</th></tr></thead><tbody><tr><td>pidstat</td><td>按进程/线程级别</td><td>/proc/[pid]/sched 或 /proc/[pid]/status</td><td>显示某些（非全部）PID 的上下文切换次数</td></tr><tr><td>vmstat</td><td>系统全局级别</td><td>内核调度器</td><td>显示全系统每秒上下文切换总数</td></tr></tbody></table><p>4、查看线程情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">$ pidstat -wt 1</span><br><span class="line">19时34分55秒  UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 616348 </span>        -      0.00      0.00  sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616348 </span>     0.00      0.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616349 </span> 67080.00      6.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616350 </span> 63009.00      3.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616351 </span> 68060.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616352 </span> 69808.00      4.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616353 </span> 68806.00      5.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616354 </span> 73688.00      6.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616355 </span> 72296.00      4.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616356 </span> 63978.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616357 </span> 67409.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616358 </span> 67859.00      2.00  |__sysbench</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。上下文切换罪魁祸首，还是过多的 sysbench 线程</p><p>5、查看中断升高的原因</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d cat /<span class="keyword">proc</span>/interrupts<span class="title"></span></span><br><span class="line"><span class="title">           CPU0</span> <span class="title">      CPU1</span> <span class="title">      CPU2</span></span><br><span class="line">...<span class="title"></span></span><br><span class="line"><span class="title"> RES:</span>  117962220   27310354   17986708<span class="title">   Rescheduling</span> interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察发现，变化速度最快的是重调度中断（RES），它代表唤醒空闲状态的 CPU 来调度新的任务运行，这是在多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）</p><p><strong>分析：</strong>过多任务导致了重调度中断的升高，和前面分析结果一致</p><h2 id="每秒上下文切换多少次正常"><a href="#每秒上下文切换多少次正常" class="headerlink" title="每秒上下文切换多少次正常"></a>每秒上下文切换多少次正常</h2><p><strong>上下文切换次数取决于系统本身的CPU性能。</strong>如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级增长时，就很有可能出现了性能问题，这时根据具体上下文切换的类型具体分析：</p><ul><li>资源上下文切换变多了，说明进程在等在资源，可能发生了 I/O 等其他问题</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还序号通过查看 /proc/interrupts 文件来分析具体的中断类型</li></ul>]]></content>
    
    
    <summary type="html">本文深入讲解 Linux 系统性能调优中的 CPU 相关知识，重点解析平均负载的含义及其与 CPU 使用率的关系，探讨 CPU 上下文切换（进程、线程、中断）的机制与影响，并通过 sysbench 案例分析高负载场景下的诊断方法，指导如何使用 vmstat、pidstat 等工具定位性能瓶颈。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何迅速分析出CPU的瓶颈</title>
    <link href="https://wu3227834.github.io/2025/05/15/2025-05-15-ru-he-xun-su-fen-xi-chu-cpu-de-ping-jing/"/>
    <id>https://wu3227834.github.io/2025/05/15/2025-05-15-ru-he-xun-su-fen-xi-chu-cpu-de-ping-jing/</id>
    <published>2025-05-15T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.050Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a>CPU性能指标</h2><p>性能指标总览</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image.png" alt="性能指标总览"></p><h3 id="CPU使用率"><a href="#CPU使用率" class="headerlink" title="CPU使用率"></a>CPU使用率</h3><p>CPU 使用率描述了非空闲时间占总 CPU 时间的百分比，根据 CPU 上运行任务的不同，又被分为用户 CPU、系统 CPU、等待 I/0 CPU、软中断和硬中断等。用户 CPU 使用率，包括用户态 CPU 使用率（user）和低优先级用户态：</p><ul><li>CPU 使用率（nice），表示 CPU 在<strong>用户态</strong>运行的时间百分比。用户 CPU 使用率高，通常说明有<strong>应用程序</strong>比较繁忙</li><li>系统 CPU 使用率，表示 CPU 在内核状态运行的时间百分比（不包括中断）。系统 CPU 使用率高，说明<strong>内核</strong>比较繁忙</li><li>等待 I/O 的 CPU 使用率，通常为 iowait，表示<strong>等待 I/O</strong> 的时间百分比。iowait 高，通常说明系统与硬件设备的 I/O 交互比较长</li><li>软中断和硬中断的 CPU 利用率，分别表示内核调用软中断处理程序、硬中断处理程序的时间百分比。它们的使用率高，通常说明系统发生了大量的中断</li><li>除了上述这些，还有在虚拟化环境中会用到的<strong>窃取 CPU 利用率（steal）和客户 CPU 使用率（guest）</strong>，分别表示被其他虚拟机占用的 CPU 时间百分比，和运行客户虚拟机的 CPU 时间百分比</li></ul><h3 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h3><p>系统的活跃进程数。反映了系统的整体负载情况，主要包括三个数值，分别表示过去 1 分钟、过去 5 分钟和过去 15 分钟的平均负载。理想情况下，平均负载等于逻辑 CPU 个数，这个代表每个 CPU 都恰好被充分利用。如果负载大于逻辑 CPU 个数，就表示负载比较重了。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>进程上下文切换分为：自愿上下文切换和非自愿上下文切换</p><p>注意：过多的上下文切换，会将原本运行进程的 CPU 时间，消耗在<strong>寄存器、内核栈以及虚拟内存等数据的保存和恢复上</strong>，缩短进程真正进行的时间，成为性能瓶颈。</p><h3 id="CPU-缓存命中率"><a href="#CPU-缓存命中率" class="headerlink" title="CPU 缓存命中率"></a>CPU 缓存命中率</h3><p>CPU 缓存的速度介于 CPU 和内存之间，缓存的是<strong>热点的内存数据</strong>。</p><p>如下图，根据不断增长的热点数据，这些缓存按照大小不同分为 L1、L2、L3 等三级缓存，其中 L1 和 L2 常在单核中，L3 则在多核中。从 L1 到 L3，三级缓存的大小依次增大，相应的，性能依次减少（当然内存还是好得多）。而它们的命中率，衡量的是 <strong>CPU 缓存的复用情况</strong>，命中率越高，则表示性能越好。</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image2.png" alt="CPU 缓存"></p><h2 id="CPU-性能工具"><a href="#CPU-性能工具" class="headerlink" title="CPU 性能工具"></a>CPU 性能工具</h2><p>平均负载案例：使用 uptime 查看平均负载，在平均负载升高时，使用 mpstat 和 pidstat 分别观察每个 CPU 和每个进程 CPU 的使用情况，找到导致平均负载升高的 stress 进程</p><p>上下文切换的案例：先使用 vmstat，查看系统上下文切换次数和中断次数；然后使用 pidstat（-w 参数）观察进程的自愿上下文切换和非自愿上下文切换；最后通过 vmstat（-wt参数）查看线程的上下文切换情况，从而找到了线程上下文切换增多的原因是 sysbench 工具</p><p>进程 CPU 使用率升高的案例：先使用 top 找出系统和进程 CPU 的使用情况，发现了 CPU 使用率很高的进程 php-fpm，再使用 perf top 找出热点函数 sqrt()；如果是 Python 应用，可以使用 profiler 工具 pyflame 对指定进程分析（pyflame -p pid –threads -s 检测时间 -r 取样间隔 -o &lt;file.txt&gt;），再通过 flamegraph.pl 将输出的 txt 文件转换为 *.svg 格式的火焰图（./flamegraph.pl prof.txt &gt; prof.svg）</p><p>不可中断进程和僵尸进程的案例：</p><ul><li>不可中断进程分析过程：先使用 top 查看，发现存在 D 状态（不可中断休眠进程）和 Z 状态（僵尸进程），并且 iowait 较高；使用 dstat 分析磁盘 I/O，发现 app 进程有大量的磁盘读请求；使用 pidstat（-d -p 参数）分析 app 进程的 I/O 操作，发现没有大量的 I/O 操作，再用 pidstat -d 分析系统的 I/O 情况，发现还是 app 进程在进行磁盘读；再使用 strace 跟踪 D 状态进程对应进程号的系统调用，发现没有权限；ps 查看发现对应进程号的进程已经变成僵尸进程；之后，通过 perf record -g 和 perf report 生成报告，查看 app 进程的调用栈，发现 CPU 使用主要是在 sys_read() 函数，定位到是在对磁盘进行直接读（direct_IO）；查看代码发现 open() 系统调用使用了 O_DIRECT 参数</li><li>僵尸进程分析：使用 pstree 命令找出僵尸进程的父进程是 app 进程，然后查看 app.c 文件，发现 wait() 使用位置不当导致不能回收子进程</li></ul><p>软中断的案例：先使用 top 查看系统指标，发现系统 CPU 使用率很低，但是主要是在软中断 si 上，然后查看 /proc/softirqs 查看系统软中断变化情况，发现 NET_RX 变化率很快，再使用 sar 工具查看系统的网络收发情况，发现 eth0 网卡接收到了大量的小包；在通过抓包工具 tcpdump，发现 eth0 接受到了大量的 SYN 包，最终确定了是 SYN FLOOD 攻击</p><h3 id="性能指标找工具"><a href="#性能指标找工具" class="headerlink" title="性能指标找工具"></a>性能指标找工具</h3><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image3.png" alt="性能指标找工具"></p><h3 id="工具找指标"><a href="#工具找指标" class="headerlink" title="工具找指标"></a>工具找指标</h3><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image4.png" alt="工具对应指标"></p><h2 id="如何分析-CPU-的性能瓶颈"><a href="#如何分析-CPU-的性能瓶颈" class="headerlink" title="如何分析 CPU 的性能瓶颈"></a>如何分析 CPU 的性能瓶颈</h2><p>重点：弄清楚性能指标之间的关联性</p><p><img src="/img/2025-05-15-%E5%A6%82%E4%BD%95%E8%BF%85%E9%80%9F%E5%88%86%E6%9E%90%E5%87%BACPU%E7%9A%84%E7%93%B6%E9%A2%88/image5.png" alt="指标关联性"></p><h2 id="CPU-性能优化的几个思路"><a href="#CPU-性能优化的几个思路" class="headerlink" title="CPU 性能优化的几个思路"></a>CPU 性能优化的几个思路</h2><h3 id="性能优化方法论"><a href="#性能优化方法论" class="headerlink" title="性能优化方法论"></a>性能优化方法论</h3><p>确定三个问题：</p><ul><li>判断所做的性能优化是否有效？优化后，能提升多少性能，有多少收益？</li><li>如果有多个性能问题同时存在，应该先优先哪一个？</li><li>当有多个优化方法，应该选择哪一种</li></ul><p><strong>怎么评估性能优化结果：</strong></p><p>三步走原则：</p><ol><li>确定优化的量化指标</li><li>测试优化前的性能指标</li><li>测试优化后的性能指标</li></ol><p>第一步，性能的量化指标包括 CPU 使用率、应用的吞吐量，响应时间等等，<strong>不要局限在单一维度的指标上</strong>。例如，以 web 应用为例：</p><ul><li>应用程序的维度，使用<strong>吞吐量和请求延时</strong>来评估</li><li>系统资源的维度，使用<strong>CPU 使用率</strong>来评估</li></ul><p>好的应用程序是性能优化的最终结果和目的，要使用应用程序的指标，来评估性能优化的整体效果；而系统资源的使用情况是影响应用程序的根源，需要用资源的指标，来分析应用性能的瓶颈来源。</p><p>第二三步，对比第一部确定的<strong>量化指标</strong>在优化前后的差距，拿数据说话。例如，使用 ab 工具测试 Web 应用的并发请求数和响应延时，同时使用 vmstat，pidstat 等工具，观察系统和进程的 CPU 使用率，同时获得了应用和系统两个维度的性能指标</p><p><strong>进行性能测试需要注意的是：</strong></p><ul><li>要避免性能测试工具干扰应用程序的性能</li><li>避免外部环境的变化影响性能指标的评估。在优化前、后的应用程序，都运行在相同配置的机器上，并且它们的外部依赖也要完全一致</li></ul><p><strong>多个性能问题同时存在，怎么选择？</strong></p><p>遵循<strong>二八原则</strong>，80% 的性能问题都是由于 20% 的代码导致的，<strong>并不是所有的性能问题都值得优化</strong></p><p>分析的步骤：</p><ul><li>挨个分析出所有的性能瓶颈，排除掉有因果关系的性能问题</li><li>在剩下的几个性能问题中，选择能明显提升应用性能的问题进行修复，有两种方法：<ul><li>如果系统资源出现瓶颈，首先优化系统资源使用的问题</li><li>针对不同类型的指标，首先优化导致<strong>性能指标变化幅度最大</strong>的那些瓶颈问题</li></ul></li></ul><p><strong>有多种优化方法时，如何选择？</strong></p><p>性能优化并非没有成本。</p><p>一个很典型的例子网络中的 DPDK（Data Plane Development Kit）。DPDK 是一种优化网络处理速度的方法，它通过绕开内核网络协议栈的方法，提升网络的处理能力。不过它有一个很典型的要求，就是要独占一个 CPU 以及一定数量的内存大页，并且总是以 100% 的 CPU 使用率运行。所以，如果你的 CPU 核数很少，就有点得不偿失了。</p><p>因此，在考虑性能优化方法时，要结合实际情况，考虑多方面的因素，进行权衡在做选择</p><h3 id="CPU优化"><a href="#CPU优化" class="headerlink" title="CPU优化"></a>CPU优化</h3><p><strong>常见的几种应用程序方法：</strong></p><ul><li><strong>编译器优化</strong>：很多编译器都会提供优化选项，适当开启它们，在编译阶段你就可以获得编译器的帮助，来提升性能。比如，gcc 就提供了优化选项 -O2，开启后会自动对应用程序的代码进行优化</li><li><strong>算法优化</strong>：使用复杂度更低的算法，显著加快处理速度</li><li><strong>异步处理</strong>：使用异步处理，可以避免程序因为等待某个资源而一直阻塞，从而提升程序的并发处理能力。比如，把轮询替换为事件通知，就可以避免轮询耗费 CPU 的问题</li><li><strong>多线程代替多进程</strong>：前面讲过，相对于进程的上下文切换，线程的上下文切换并不切换进程地址空间，因此可以降低上下文切换的成本</li><li><strong>善用缓存</strong>：经常访问的数据或者计算过程中的步骤，可以放到内存中缓存起来，这样在下次用时就能直接从内存中获取，加快程序的处理速度</li></ul><p><strong>常见的系统优化方法：</strong></p><ul><li><strong>CPU 绑定</strong>：把进程绑定到一个或者多个 CPU 上，可以提高 CPU 缓存的命中率，减少跨 CPU 调度带来的上下文切换问题</li><li><strong>CPU 独占</strong>：跟 CPU 绑定类似，进一步将 CPU 分组，并通过 CPU 亲和性机制为其分配进程。这样，这些 CPU 就由指定的进程独占，换句话说，不允许其他进程再来使用这些 CPU</li><li><strong>优先级调整</strong>：使用 nice 调整进程的优先级，正值调低优先级，负值调高优先级。可以适当降低非核心应用的优先级，增高核心应用的优先级，可以确保核心应用得到优先处理</li><li><strong>为进程设置资源限制</strong>：使用 Linux cgroups 来设置进程的 CPU 使用上限，可以防止由于某个应用自身的问题，而耗尽系统资源</li><li><strong>NUMA（Non-Uniform Memory Access）优化</strong>：支持 NUMA 的处理器会将内存划分为多个 node，每个 node 关联到系统的一个处理器。NUMA 优化，其实就是让 CPU 尽可能只访问本地内存</li><li><strong>中断负载均衡</strong>：无论是软中断还是硬中断，它们的中断处理程序都可能会耗费大量的 CPU。开启 irqbalance 服务或者配置 smp_affinity，就可以把<strong>中断处理过程自动负载均衡到多个 CPU 上</strong></li></ul><p><strong>避免过早优化：</strong></p><p>性能优化最好是<strong>逐步完善，动态进行</strong>，不追求一步到位，而要<strong>首先保证能满足当前的性能要求</strong>。当发现性能不满足要求或者出现性能瓶颈时，再根据性能评估的结果，选择最重要的性能问题进行优化</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>要忍住“把 CPU 性能优化到极致”的冲动</strong>，因为 CPU 并不是唯一的性能因素，还会有其他的性能问题，比如内存、网络、I/O 甚至是架构设计的问题。</p><p>如果不做全方位的分析和测试，只是单纯地把某个指标提升到极致，并不一定能带来整体的收益。</p>]]></content>
    
    
    <summary type="html">分析 CPU 性能瓶颈是优化 Linux 系统性能的关键。CPU 使用率反映非空闲时间占比，分为用户态、系统态、I/O 等待、软硬中断等，分别指示应用程序、内核、I/O 交互或中断的繁忙程度。平均负载表示活跃进程数，理想值等于逻辑 CPU 数量，超载提示系统压力。上下文切换包括自愿和非自愿切换，过多切换会消耗 CPU 时间，降低进程运行效率。CPU 缓存命中率衡量热点数据复用，高命中率提升性能。分析工具如 uptime、mpstat、pidstat 监测负载与 CPU 使用，vmstat 观察上下文切换，perf 定位热点函数，strace 跟踪系统调用。优化方法包括编译器优化、算法改进、异步处理、多线程替换多进程、善用缓存等系统层面优化，如 CPU 绑定、独占、优先级调整及中断负载均衡。性能优化需遵循二八原则，优先解决主要瓶颈，避免过早优化，确保量化指标（如吞吐量、响应时间）提升，结合多维度分析以实现整体性能收益。</summary>
    
    
    
    
    <category term="Linux" scheme="https://wu3227834.github.io/tags/Linux/"/>
    
    <category term="性能测试" scheme="https://wu3227834.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 Python 传参机制与对象传递</title>
    <link href="https://wu3227834.github.io/2025/02/24/2025-02-24-qian-tan-python-chuan-can-ji-zhi-yu-dui-xiang-chuan-di/"/>
    <id>https://wu3227834.github.io/2025/02/24/2025-02-24-qian-tan-python-chuan-can-ji-zhi-yu-dui-xiang-chuan-di/</id>
    <published>2025-02-24T00:00:00.000Z</published>
    <updated>2025-11-13T10:05:49.050Z</updated>
    
    <content type="html"><![CDATA[<p>Python 的传参机制是其内存管理和函数设计的重要组成部分，尤其在处理可变和不可变对象时，可能会导致意想不到的行为。本报告将详细探讨 Python 的传参方式（按值还是按引用），并深入分析如何理解“传对象”，涵盖对象引用的概念、可变性对传参的影响，以及开发者如何在实践中管理这些行为。</p><h2 id="背景与问题概述"><a href="#背景与问题概述" class="headerlink" title="背景与问题概述"></a>背景与问题概述</h2><p>在编程语言中，传参通常分为按值传递（pass by value）和按引用传递（pass by reference）。按值传递意味着函数接收的是参数的副本，修改不会影响原始变量；按引用传递意味着函数接收的是原始变量的引用，修改会影响原始变量。Python 的传参机制与这些传统概念有所不同，官方文档和社区讨论中常提到“按对象引用传递”（call by object reference）或“按赋值传递”（pass by assignment）。</p><h2 id="Python-传参的本质：按对象引用传递"><a href="#Python-传参的本质：按对象引用传递" class="headerlink" title="Python 传参的本质：按对象引用传递"></a>Python 传参的本质：按对象引用传递</h2><p>根据官方文档和权威资源，Python 的传参方式是按对象引用传递。这意味着当你将参数传递给函数时，函数接收的是指向同一个对象的引用，而不是对象的副本。具体来说：</p><ul><li>函数的参数成为函数局部命名空间中的一个新变量，这个变量绑定到与调用者传递的对象相同的对象。</li><li>这种绑定是通过赋值完成的，因此也被称为按赋值传递。</li></ul><p>为了理解这一点，我们需要回顾 Python 的对象模型：</p><ul><li>Python 中一切都是对象，变量只是指向对象的引用（reference）。 </li><li>当你执行 <code>x = 5</code>，<code>x</code> 是一个名称，绑定到整数对象 5。</li><li>当你调用 <code>func(x)</code>，函数 <code>func</code> 的参数绑定到同一个对象 5。</li></ul><h2 id="可变与不可变对象的影响"><a href="#可变与不可变对象的影响" class="headerlink" title="可变与不可变对象的影响"></a>可变与不可变对象的影响</h2><p>Python 对象的可变性（mutability）对传参行为有显著影响：</p><ol><li><strong>不可变对象</strong>（immutable objects）：如整数（int）、字符串（str）、元组（tuple）。这些对象一旦创建就不能修改。<ul><li>如果函数尝试修改不可变对象的参数（例如重新赋值），实际上是创建了一个新对象，并绑定到参数名称上，但这不会影响调用者的原始变量。</li><li>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_num</span>(<span class="params">num</span>):</span><br><span class="line">    num = <span class="number">10</span>  <span class="comment"># 创建新整数对象 10，绑定到 num</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line">modify_num(x)</span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出 5，原始变量未变</span></span><br></pre></td></tr></table></figure></li><li>在这种情况下，行为类似于按值传递，因为无法修改原始对象。</li></ul></li><li><strong>可变对象</strong>（mutable objects）：如列表（list）、字典（dict）、集合（set）。这些对象可以被修改。<ul><li>如果函数修改可变对象的状态（例如追加列表元素），这些修改会反映到调用者的原始对象上，因为两者引用的是同一个对象。</li><li>例如：  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">modify_list</span>(<span class="params">lst</span>):</span><br><span class="line">    lst.append(<span class="number">4</span>)  <span class="comment"># 修改列表，影响原始对象</span></span><br><span class="line"></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">modify_list(y)</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出 [1, 2, 3, 4]，原始列表已改变</span></span><br></pre></td></tr></table></figure></li><li>在这种情况下，行为类似于按引用传递，因为可以修改原始对象。</li></ul></li></ol><p>然而，需要注意的是，如果函数内重新赋值参数（而不是修改对象内容），这不会影响原始变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reassign_list</span>(<span class="params">lst</span>):</span><br><span class="line">    lst = [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]  <span class="comment"># 重新绑定 lst 到新列表，原始对象不变</span></span><br><span class="line"></span><br><span class="line">y = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">reassign_list(y)</span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 输出 [1, 2, 3]，原始列表未变</span></span><br></pre></td></tr></table></figure><p>这表明，参数的重新赋值只影响函数内的局部命名空间，不会改变调用者的绑定。</p><h2 id="如何理解“传对象”"><a href="#如何理解“传对象”" class="headerlink" title="如何理解“传对象”"></a>如何理解“传对象”</h2><p>“传对象”意味着函数接收的是对象的引用，而不是对象本身的副本。以下是关键点：</p><ul><li>Python 中的变量是对象的引用，传递参数时，函数的参数绑定到与调用者相同的对象。</li><li>函数可以通过这个引用访问对象的内容，并根据对象的可变性决定是否能修改它。</li><li>如果对象是可变的，函数可以修改其状态，影响原始对象；如果对象是不可变的，函数只能创建新对象，原始对象不受影响。</li></ul><p>为了更直观地理解，可以将变量想象为指向对象的标签（label）。传递参数时，函数得到的是同一个标签的副本，但标签指向的对象是共享的：</p><ul><li>对于可变对象，修改对象内容相当于在同一个对象上操作，所有标签都会看到变化。</li><li>对于不可变对象，试图修改会创建新对象，函数内的标签指向新对象，而原始标签仍指向旧对象。</li></ul><h2 id="按值、引用、对象传递对比与总结"><a href="#按值、引用、对象传递对比与总结" class="headerlink" title="按值、引用、对象传递对比与总结"></a>按值、引用、对象传递对比与总结</h2><p>以下表格对比了按值传递、按引用传递与 Python 传参的差异：</p><table><thead><tr><th>机制</th><th>描述</th><th>Python 示例</th><th>影响原始变量</th></tr></thead><tbody><tr><td>按值传递（Pass by Value）</td><td>函数接收参数的副本，修改不影响原变量</td><td>num = 10，函数内赋值新值</td><td>否</td></tr><tr><td>按引用传递（Pass by Reference）</td><td>函数接收变量的引用，修改影响原变量</td><td>C++ 中的指针或引用传递</td><td>是</td></tr><tr><td>Python 按对象引用传递</td><td>函数接收对象的引用，可变对象可修改</td><td>列表追加元素，字典修改键值</td><td>是（可变对象，修改内容）</td></tr></tbody></table><p>Python 的传参机制结合了按值和按引用的特性，具体行为取决于对象的可变性。这种灵活性适合大多数场景，但需要开发者理解对象模型以避免误用。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad_append</span>(<span class="params">new_item, a_list=[]</span>):</span><br><span class="line">    a_list.append(new_item)</span><br><span class="line">    <span class="keyword">return</span> a_list</span><br></pre></td></tr></table></figure><p>执行两次 <code>print bad_append(&#39;one&#39;)</code> 的结果是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bad_append</span>(<span class="params">new_item, a_list=<span class="literal">None</span></span>):</span><br><span class="line">    a_list.append(new_item)</span><br><span class="line">    <span class="keyword">return</span> a_list</span><br></pre></td></tr></table></figure><p>执行两次 <code>print bad_append(&#39;one&#39;)</code> 的结果是什么？</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://foofish.net/python-function-args.html">Python 函数中，参数是传值，还是传引用？</a></li><li><a href="https://realpython.com/python-pass-by-reference/">Pass by Reference in Python: Background and Best Practices</a></li><li><a href="https://docs.python.org/3/reference/compound_stmts.html#function-definitions">8.7. Function definitions</a></li><li><a href="https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference">How do I pass a variable by reference?</a></li></ul>]]></content>
    
    
    <summary type="html">Python 的传参机制是按对象引用传递（call by object reference），结合了按值和按引用的特性，行为取决于对象的可变性。在 Python 中，所有变量都是对象的引用，传递参数时，函数接收的是指向同一对象的引用，而非副本。不可变对象（如整数、字符串）无法修改，函数内重新赋值会创建新对象，不影响原始变量，行为类似按值传递。可变对象（如列表、字典）允许修改内容，函数内的更改会反映到原始对象，类似按引用传递。然而，重新赋值参数仅影响函数局部命名空间，不改变调用者的绑定。这种机制源于 Python 的对象模型，变量是对象的标签，传递时共享对象引用。开发者需注意可变对象的默认参数陷阱，如使用列表作为默认参数可能导致意外共享。理解 Python 传参机制有助于避免误用，提高代码可预测性。通过合理管理对象引用和可变性，开发者可以在函数设计中实现高效、清晰的逻辑。</summary>
    
    
    
    
    <category term="Python" scheme="https://wu3227834.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
