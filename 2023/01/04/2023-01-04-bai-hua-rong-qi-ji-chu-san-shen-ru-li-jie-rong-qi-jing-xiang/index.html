<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:description" content="这里是小布丁的私有小屋"><meta property="og:type" content="website"><meta name="description" content="这里是小布丁的私有小屋"><link rel="shortcut icon" href="/img/favicon.ico"><title>白话容器基础（三）：深入理解容器镜像</title><link rel="stylesheet" href="/css/aircloud.css"><link rel="stylesheet" href="/css/gitment.css"><link rel="stylesheet" href="/css/prism.css"><link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css"><script></script><script defer src="https://cloud.umami.is/script.js" data-website-id="bad0a741-25cb-4dd6-bbcf-f5710aeb243c"></script><script>((e,t,s,n,r,a)=>{e[s]=e[s]||function(){(e[s].q=e[s].q||[]).push(arguments)},(r=t.createElement(n)).async=1,r.src="https://www.clarity.ms/tag/sgs1vujgeb?ref=bwt",(a=t.getElementsByTagName(n)[0]).parentNode.insertBefore(r,a)})(window,document,"clarity","script")</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Pudding 日常" type="application/atom+xml"></head><body><div class="site-nav-toggle" id="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><div class="index-about"><i>a week is 2% of the year</i></div><div class="index-container"><div class="index-left"><div class="nav" id="nav"><div class="avatar-name"><div class="avatar"><img src="/img/avatar.png"></div><div class="name"><i>Pudding</i></div></div><div class="contents" id="nav-content"><ul><li><a href="/"><i class="iconfont icon-shouye1"></i> <span>主页</span></a></li><li><a href="/tags"><i class="iconfont icon-biaoqian1"></i> <span>标签</span></a></li><li><a href="/archive"><i class="iconfont icon-guidang2"></i> <span>存档</span></a></li><li><a href="/about/"><i class="iconfont icon-guanyu2"></i> <span>关于</span></a></li><li><a id="search"><i class="iconfont icon-sousuo1"></i> <span>搜索</span></a></li></ul></div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-text">容器的一致性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Union-File-System"><span class="toc-text">Union File System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%8C%E5%8F%AA%E8%AF%BB%E5%B1%82"><span class="toc-text">第一部分，只读层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%8C%E5%8F%AF%E8%AF%BB%E5%86%99%E5%B1%82"><span class="toc-text">第二部分，可读写层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%8CInit-%E5%B1%82"><span class="toc-text">第三部分，Init 层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></div></div><div class="search-field" id="search-field"><div class="search-bg" id="search-bg"></div><div class="search-container"><div class="search-input"><span id="esc-search"><i class="icon-fanhui iconfont"></i></span> <input id="search-input"> <span id="begin-search">搜索</span></div><div class="search-result-container" id="search-result-container"></div></div></div><div class="index-about-mobile"><i>a week is 2% of the year</i></div></div><div class="index-middle"><div class="post-container"><div class="post-title">白话容器基础（三）：深入理解容器镜像</div><div class="post-meta"><span class="attr">发布于：<span>2023-01-04</span></span> <span class="attr">标签：/ <a class="tag" href="/tags/#Docker" title="Docker">Docker</a> <span>/</span> <a class="tag" href="/tags/#学习笔记" title="学习笔记">学习笔记</a> <span>/</span> </span><span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span></div><div class="post-content no-indent"><p>Linux 容器最基础的两种技术：Namespace 和 Cgroups，其中 Namespace 的作用是“隔离”，它让应用进程只能看到该 Namespace 内的“世界”；而 Cgroups 的作用是“限制”，它给这个“世界”围上了一圈看不见的墙。</p><p>这么一折腾，进程就真的被“装”在了一个与世隔绝的房间里，而这些房间就是 PaaS 项目赖以生存的应用“沙盒”。</p><p>可是，现在这个房间四周虽然有了墙，但是如果容器进程低头一看地面，又是怎样一副景象呢？</p><p>换句话说，容器里的进程看到的文件系统又是什么样子的呢？</p><p>可能你立刻就能想到，这一定是一个关于 Mount Namespace 的问题：容器里的应用进程，理应看到一份完全独立的文件系统。这样，它就可以在自己的容器目录（比如 /tmp）下进行操作，而完全不会受宿主机以及其他容器的影响。</p><p>但是，Mount Namespace 修改的是容器进程对文件系统“挂载点”的认知。这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。</p><p>因此，创建新进程时，除了声明要启用 Mount Namespace 之外，我们还应该告诉容器进程，有哪些目录需要重新挂载，就比如这个 /tmp 目录；更重要的是，因为我们创建的新进程启用了 Mount Namespace，所以这次重新挂载的操作，只在容器进程的 Mount Namespace 中有效。这就是 Mount Namespace 跟其他 Namespace 的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。</p><p>但是，作为一个普通用户，我们希望的是一个更友好的情况：每当创建一个新容器时，我希望容器进程看到的文件系统就是一个独立的隔离环境，而不是继承自宿主机的文件系统。那应该怎么才能做到这一点呢？</p><p>不难想到，我们可以在容器进程启动之前重新挂载它的整个根目录“/”。而由于 Mount Namespace 的存在，这个挂载对宿主机不可见，所以容器进程就可以在里面随便折腾了。</p><p>在 Linux 操作系统里，有一个名为 chroot 的命令可以帮助你在 shell 中方便地完成这个工作。顾名思义，它的作用就是帮你“change root file system”，即改变进程的根目录到你指定的位置。它的用法也非常简单。</p><p>假设，现在有一个 $HOME/test 目录，要让它作为一个 /bin/bash 进程的根目录。</p><p>首先，创建一个 test 目录和几个 lib 文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/test</span><br><span class="line">$ <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/test/&#123;bin,lib64,lib&#125;</span><br><span class="line">$ <span class="built_in">cd</span> <span class="variable">$T</span></span><br></pre></td></tr></table></figure><p>然后，把 bash 命令拷贝到 test 目录对应的 bin 路径下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -v /bin/&#123;bash,<span class="built_in">ls</span>&#125; <span class="variable">$HOME</span>/test/bin</span><br></pre></td></tr></table></figure><p>接下来，把 bash 命令需要的所有 so 文件，也拷贝到 test 目录对应的 lib 路径下。找到 so 文件可以用 ldd 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ T=<span class="variable">$HOME</span>/test</span><br><span class="line">$ list=<span class="string">&quot;<span class="subst">$(ldd /bin/ls | egrep -o &#x27;/lib.*\.[0-9]&#x27;)</span>&quot;</span></span><br><span class="line">$ <span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$list</span>; <span class="keyword">do</span> <span class="built_in">cp</span> -v <span class="string">&quot;<span class="variable">$i</span>&quot;</span> <span class="string">&quot;<span class="variable">$&#123;T&#125;</span><span class="variable">$&#123;i&#125;</span>&quot;</span>; <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>最后，执行 chroot 命令，告诉操作系统，我们将使用 $HOME/test 目录作为 /bin/bash 进程的根目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">chroot</span> <span class="variable">$HOME</span>/test /bin/bash</span><br></pre></td></tr></table></figure><p>这时，你如果执行 “ls /“，就会看到，它返回的都是 $HOME/test 目录下面的内容，而不是宿主机的内容。</p><p>更重要的是，对于被 chroot 的进程来说，它并不会感受到自己的根目录已经被“修改”成 $HOME/test 了。</p><p>这种视图被修改的原理，是不是和 Linux Namespace 很类似呢？</p><p>没错！</p><p><strong>实际上，Mount Namespace 正是基于对 chroot 的不断改良才被发明出来的，它也是 Linux 操作系统里的第一个 Namespace。</strong></p><p>当然，为了能够让容器的这个根目录看起来更“真实”，我们一般会在这个容器的根目录下挂载一个完整操作系统的文件系统，比如 Ubuntu16.04 的 ISO。这样，在容器启动之后，我们在容器里通过执行 “ls /“ 查看根目录下的内容，就是 Ubuntu 16.04 的所有目录和文件。</p><p><strong>而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。</strong></p><p>所以，一个最常见的 rootfs，或者说容器镜像，会包括如下所示的一些目录和文件，比如 /bin，/etc，/proc 等等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /</span><br><span class="line">bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var</span><br></pre></td></tr></table></figure><p>而你进入容器之后执行的 /bin/bash，就是 /bin 目录下的可执行文件，与宿主机的 /bin/bash 完全不同。</p><p>现在，你应该可以理解，对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：</p><ol><li>启用 Linux Namespace 配置</li><li>设置指定的 Cgroups 参数</li><li>切换进程的根目录（Change Root）</li></ol><p>这样，一个完整的容器就诞生了。不过，Docker 项目在最后一步的切换上会优先使用 pivot_root 系统调用，如果系统不支持，才会使用 chroot。</p><p>另外，<strong>需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。</strong></p><p>所以说，rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。</p><p>那么，对于容器来说，这个操作系统的“灵魂”又在哪里呢？</p><p>实际上，同一台机器上的所有容器，都共享宿主机操作系统的内核。</p><p>这就意味着，如果你的应用程序需要配置内核参数、加载额外的内核模块，以及跟内核进行直接的交互，你就需要注意了：这些操作和依赖的对象，都是宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。</p><p>这是容器相较于虚拟机的缺陷之一：毕竟后者不仅有模拟出来的硬件机器当作沙盒，而且每个沙盒里还运行着一个完整的 Guest OS 给应用随便折腾。</p><p>不过，<strong>正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：一致性。</strong></p><p>什么是容器的“一致性”呢？</p><h2 id="容器的一致性"><a href="#容器的一致性" class="headerlink" title="容器的一致性"></a>容器的一致性</h2><p>由于云端与本地服务器环境不同，应用的打包过程，一直是使用 PaaS 时最“痛苦”的一个步骤。</p><p>但有了容器之后，更准确地说，有了容器镜像（即 rootfs）之后，这个问题被非常优雅地解决了。</p><p><strong>由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。</strong></p><p>事实上，对于大多数开发者而言，他们对应用依赖的理解，一直局限在编程语言层面。比如Golang 的 Godeps.json。但实际上，一个一直以来很容易被忽视的事实是，<strong>对一个应用来说，操作系统本身才是它运行所需要的最完整的“依赖库”</strong>。</p><p>有了容器镜像“打包操作系统”的能力，这个最基础的依赖环境也终于变成了应用沙盒的一部分。这就赋予了容器所谓的一致性：无论在本地、云端，还是在一台任何地方的机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就被重现出<br>来了。</p><p><strong>这种深入到操作系统级别的运行环境一致性，打通了应用在本地开发和远端执行环境之间难以逾越的鸿沟。</strong></p><p>不过，这时你可能已经发现了另一个非常棘手的问题：难道我每开发一个应用，或者升级一下现有的应用，都要重复制作一次 rootfs 吗？</p><p>比如，我现在用 Ubuntu 操作系统的 ISO 做了一个 rootfs，然后又在里面安装了 Java 环境，用来部署我的 Java 应用。那么，我的另一个同事在发布他的 Java 应用时，显然希望能够直接使用我安装过 Java 环境的 rootfs，而不是重复这个流程。</p><p>一种比较直观的解决办法是，我在制作 rootfs 的时候，每做一步“有意义”的操作，就保存一个 rootfs 出来，这样其他同事就可以按需求去用他需要的 rootfs 了。</p><p>但是，这个解决办法并不具备推广性。原因在于，一旦你的同事们修改了这个 rootfs，新旧两个 rootfs 之间就没有任何关系了。这样做的结果就是极度的碎片化。</p><p>那么，既然这些修改都基于一个旧的 rootfs，我们能不能以增量的方式去做这些修改呢？这样做的好处是，所有人都只需要维护相对于 base rootfs 修改的增量内容，而不是每次修改都制造一个“fork”。</p><p>答案当然是肯定的。</p><p>这也正是为何，Docker 公司在实现 Docker 镜像时并没有沿用以前制作 rootfs 的标准流程，而是做了一个小小的创新：</p><blockquote><p>Docker 在镜像的设计中，引入了层（layer）的概念。也就是说，用户制作镜像的每一步操作，都会生成一个层，也就是一个增量 rootfs。</p></blockquote><p>当然，这个想法不是凭空臆造出来的，而是用到了一种叫作联合文件系统（Union File System）的能力。</p><p>Union File System 也叫 UnionFS，最主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。比如，我现在有两个目录 A 和 B，它们分别有两个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│ ├── a</span><br><span class="line">│ └── x</span><br><span class="line">└── B</span><br><span class="line"> ├── b</span><br><span class="line"> └── x</span><br></pre></td></tr></table></figure><p>然后，我使用联合挂载的方式，将这两个目录挂载到一个公共的目录 C 上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> C</span><br><span class="line">$ mount -t aufs -o <span class="built_in">dirs</span>=./A:./B none ./C</span><br></pre></td></tr></table></figure><p>这时，我再查看目录 C 的内容，就能看到目录 A 和 B 下的文件被合并到了一起：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tree ./C</span><br><span class="line">./C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br></pre></td></tr></table></figure><p>可以看到，在这个合并后的目录 C 里，有 a、b、x 三个文件，并且 x 文件只有一份。这就是“合并”的含义。此外，如果你在目录 C 里对 a、b、x 文件做修改，这些修改也会在对应的目录 A、B 中生效。</p><p>那么，在 Docker 项目中，又是如何使用这种 Union File System 的呢？</p><h2 id="Union-File-System"><a href="#Union-File-System" class="headerlink" title="Union File System"></a>Union File System</h2><p>如果你的环境是 Ubuntu 16.04 和 Docker CE 18.05，这对组合默认使用的是 AuFS 这个联合文件系统的实现。你可以通过 docker info 命令，查看到这个信息。</p><p>对于 AuFS 来说，它最关键的目录结构在 /var/lib/docker 路径下的 diff 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/aufs/diff/&lt;layer_id&gt;</span><br></pre></td></tr></table></figure><p><strong>而这个目录的作用，我们不妨通过一个具体例子来看一下。</strong></p><p>现在，我们启动一个容器，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu:latest <span class="built_in">sleep</span> 3600</span><br></pre></td></tr></table></figure><p>这时候，Docker 就会从 Docker Hub 上拉取一个 Ubuntu 镜像到本地。</p><p>这个所谓的“镜像”，实际上就是一个 Ubuntu 操作系统的 rootfs，它的内容是 Ubuntu 操作系统的所有文件和目录。不过，与之前我们讲述的 rootfs 稍微不同的是，Docker 镜像使用的 rootfs，往往由多个“层”组成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ docker image inspect ubuntu:latest</span><br><span class="line">...</span><br><span class="line">    <span class="string">&quot;RootFS&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Layers&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;sha256:f49017d4d5ce9c0f544c...&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:8f2b771487e9d6354080...&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:ccd4d61916aaa2159429...&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:c01d74f99de40e097c73...&quot;</span>,</span><br><span class="line">            <span class="string">&quot;sha256:268a067217b5fe78e000...&quot;</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个 Ubuntu 镜像，实际上由五个层组成。这五个层就是五个增量 rootfs，每一层都是 Ubuntu 操作系统文件与目录的一部分；而在使用镜像时，Docker 会把这些增量联合挂载在一个统一的挂载点上（等价于前面例子里的“/C”目录）。</p><p>这个挂载点就是 /var/lib/docker/aufs/mnt/，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fc...</span><br></pre></td></tr></table></figure><p>不出意外的话，这个目录里面正是一个完整的 Ubuntu 操作系统：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fc...</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>那么，前面提到的五个镜像层，又是如何被联合挂载成这样一个完整的 Ubuntu 文件系统的呢？</p><p>这个信息记录在 AuFS 的系统目录 /sys/fs/aufs 下面。</p><p>首先，通过查看 AuFS 的挂载信息，我们可以找到这个目录对应的 AuFS 的内部 ID（也叫：si）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /proc/mounts| grep aufs</span><br><span class="line">none /var/lib/docker/aufs/mnt/6e3be5d2ecccae7cc0fc... aufs rw,relatime,si=972c6d361e6b32ba</span><br></pre></td></tr></table></figure><p>然后使用这个 ID，你就可以在 /sys/fs/aufs 下查看被联合挂载在一起的各个层的信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/fs/aufs/si_972c6d361e6b32ba/br[0-9]*</span><br><span class="line">/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...=rw</span><br><span class="line">/var/lib/docker/aufs/diff/6e3be5d2ecccae7cc...-init=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/32e8e20064858c0f2...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/2b8858809bce62e62...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/20707dce8efc0d267...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/72b0744e06247c7d0...=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/a524a729adadedb90...=ro+wh</span><br></pre></td></tr></table></figure><p>从这些信息里，我们可以看到，镜像的层都放置在 /var/lib/docker/aufs/diff 目录下，然后被联合挂载在 /var/lib/docker/aufs/mnt 里面。</p><p><strong>而且，从这个结构可以看出来，这个容器的 rootfs 由如下图所示的三部分组成：</strong></p><p><img src="/img/2023-01-04-%E7%99%BD%E8%AF%9D%E5%AE%B9%E5%99%A8%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F/pho1.png" alt="rootfs"></p><h3 id="第一部分，只读层"><a href="#第一部分，只读层" class="headerlink" title="第一部分，只读层"></a>第一部分，只读层</h3><p>它是这个容器的 rootfs 最下面的五层，对应的正是 ubuntu:latest 镜像的五层。可以看到，它们的挂载方式都是只读的（ro+wh，即 readonly+whiteout）。</p><p>这时，我们可以分别查看一下这些层的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> /var/lib/docker/aufs/diff/72b0744e06247c7d0...</span><br><span class="line">etc sbin usr var</span><br><span class="line">$ <span class="built_in">ls</span> /var/lib/docker/aufs/diff/32e8e20064858c0f2...</span><br><span class="line">run</span><br><span class="line">$ <span class="built_in">ls</span> /var/lib/docker/aufs/diff/a524a729adadedb900...</span><br><span class="line">bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</span><br></pre></td></tr></table></figure><p>可以看到，这些层，都以增量的方式分别包含了 Ubuntu 操作系统的一部分。</p><h3 id="第二部分，可读写层"><a href="#第二部分，可读写层" class="headerlink" title="第二部分，可读写层"></a>第二部分，可读写层</h3><p>它是这个容器的 rootfs 最上面的一层（6e3be5d2ecccae7cc），它的挂载方式为：rw，即 read write。在没有写入文件之前，这个目录是空的。而一旦在容器里做了写操作，你修改所产生的内容就会以增量的方式出现在这个层中。</p><p>可是，你有没有想到这样一个问题：如果我现在要做的是，删除只读层里的一个文件呢？</p><p><font color="pink">为了实现这样的删除操作，AuFS 会在可读写层创建一个 whiteout 文件，把只读层里的文件“遮挡”起来。</font></p><p>比如，你要删除只读层里一个名叫 foo 的文件，那么这个删除操作实际上是在可读写层创建了一个名叫 .wh.foo 的文件。这样，当这两个层被联合挂载之后，foo 文件就会被 .wh.foo 文件“遮挡”起来，“消失”了。这个功能，就是“ro+wh”的挂载方式，即只读 +whiteout 的含义。</p><p>所以，最上面这个可读写层的作用，就是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。</p><h3 id="第三部分，Init-层"><a href="#第三部分，Init-层" class="headerlink" title="第三部分，Init 层"></a>第三部分，Init 层</h3><p>它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init 层是 Docker 项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf 等信息。</p><p>需要这样一层的原因是，这些文件本来属于只读的 Ubuntu 镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如 hostname，所以就需要在可读写层对它们进行修改。</p><p>可是，这些修改往往只对当前的容器有效，我们并不希望执行 docker commit 时，把这些信息连同可读写层一起提交掉。</p><p>所以，Docker 做法是，在修改了这些文件之后，以一个单独的层挂载了出来。而用户执行docker commit 只会提交可读写层，所以是不包含这些内容的。</p><p>最终，这 7 个层都被联合挂载到 /var/lib/docker/aufs/mnt 目录下，表现为一个完整的 Ubuntu 操作系统供容器使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Linux 容器文件系统的实现方式机制：rootfs。它只是一个操作系统的所有文件和目录，并不包含内核，最多也就几百兆。而相比之下，传统虚拟机的镜像大多是一个磁盘的“快照”，磁盘有多大，镜像就至少有多大。</p><p>通过结合使用 Mount Namespace 和 rootfs，容器就能够为进程构建出一个完善的文件系统隔离环境。当然，这个功能的实现还必须感谢 chroot 和 pivot_root 这两个系统调用切换进程根目录的能力。</p><p>而在 rootfs 的基础上，Docker 公司创新性地提出了使用多个增量 rootfs 联合挂载一个完整 rootfs 的方案，这就是容器镜像中“层”的概念。</p><p>通过“分层镜像”的设计，以 Docker 镜像为核心，来自不同公司、不同团队的技术人员被紧密地联系在了一起。而且，由于容器镜像的操作是增量式的，这样每次镜像拉取、推送的内容，比原本多个完整的操作系统的大小要小得多；而共享层的存在，可以使得所有这些容器镜像需要的总空间，也比每个镜像的总和要小。这样就使得基于容器镜像的团队协作，要比基于动则几个 GB 的虚拟机磁盘镜像的协作要敏捷得多。</p><p>更重要的是，一旦这个镜像被发布，那么你在全世界的任何一个地方下载这个镜像，得到的内容都完全一致，可以完全复现这个镜像制作者当初的完整环境。这，就是容器技术“强一致性”的重要体现。</p><p>而这种价值正是支撑 Docker 公司在 2014~2016 年间迅猛发展的核心动力。容器镜像的发明，不仅打通了“开发 - 测试 - 部署”流程的每一个环节，更重要的是：</p><center><font color="red">容器镜像将会成为未来软件的主流发布方式。</font></center><br><div id="comment-container"></div><div id="disqus_thread"></div><div id="lv-container"></div><div class="giscus"></div></div></div></div></div><footer class="footer"><ul class="list-inline text-center"><li><a target="_blank" href="https://github.com/wu3227834" rel="external nofollow noreferrer"><span class="fa-stack fa-lg"><i class="iconfont icon-github"></i></span></a></li></ul><p><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span>PV </span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span>UV </span>Created By <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> Theme <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script><script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script type="text/javascript" src="/js/clipboard.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body><script>window.hexo_search_path="search.json",window.hexo_root="/",window.isPost=!0</script><script src="/js/index.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/jquery.min.js"></script><script src="/js/prism.js"></script><script src="https://giscus.app/client.js" data-repo="wu3227834/wu3227834.github.io" data-repo-id="R_kgDOIh8vuA" data-category="General" data-category-id="DIC_kwDOIh8vuM4CpDjz" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></html><script src="/js/fancybox/jquery.fancybox.min.js" key="fancybox_js"></script><script src="/js/fancybox/wrapImage.js" key="wrap_image_js"></script><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" key="fancybox_css">