---
layout: mypost
title: Raft 论文学习笔记
categories: [Raft]
---

# <center> Raft 论文精读笔记｜In Search of an Understandable Consensus Alg orithm (Extended Version) </center>

> In Search of an Understandable Consensus Alg orithm (Extended Version)
寻找⼀种易于理解的⼀致性算法（扩展版）

这篇文章完全按照某乎大佬的文章————<a href="https://zhuanlan.zhihu.com/p/514512060?utm_id=0">《 Raft 论文精读笔记｜In Search of an Understandable Consensus Alg orithm (Extended Version) 》</a>的内容做的笔记，也加入了部分自己的理解。

## 1. 背景（Abstract & Introduction）

什么是一致性算法和共识算法？

<ol>
  <li>一致性算法是指通过协调分布系统中各个节点来实现数据一致性的算法。常见的一致性算法有两类：基于副本的一致性算法和基于共享的一致性算法。基于副本的一致性算法通过在不同节点之间复制数据来实现数据的一致性；而基于共享的一致性算法则通过协调节点之间的访问来实现数据的一致性。</li>
  <li>共识算法是一种特殊的一致性算法，主要用在分布式系统中达成一致性决策。共识算法通常包括一个选举过程，用于选举一个领导者节点，并通过领导者节点的协调来实现数据的一致性。通常的共识算法包括 Paxos 和 Raft。</li>
  <li>两者的区别在于：共识算法主要关注如何在分布式系统中达成一致性决策，而一致性算法更关注如何在分布式系统中实现数据一致性。</li>
</ol>

朴素地讲，一致性算法（或共识算法），就是让一组机器像一个整体一样工作，即使其中一些机器出现故障也能够继续工作。

而 Raft 是⼀种为了管理复制⽇志的⼀致性算法。它将一致性算法分解成了几个关键模块：领导人选举、日志复制和安全性。同时它通过更强的一致性来减少状态机的数量。

总之，对比传统的一致性算法 Paxos，Raft 更清晰易懂，易于实现。（Paxos 算法：<a href="https://wu3227834.github.io/posts/2022/12/14/%E5%9B%BE%E8%A7%A3-Paxos-%E7%AE%97%E6%B3%95.html">《图解 Paxos 算法》</a>）它有几个独特特性：

<ul>
  <li>强领导性：例如日志条目只从领导者发送给其他的服务器，简化了对日志的管理并更好理解</li>
  <li>领导选举：用随机计时器来选举领导者，基于心跳机制实现，用于解决冲突</li>
  <li>成员关系调整：使得集群在成员变换的时候依然可以继续工作</li>
</ul>

## 2.复制状态机（Replicated state machines）

⼤规模的系统中通常都有⼀个集群领导者（Primary，论文中用的 Leader），⼀个独⽴的复制状态机管理领导选举和存储配置信息并且在领导⼈宕机的情况下存活下来。

复制状态机是指多台机器具有完全相同的状态，运行完全相同的确定性状态机。这多台机器组成一个整体对外服务，其中部分机器失效不影响整体的可用性。

Raft 提出了如图（Raft 提出的复制状态机架构）所示的复制状态机架构，通过**复制日志**来实现复制状态机，复制日志又使用共识（Consensus）协议来实现，保证日志的一致性。

![图 1](raft-图1.png)

**保证复制⽇志相同就是⼀致性算法的⼯作。**一致性模块（图中 Consensus Module）接受客户指令，生成日志，和其他 Backup 通信传递日志。

实际使用的一致性算法有以下特征：

<ul>
  <li><b>安全性</b>：非拜占庭错误情况下，绝不会返回错误的结果</li>
  <li><b>可用性</b>：只要大多数机器正常就可保证可用</li>
  <li><b>不依赖时序保证一致性</b></li>
  <li>一条指令大多数节点可一轮 RPC 完成，小部分慢节点不影响整体性能</li>
</ul>

## 3.Paxos 算法的问题（What’s wrong with Paxos?）

Paxos ⾸先定义了⼀个能够达成单⼀决策⼀致的协议，⽐如单条的复制⽇志项。这⼀⼦集叫做单决策 Paxos。然后通过组合多个 Paxos 协议的实例来促进⼀系列决策的达成。

Paxos 是大多数一致性算法的起点，理论上证明可行，但是有两个明显缺点：

<ol>
  <li>特别难以理解。不直观、不透明。</li>
  <li>理论可行，实际实现困难，不易于构建实践系统。</li>
</ol>

Raft 算法就是尝试克服以上缺点，替代 Paxos 的一致性算法。

## 4.为了可理解性的设计（Designing for understandability）

设计 Raft 的初衷：

<ul>
  <li>提供⼀个完整的实际的系统实现基础：大大减少开发者的工作</li>
  <li>任何情况下都是安全的</li>
  <li>⼤多数的情况下都是可⽤的</li>
  <li>⼤部分操作必须是⾼效的</li>
  <li>可理解性：（最重要、最大挑战）保证普遍⼈都可以容易理解</li>
  <li>能够让⼈形成直观的认识：使系统的构建者能够在现实中进⾏必然的扩展</li>
</ul>

为了可理解性做的工作：
<ul>
  <li><b>问题分解：</b>尽可能将问题分解成几个相对独立的、可被解决的、可解释的和可理解的子问题。Raft 算法被分成领导人选举、日志复制、安全性和角色改变几个部分。
  <li><b>减少状态的数量</b>来简化需要考虑的状态空间：使得系统更加连贯并且可能的时候消除不确定性。</li>
  <li><b>随机化方法</b>增加了不确定性，但是有利于减少状态空间数量，通过处理所有可能选择时使用相似的方法。</li>
  </li>使用随机化去简化 Raft 中领导人选举算法。
</ul>

## 5. Raft 共识算法（The Raft consensus algorithm）

Raft 是一种用来管理第 2 部分中描述的复制日志的算法。图 2 是这个算法的简略版，图 3 列举了这个算法的关键特性。

Raft 选举一个 Leader，给予管理所有复制日志的权限，由此实现一致性。

Leader 从客户接受指令，写入日志，复制到其他 Backup Server 上，在保证安全性时通知其他 Server 根据日志执行指令更新状态机。

Leader 大大简化了对日复制日志的管理。Leader 可以自行决定新日志写入位置，数据都从 Leader 流向其他 Server。当 Leader 宕机，其他 Server 中选举一个新 Leader。

由此 Raft 将一致性问题分解为三个子问题：
<ul>
  <li><b>领导选举：</b>旧 Leader 宕机选举新 Leader（5.2 节）</li>
  <li><b>日志复制：</b>Leader 接受日志，复制到其他节点并保持一致。</li>
  <li><b>安全性：</b>关键在于状态机安全（图 3）：某节点应用某个日志条目到状态机，其他节点不能在此条目应用不同指令。（5.4 节）</li>
  <li>此外还涉及一个额外的选举机制上的限制（5.2 节）</li>
</ul>

### 两张图

图 2 是 Raft 算法的简略版，图 3 列举了 Raft 算法的关键特性。

> 对两个图片内容进行了全面的翻译。

![图 2](raft-图2.png)

> 一个关于 Raft 一致性算法的浓缩总结（不包括成员变换和日志压缩）

#### State（状态）

<b>所有服务器上持久存在的：</b>
（在响应 RPCs 之前已在稳定的存储上进行更新）

| 参数 | 含义 |
| --- | --- |
| currentTerm | 服务器最后一次知道的任期号（初始化为 0，持续递增） |
| votedFor | 在当前获得选票的候选人的 ID （如果没有则为 null） |
| log[] | 日志条目集；每个条目包含一个用户状态机执行的指令，和收到时的任期号 |

<b>所有服务器上经常变的：</b>

| 参数 | 含义 |
| --- | --- |
| commitIndex | 已知的最⼤的已经被提交的⽇志条⽬的索引值 |
| lastApplied | 最后被应用到状态机的日志条目索引值（初始化为 0，持续递增） |

<b>在领导人里经常改变的：</b>
（选举后初始化）
| 参数 | 含义 |
| --- | --- |
| nextIndex[] | 对于每⼀个服务器，需要发送给他的下⼀个⽇志条⽬的索引值（初始化为领导⼈最后索引值加⼀） |
| matchIndex[] | 对于每⼀个服务器，已经复制给他的⽇志的最⾼索引值 |

#### AppendEntries RPC（追加待同步⽇志 RPC）

由 Leader 负责调⽤来复制⽇志（5.3）；也会⽤作心跳（5.2）

<b>传入参数</b>

| 参数 | 含义 |
| --- | --- |
| term | 领导人的任期号 |
| leadId | 领导人的 ID，以便于更随者重定向请求 |
| prevLogIndex | 新的日志条目紧随之前的索引值 |
| prevLogTerm | prevLogIndex 条目的任期号 |
| entries[] | 准备存储的日志条目（表示心跳时为空；一次性发送多个是为了提高效率） |
| leaderCommit | 领导人已经提交的日志的索引值 |

<b>返回值：</b>

| 参数 | 含义 |
| --- | --- |
| term | 当前的任期号，用于领导人去更新自己 |
| success | 跟随者包含了匹配上 prevLogIndex 和 prevLogTerm 的日志时为真 |

<b>接受者实现：</b>

<ol>
  <li> 如果 term < currentTerm 就返回 false （5.1 节）</li>
  <li> 如果日志在 prevLogIndex 位置处的日志条目的任期号和 preLogTerm 不匹配，则返回 false（5.3 节）</li>
  <li> 如果现有的日志条目和新的产生冲突（索引值相同但是任期号不同），删除现有的和之后所有的条目（5.3 节）</li>
  <li> 追加日志中尚未存在的任何新条目</li>
  <li> 如果 leaderCommit > commitIndex，令 commitIndex = min(leaderCommit, 新日志条目索引)</li>
</ol>

#### RequestVote RPC（请求投票 RPC）

由候选⼈调⽤⽤来征集选票（5.2 节）

<b>传入参数</b>

| 参数 | 含义 |
| --- | --- |
| term | 领导人的任期号 |
| candidateId | 请求选票的候选人的 ID |
| lastLogIndex | 候选⼈的最后⽇志条⽬的索引值 |
| lastLogTerm | 候选⼈最后⽇志条⽬的任期号 |

<b>返回值：</b>

| 参数 | 含义 |
| --- | --- |
| term | 当前任期号，以便于候选⼈去更新⾃⼰的任期号 |
| voteGranted | 候选⼈赢得了此张选票时为 true |

<b>接受者实现：</b>

<ol>
  <li> 如果 term < currentTerm 就返回 false （5.2 节）</li>
  <li> 如果 votedFor 为 null 或者为 candidateId，并且候选人的日志至少和接收者一样新，那么就给它投票（5.2 节，5.4 节）</li>
</ol>

### Rules for Servers（服务器的规则）

<b>所有服务器：</b>

<ul>
  <li> 如果 commitIndex > lastApplied，那么就 lastApplied 加一，并把 log[llastApplied] 应用到状态机中（5.3 节）</li>
  <li>如果接收到 RPC 请求或响应中，任期号 T > currentTerm，那么就令 currentTerm 等于 T，并切换状态为 Follower（5.1 节）
</ul>