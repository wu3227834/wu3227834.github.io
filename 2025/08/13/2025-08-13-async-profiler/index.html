<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:description" content="这里是小布丁的私有小屋"><meta property="og:type" content="website"><meta name="keywords" content="async-profiler, Java, 性能分析, Safepoint, 内存泄漏,"><meta name="description" content="async-profiler 是一个低开销 Java 性能分析器，规避 Safepoint 偏差，支持 CPU、内存分配、锁争用等多种分析模式，适用于 HotSpot JVM，提供精确的栈跟踪和内存泄漏检测。"><link rel="shortcut icon" href="/img/favicon.ico"><title>async-profiler</title><link rel="stylesheet" href="/css/aircloud.css"><link rel="stylesheet" href="/css/gitment.css"><link rel="stylesheet" href="/css/prism.css"><link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css"><script></script><script defer src="https://cloud.umami.is/script.js" data-website-id="bad0a741-25cb-4dd6-bbcf-f5710aeb243c"></script><script type="text/javascript">((e,t,s,n,a,c)=>{e[s]=e[s]||function(){(e[s].q=e[s].q||[]).push(arguments)},(a=t.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/sgs6id3d37",(c=t.getElementsByTagName(n)[0]).parentNode.insertBefore(a,c)})(window,document,"clarity","script")</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Pudding 日常" type="application/atom+xml"></head><body><div class="site-nav-toggle" id="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><div class="index-about"><i>a week is 2% of the year</i></div><div class="index-container"><div class="index-left"><div class="nav" id="nav"><div class="avatar-name"><div class="avatar"><img src="/img/avatar.png"></div><div class="name"><i>Pudding</i></div></div><div class="contents" id="nav-content"><ul><li><a href="/"><i class="iconfont icon-shouye1"></i> <span>主页</span></a></li><li><a href="/tags"><i class="iconfont icon-biaoqian1"></i> <span>标签</span></a></li><li><a href="/archive"><i class="iconfont icon-guidang2"></i> <span>存档</span></a></li><li><a href="/about/"><i class="iconfont icon-guanyu2"></i> <span>关于</span></a></li><li><a id="search"><i class="iconfont icon-sousuo1"></i> <span>搜索</span></a></li></ul></div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A8%A1%E5%BC%8F"><span class="toc-text">性能分析模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E5%88%86%E6%9E%90"><span class="toc-text">CPU 分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ALLOCATION-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">ALLOCATION 性能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native-memory-leaks"><span class="toc-text">Native memory leaks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wall-clock-%E5%88%86%E6%9E%90"><span class="toc-text">Wall-clock 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock-%E5%88%86%E6%9E%90"><span class="toc-text">Lock 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">Java 方法分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native-function-%E5%88%86%E6%9E%90"><span class="toc-text">Native function 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multiple-events"><span class="toc-text">Multiple events</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E2%80%93all-%E8%BF%9B%E8%A1%8C%E5%A4%9A%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90"><span class="toc-text">使用 –all 进行多事件分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">连续性能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#perf-event-types-supported-on-Linux"><span class="toc-text">perf event types supported on Linux</span></a></li></ol></div></div><div class="search-field" id="search-field"><div class="search-bg" id="search-bg"></div><div class="search-container"><div class="search-input"><span id="esc-search"><i class="icon-fanhui iconfont"></i></span> <input id="search-input"> <span id="begin-search">搜索</span></div><div class="search-result-container" id="search-result-container"></div></div></div><div class="index-about-mobile"><i>a week is 2% of the year</i></div></div><div class="index-middle"><div class="post-container"><div class="post-title">async-profiler</div><div class="post-meta"><span class="attr">发布于：<span>2025-08-13</span></span> <span class="attr">标签：/ <a class="tag" href="/tags/#Java" title="Java">Java</a> <span>/</span> <a class="tag" href="/tags/#Profiler" title="Profiler">Profiler</a> <span>/</span> </span><span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span></div><div class="post-content no-indent"><p>前两篇文章介绍了 jvm 中的安全点机制，以及为什么（大多数）分析器都很难用。这篇文章介绍一下 async-profiler 这个工具。</p><p>这个项目是一个针对 Java 的低开销采样性能分析器，不受 Safepoint 偏差问题的影响。它具有 HotSpot 特定的 API, 用于收集堆栈跟踪和跟踪内存分配。该性能分析器可与 OpenJDK 和其他基于 HotSpot JVM 的 Java 运行时配合使用。<br>项目文档地址：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/async-profiler/async-profiler/tree/master/docs">async-profiler/docs/</a></p><h2 id="性能分析模式"><a href="#性能分析模式" class="headerlink" title="性能分析模式"></a>性能分析模式</h2><p>除了 CPU 时间，async-profiler 还提供了各种其他性能分析模式，如 Allocation, Wall Clock, Java Method，甚至是 Multiple Events 性能分析模式。</p><h3 id="CPU-分析"><a href="#CPU-分析" class="headerlink" title="CPU 分析"></a>CPU 分析</h3><p>在这种模式下，性能分析器收集栈跟踪样本，其中包括 <strong>Java 方法、原生调用、JVM 代码和内核函数</strong>。</p><p>通用方法是接收 <code>perf_events</code> 生成的调用栈，并将它们与 AsyncGetCallTrace 生成的调用栈进行匹配，以生成 Java 和本机代码的准确性分析。此外，Async-profiler 提供了一种解决方案，用于在 <code>AsyncGetCallTrace</code> 失败的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://bugs.openjdk.org/browse/JDK-8178287">某些案例情况</a>恢复栈跟踪。</p><p>与直接在 Java 代理中使用 <code>perf_events</code> 相比，这种方法具有以下优势，后者可以将地址转换为 Java 方法名称：</p><ul><li>不需要 <code>-XX:+PreserveFramePointer</code>, 这会引入性能开销，有时高达 10%</li><li>不需要在 JVM 开始时使用代理将 Java 代码地址转换为方法名称</li><li>显示解释器帧</li><li>不会生成大型中间文件（perf.data），一边在用户空间脚本中进一步处理</li></ul><p>如果希望在 libjvm 中解析帧，则需要使用调试符号。</p><h2 id="ALLOCATION-性能分析"><a href="#ALLOCATION-性能分析" class="headerlink" title="ALLOCATION 性能分析"></a>ALLOCATION 性能分析</h2><p>可以将性能呢分析器配置为收集分配了最大量堆内存的调用站点。</p><p>Async-profiler 不使用字节码探测或昂贵的 DTrace 探针等侵入性技术，这些技术对性能有显著影响。它也不影响 Escape Analysis 或阻止 JIT 优化 (如分配消除)。只测量实际的堆分配。</p><p>性能分析器具有 TLAB(Thread Local Allocation Buffer, 线程本地分配缓存) 驱动的采样功能。它依赖于 HotSpot 特定的回调来接收两种类型的通知：</p><ul><li>当在新创建的 TLAB 中分配对象时</li><li>当在 TLAB 之外的慢速路径上分配对象时</li></ul><p>可以使用 <code>--alloc</code> 选项调整采样间隔。例如 <code>--alloc 500k</code> 将在平均分配空间 500KB 后采样一次。在 JDK 11 之前，小于 TLAB 大小的间隔不会生效。</p><p>在分配分析模式下，每个调用跟踪的顶帧是分配对象的类，计数器是堆压力（分配的 TLAB 或 TLAB 外对象的总大小）。</p><h2 id="Native-memory-leaks"><a href="#Native-memory-leaks" class="headerlink" title="Native memory leaks"></a>Native memory leaks</h2><p>性能分析模式 <code>nativemem</code> 记录 <code>malloc</code>、<code>relloc</code>、<code>calloc</code> 和 <code>free</code> 地址，以便将分配与空闲调用进行匹配。这有助于将性能分析报告仅集中在非空闲分配上，这些分配可能是内存泄漏的来源。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asprof start -e nativemem -f app.jfr &lt;YourApp&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line">asprof start --nativemem N -f app.jfr &lt;YourApp&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or <span class="keyword">if</span> only allocation calls are interesting, <span class="keyword">do</span> not collect free calls:</span></span><br><span class="line">asprof start --nativemem N --nofree -f app.jfr &lt;YourApp&gt;</span><br><span class="line"></span><br><span class="line">asprof stop &lt;YourApp&gt;</span><br></pre></td></tr></table></figure><p>现在我们需要处理 jfr 文件，以查找原生内存泄漏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--total <span class="keyword">for</span> bytes, default counts invocations.</span></span><br><span class="line">jfrconv --total --nativemem --leak app.jfr app-leak.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">No leak analysis, include all native allocations:</span></span><br><span class="line">jfrconv --total --nativemem app.jfr app-malloc.html</span><br></pre></td></tr></table></figure><p>当使用 <code>--leak</code> 选项时，生成的火焰图将显示未匹配免费调用的分配。</p><p><img src="/img/2025-08-13-async-profiler/nativemem_flamegraph.png" alt="火焰图"></p><p>为了避免对分析会话结束时未释放的最新分配产生偏差，泄漏分析器会忽略分析期间最后10%的尾部分配。可以通过–tail选项调整尾部长度，该选项接受比率或百分比（%）作为参数。例如，要忽略10分钟分析中最后2分钟的分配，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jfrconv --nativemem --leak --tail 20% app.jfr app-leak.html</span><br></pre></td></tr></table></figure><p>原生内存分析的开销取决于原生分配的数量，但通常对生产环境来说也足够小。如果需要，可以通过配置分析间隔来降低开销。例如，添加 <code>nativemem=1m</code> 的分析器选项后，分配样本将限制为每分配 1MB 最多一个样本。</p><h2 id="Wall-clock-分析"><a href="#Wall-clock-分析" class="headerlink" title="Wall-clock 分析"></a>Wall-clock 分析</h2><p><code>-e wall</code> 选项告诉 async-profiler 在给定时间段内平等地采样所有线程，而不考虑线程状态：运行、睡眠或阻塞。例如，这在分析应用程序启动时间时可能会很有帮助。</p><p>Wall-clock 分析器在每线程模式（<code>-t</code>）下最有用。</p><p>示例：<code>asprof -e wall -t -i 50ms -f result.html 8983</code></p><h2 id="Lock-分析"><a href="#Lock-分析" class="headerlink" title="Lock 分析"></a>Lock 分析</h2><p><code>-e lock</code> 选项告诉 async-profiler 测量已分析应用程序中的锁争用。锁性能分析可以帮助开发人员了解锁获取模式、锁争用（当线程需要等待获取锁时）、等待锁花费的时间以及哪些代码路径因锁而被阻塞。</p><p>在锁分析模式中，顶部帧是锁/监视器类，计数器是进入该锁/监视器所需要的纳秒数。</p><p>示例：<code>asprof -e lock -t -i 5ms -f result.html 8983</code></p><h2 id="Java-方法分析"><a href="#Java-方法分析" class="headerlink" title="Java 方法分析"></a>Java 方法分析</h2><p><code>-e ClassName.methodName</code> 选项检测给定的 Java 方法，以记录对该方法的所有调用以及栈跟踪。</p><p>示例：<code>-e java.util.Properties.getProperty</code> 将分析调用 getProperty 方法的所有位置。</p><p>仅支持非原生 Java 方法。要分析原生方法，请改用硬件断电时间，例如 <code>-e Java_java_lang_Throwable_fillInStackTrace</code>。<strong>请注意</strong>，如果在运行时附加异步配置文件，非原生 Java 方法的第一次插桩可能会导致所有编译的方法去优化。虽有的插桩只会刷新依赖代码。</p><p>如果将 async-profiler 作为代理附加，则不会发生大规模的 CodeCache 刷新。</p><h2 id="Native-function-分析"><a href="#Native-function-分析" class="headerlink" title="Native function 分析"></a>Native function 分析</h2><p>以下是一些可以分析的 Native function：</p><ul><li><code>G1CollectedHeap::humongous_obj_allocate</code> - 跟踪 G1 GC 的巨大分配</li><li><code>JVM_StartThread</code> - 跟踪新 Java 线程的创建</li><li><code>Java_java_lang_ClassLoader_defineClass1</code> - 跟踪类加载</li></ul><h2 id="Multiple-events"><a href="#Multiple-events" class="headerlink" title="Multiple events"></a>Multiple events</h2><p>可以同时分析 CPU、分配和锁。除了 CPU，还可以选择任何其他执行事件：wall-clock, perf event, tracepoint, Java method 等等</p><p>唯一支持多个事件同时分析的输出格式是 JFR。记录将包含以下事件类型：</p><ul><li><code>jdk.ExecutionSample</code></li><li><code>jdk.ObjectAllocationInNewTLAB</code> (alloc)</li><li><code>jdk.ObjectAllocationOutsideTLAB</code> (alloc)</li><li><code>jdk.JavaMonitorEnter</code> (lock)</li><li><code>jdk.ThreadPark</code> (lock)</li></ul><p>如果分析 cpu + allocations + locks，可以指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof -e cpu,alloc,lock -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>或者使用 <code>--alloc</code> 和 <code>--lock</code> 参数并设置所需的阈值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof -e cpu --alloc 2m --lock 10ms -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>同样，当将分析器作为代理启动时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentpath:/path/to/libasyncProfiler.so=start,event=cpu,alloc=2m,lock=10ms,file=profile.jfr</span><br></pre></td></tr></table></figure><h2 id="使用-–all-进行多事件分析"><a href="#使用-–all-进行多事件分析" class="headerlink" title="使用 –all 进行多事件分析"></a>使用 –all 进行多事件分析</h2><p><code>--all</code> 标志提供了一个同时启动预定义的常见性能分析时间集合方法。默认情况下，<code>--all</code> 会激活 cpu、wall、alloc、lock 和 nativemem。</p><p><strong>注意</strong>：虽然 <code>--all</code> 标志对于开发环境来说可以用于获得广泛的概述，但不建议在生产环境中启动它，尤其是对于持续性能分析。用户需要仔细选择要分析的内容以及使用哪些设置。</p><p><strong>示例</strong>：下面这个命令启用了 <code>--all</code> 中包含的默认事件集：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>或者结合 <code>--alloc</code>/<code>--wall</code>/<code>--lock</code>/<code>--nativemem</code> 选项来覆盖单个设置。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all --alloc 2m --lock 10ms -f profile.jfr ...</span><br></pre></td></tr></table></figure><p>同样，当将性能分析器作为代理启动时：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-agentpath:/path/to/libasyncProfiler.so=start,event=all,alloc=2m,lock=10ms,file=profile.jfr</span><br></pre></td></tr></table></figure><p>可以用你选择的任何其他事件类型来覆盖 <code>--all</code> 参数，而不是 <code>cpu</code>。例如，以下命令将分析循环以及 <code>wall</code>, <code>alloc</code>, <code>live</code>, <code>lock</code> 和 <code>nativemem</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --all -e cycles -f profile.jfr</span><br></pre></td></tr></table></figure><h2 id="连续性能分析"><a href="#连续性能分析" class="headerlink" title="连续性能分析"></a>连续性能分析</h2><p>持续性能分析是一种可以持续性能分析应用程序并在每个指定时间段转储性能分析结果的方法。这是一种主动且高效地发现性能下降的非常有效的技术。持续性能分析有助于用户了解同一应用程序各版本之间的性能差异。可以将最近的输出与持续性能分析的输出历史记录进行比较，以找出差异并优化性能下降情况下引入的变更。aysnc-profiler 提供了使用循环选项持续性能分析应用程序的能力。确保文件名包含时间戳模式，否则输出将在每次迭代中被覆盖。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asprof --loop 1h -f /var/log/profile-%t.jfr 8983</span><br></pre></td></tr></table></figure><h2 id="perf-event-types-supported-on-Linux"><a href="#perf-event-types-supported-on-Linux" class="headerlink" title="perf event types supported on Linux"></a>perf event types supported on Linux</h2><table><thead><tr><th>Usage</th><th>Description</th></tr></thead><tbody><tr><td>Predefined:</td><td></td></tr><tr><td><code>-e cpu-clock</code></td><td>High-resolution per-CPU timer. Similar to <code>-e cpu</code> but forces using perf_events.</td></tr><tr><td><code>-e page-faults</code></td><td>Software page faults</td></tr><tr><td><code>-e context-switches</code></td><td>Context switches</td></tr><tr><td><code>-e cycles</code></td><td>Total CPU cycles</td></tr><tr><td><code>-e instructions</code></td><td>Retired CPU instructions</td></tr><tr><td><code>-e cache-references</code></td><td>Cache accesses (usually Last Level Cache, but may depend on the architecture)</td></tr><tr><td><code>-e cache-misses</code></td><td>Cache accesses requiring fetching data from a higher-level cache or main memory</td></tr><tr><td><code>-e branch-instructions</code></td><td>Retired branch instructions</td></tr><tr><td><code>-e branch-misses</code></td><td>Mispredicted branch instructions</td></tr><tr><td><code>-e bus-cycles</code></td><td>Bus cycles</td></tr><tr><td><code>-e L1-dcache-load-misses</code></td><td>Cache misses on Level 1 Data Cache</td></tr><tr><td><code>-e LLC-load-misses</code></td><td>Cache misses on the Last Level Cache</td></tr><tr><td><code>-e dTLB-load-misses</code></td><td>Data load misses on the Translation Lookaside Buffer</td></tr><tr><td>Breakpoint:</td><td></td></tr><tr><td><code>-e mem:&lt;addr&gt;</code></td><td>Breakpoint on a decimal or hex (0x) address</td></tr><tr><td><code>-e mem:&lt;func&gt;</code></td><td>Breakpoint on a public or a private symbol</td></tr><tr><td><code>-e mem:&lt;func&gt;[+&lt;offset&gt;][/&lt;len&gt;][:rwx&gt;]</code></td><td>Breakpoint on a symbol or an address with offset, length and read/write/exec. Address, offset and length can be hex or dec. The format of <code>mem</code> event is the same as in <a target="_blank" rel="noopener external nofollow noreferrer" href="https://man7.org/linux/man-pages/man1/perf-record.1.html"><code>perf-record</code></a>.</td></tr><tr><td><code>-e &lt;symbol&gt;</code></td><td>Equivalent to an execution breakpoint on a symbol: <code>mem:&lt;symbol&gt;:x</code>. Example: <code>-e strcmp</code> will trace all calls of native <code>strcmp</code> function.</td></tr><tr><td>Tracepoint:</td><td></td></tr><tr><td><code>-e trace:&lt;id&gt;</code></td><td>Kernel tracepoint with the given numeric id</td></tr><tr><td><code>-e &lt;tracepoint&gt;</code></td><td>Kernel tracepoint with the specified name. Example: <code>-e syscalls:sys_enter_open</code> will trace all <code>open</code> syscalls.</td></tr><tr><td>Probes:</td><td></td></tr><tr><td><code>-e kprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Kernel probe. Example: <code>-e kprobe:do_sys_open</code>.</td></tr><tr><td><code>-e kretprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Kernel return probe. Example: <code>-e kretprobe:do_sys_open</code>.</td></tr><tr><td><code>-e uprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Userspace probe. Example: <code>-e uprobe:/usr/lib64/libc-2.17.so+0x114790</code>.</td></tr><tr><td><code>-e uretprobe:&lt;func&gt;[+&lt;offset&gt;]</code></td><td>Userspace return probe</td></tr><tr><td>PMU:</td><td></td></tr><tr><td><code>-e r&lt;NNN&gt;</code></td><td>Architecture-specific PMU event with the given number. Example: <code>-e r4d2</code> selects <code>MEM_LOAD_L3_HIT_RETIRED.XSNP_HITM</code> event, which corresponds to event 0xd2, umask 0x4.</td></tr><tr><td><code>-e &lt;pmu descriptor&gt;</code></td><td>PMU event descriptor. Example: <code>-e cpu/cache-misses/</code>, <code>-e cpu/event=0xd2,umask=4/</code>. The same syntax can be used for uncore and vendor-specific events, e.g. <code>amd_l3/event=0x01,umask=0x80/</code></td></tr></tbody></table><br><div id="comment-container"></div><div id="disqus_thread"></div><div id="lv-container"></div><div class="giscus"></div></div></div></div></div><footer class="footer"><ul class="list-inline text-center"><li><a target="_blank" href="https://github.com/wu3227834" rel="external nofollow noreferrer"><span class="fa-stack fa-lg"><i class="iconfont icon-github"></i></span></a></li></ul><p><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span>PV </span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span>UV </span>Created By <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> Theme <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script><script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script type="text/javascript" src="/js/clipboard.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body><script>window.hexo_search_path="search.json",window.hexo_root="/",window.isPost=!0</script><script src="/js/index.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/jquery.min.js"></script><script src="/js/prism.js"></script><script src="https://giscus.app/client.js" data-repo="wu3227834/wu3227834.github.io" data-repo-id="R_kgDOIh8vuA" data-category="General" data-category-id="DIC_kwDOIh8vuM4CpDjz" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></html><script src="/js/fancybox/jquery.fancybox.min.js" key="fancybox_js"></script><script src="/js/fancybox/wrapImage.js" key="wrap_image_js"></script><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" key="fancybox_css">