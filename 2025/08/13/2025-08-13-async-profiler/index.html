<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:description" content="这里是小布丁的私有小屋"><meta property="og:type" content="website"><meta name="description" content="这里是小布丁的私有小屋"><link rel="shortcut icon" href="/img/favicon.ico"><title>async-profiler</title><link rel="stylesheet" href="/css/aircloud.css"><link rel="stylesheet" href="/css/gitment.css"><link rel="stylesheet" href="/css/prism.css"><link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css"><script></script><script defer src="https://cloud.umami.is/script.js" data-website-id="bad0a741-25cb-4dd6-bbcf-f5710aeb243c"></script><script type="text/javascript">((e,t,s,n,a,c)=>{e[s]=e[s]||function(){(e[s].q=e[s].q||[]).push(arguments)},(a=t.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/sgs6id3d37",(c=t.getElementsByTagName(n)[0]).parentNode.insertBefore(a,c)})(window,document,"clarity","script")</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Pudding 日常" type="application/atom+xml"></head><body><div class="site-nav-toggle" id="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><div class="index-about"><i>a week is 2% of the year</i></div><div class="index-container"><div class="index-left"><div class="nav" id="nav"><div class="avatar-name"><div class="avatar"><img src="/img/avatar.png"></div><div class="name"><i>Pudding</i></div></div><div class="contents" id="nav-content"><ul><li><a href="/"><i class="iconfont icon-shouye1"></i> <span>主页</span></a></li><li><a href="/tags"><i class="iconfont icon-biaoqian1"></i> <span>标签</span></a></li><li><a href="/archive"><i class="iconfont icon-guidang2"></i> <span>存档</span></a></li><li><a href="/about/"><i class="iconfont icon-guanyu2"></i> <span>关于</span></a></li><li><a id="search"><i class="iconfont icon-sousuo1"></i> <span>搜索</span></a></li></ul></div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%A8%A1%E5%BC%8F"><span class="toc-text">性能分析模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-%E5%88%86%E6%9E%90"><span class="toc-text">CPU 分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ALLOCATION-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">ALLOCATION 性能分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Native-memory-leaks"><span class="toc-text">Native memory leaks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wall-clock-%E5%88%86%E6%9E%90"><span class="toc-text">Wall-clock 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock-%E5%88%86%E6%9E%90"><span class="toc-text">Lock 分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E6%96%B9%E6%B3%95%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-text">Java 方法性能分析</span></a></li></ol></div></div><div class="search-field" id="search-field"><div class="search-bg" id="search-bg"></div><div class="search-container"><div class="search-input"><span id="esc-search"><i class="icon-fanhui iconfont"></i></span> <input id="search-input"> <span id="begin-search">搜索</span></div><div class="search-result-container" id="search-result-container"></div></div></div><div class="index-about-mobile"><i>a week is 2% of the year</i></div></div><div class="index-middle"><div class="post-container"><div class="post-title">async-profiler</div><div class="post-meta"><span class="attr">发布于：<span>2025-08-13</span></span> <span class="attr">标签：/ <a class="tag" href="/tags/#Java" title="Java">Java</a> <span>/</span> <a class="tag" href="/tags/#Profiler" title="Profiler">Profiler</a> <span>/</span> </span><span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span></div><div class="post-content no-indent"><p>前两篇文章介绍了 jvm 中的安全点机制，以及为什么（大多数）分析器都很难用。这篇文章介绍一下 async-profiler 这个工具。</p><p>这个项目是一个针对 Java 的低开销采样性能分析器，不受 Safepoint 偏差问题的影响。它具有 HotSpot 特定的 API, 用于收集堆栈跟踪和跟踪内存分配。该性能分析器可与 OpenJDK 和其他基于 HotSpot JVM 的 Java 运行时配合使用。</p><h2 id="性能分析模式"><a href="#性能分析模式" class="headerlink" title="性能分析模式"></a>性能分析模式</h2><p>除了 CPU 时间，async-profiler 还提供了各种其他性能分析模式，如 Allocation, Wall Clock, Java Method，甚至是 Multiple Events 性能分析模式。</p><h3 id="CPU-分析"><a href="#CPU-分析" class="headerlink" title="CPU 分析"></a>CPU 分析</h3><p>在这种模式下，性能分析器收集栈跟踪样本，其中包括 <strong>Java 方法、原生调用、JVM 代码和内核函数</strong>。</p><p>通用方法是接收 <code>perf_events</code> 生成的调用栈，并将它们与 AsyncGetCallTrace 生成的调用栈进行匹配，以生成 Java 和本机代码的准确性分析。此外，Async-profiler 提供了一种解决方案，用于在 <code>AsyncGetCallTrace</code> 失败的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://bugs.openjdk.org/browse/JDK-8178287">某些案例情况</a>恢复栈跟踪。</p><p>与直接在 Java 代理中使用 <code>perf_events</code> 相比，这种方法具有以下优势，后者可以将地址转换为 Java 方法名称：</p><ul><li>不需要 <code>-XX:+PreserveFramePointer</code>, 这会引入性能开销，有时高达 10%</li><li>不需要在 JVM 开始时使用代理将 Java 代码地址转换为方法名称</li><li>显示解释器帧</li><li>不会生成大型中间文件（perf.data），一边在用户空间脚本中进一步处理</li></ul><p>如果希望在 libjvm 中解析帧，则需要使用调试符号。</p><h2 id="ALLOCATION-性能分析"><a href="#ALLOCATION-性能分析" class="headerlink" title="ALLOCATION 性能分析"></a>ALLOCATION 性能分析</h2><p>可以将性能呢分析器配置为收集分配了最大量堆内存的调用站点。</p><p>Async-profiler 不使用字节码探测或昂贵的 DTrace 探针等侵入性技术，这些技术对性能有显著影响。它也不影响 Escape Analysis 或阻止 JIT 优化 (如分配消除)。只测量实际的堆分配。</p><p>性能分析器具有 TLAB(Thread Local Allocation Buffer, 线程本地分配缓存) 驱动的采样功能。它依赖于 HotSpot 特定的回调来接收两种类型的通知：</p><ul><li>当在新创建的 TLAB 中分配对象时</li><li>当在 TLAB 之外的慢速路径上分配对象时</li></ul><p>可以使用 <code>--alloc</code> 选项调整采样间隔。例如 <code>--alloc 500k</code> 将在平均分配空间 500KB 后采样一次。在 JDK 11 之前，小于 TLAB 大小的间隔不会生效。</p><p>在分配分析模式下，每个调用跟踪的顶帧是分配对象的类，计数器是堆压力（分配的 TLAB 或 TLAB 外对象的总大小）。</p><h2 id="Native-memory-leaks"><a href="#Native-memory-leaks" class="headerlink" title="Native memory leaks"></a>Native memory leaks</h2><p>性能分析模式 <code>nativemem</code> 记录 <code>malloc</code>、<code>relloc</code>、<code>calloc</code> 和 <code>free</code> 地址，以便将分配与空闲调用进行匹配。这有助于将性能分析报告仅集中在非空闲分配上，这些分配可能是内存泄漏的来源。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">asprof start -e nativemem -f app.jfr &lt;YourApp&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or</span></span><br><span class="line">asprof start --nativemem N -f app.jfr &lt;YourApp&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or <span class="keyword">if</span> only allocation calls are interesting, <span class="keyword">do</span> not collect free calls:</span></span><br><span class="line">asprof start --nativemem N --nofree -f app.jfr &lt;YourApp&gt;</span><br><span class="line"></span><br><span class="line">asprof stop &lt;YourApp&gt;</span><br></pre></td></tr></table></figure><p>现在我们需要处理 jfr 文件，以查找原生内存泄漏：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--total <span class="keyword">for</span> bytes, default counts invocations.</span></span><br><span class="line">jfrconv --total --nativemem --leak app.jfr app-leak.html</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">No leak analysis, include all native allocations:</span></span><br><span class="line">jfrconv --total --nativemem app.jfr app-malloc.html</span><br></pre></td></tr></table></figure><p>当使用 <code>--leak</code> 选项时，生成的火焰图将显示未匹配免费调用的分配。</p><p><img src="/img/2025-08-13-async-profiler/nativemem_flamegraph.png" alt="火焰图"></p><p>为了避免对分析会话结束时未释放的最新分配产生偏差，泄漏分析器会忽略分析期间最后10%的尾部分配。可以通过–tail选项调整尾部长度，该选项接受比率或百分比（%）作为参数。例如，要忽略10分钟分析中最后2分钟的分配，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jfrconv --nativemem --leak --tail 20% app.jfr app-leak.html</span><br></pre></td></tr></table></figure><p>原生内存分析的开销取决于原生分配的数量，但通常对生产环境来说也足够小。如果需要，可以通过配置分析间隔来降低开销。例如，添加 <code>nativemem=1m</code> 的分析器选项后，分配样本将限制为每分配 1MB 最多一个样本。</p><h2 id="Wall-clock-分析"><a href="#Wall-clock-分析" class="headerlink" title="Wall-clock 分析"></a>Wall-clock 分析</h2><p><code>-e wall</code> 选项告诉 async-profiler 在给定时间段内平等地采样所有线程，而不考虑线程状态：运行、睡眠或阻塞。例如，这在分析应用程序启动时间时可能会很有帮助。</p><p>Wall-clock 分析器在每线程模式（<code>-t</code>）下最有用。</p><p>示例：<code>asprof -e wall -t -i 50ms -f result.html 8983</code></p><h2 id="Lock-分析"><a href="#Lock-分析" class="headerlink" title="Lock 分析"></a>Lock 分析</h2><p><code>-e lock</code> 选项告诉 async-profiler 测量已分析应用程序中的锁争用。锁性能分析可以帮助开发人员了解锁获取模式、锁争用（当线程需要等待获取锁时）、等待锁花费的时间以及哪些代码路径因锁而被阻塞。</p><p>在锁分析模式中，顶部帧是锁/监视器类，计数器是进入该锁/监视器所需要的纳秒数。</p><p>示例：<code>asprof -e lock -t -i 5ms -f result.html 8983</code></p><h2 id="Java-方法性能分析"><a href="#Java-方法性能分析" class="headerlink" title="Java 方法性能分析"></a>Java 方法性能分析</h2><p><code>-e ClassName.methodName</code> 选项检测给定的 Java 方法，以记录对该方法的所有调用以及栈跟踪。</p><p>示例：<code>-e java.util.Properties.getProperty</code> 将分析调用 getProperty 方法的所有位置。</p><p>仅支持非原生 Java 方法。要分析原生方法，请改用硬件断电时间，例如 <code>-e Java_java_lang_Throwable_fillInStackTrace</code>。<strong>请注意</strong>，如果在运行时附加异步配置文件，非原生 Java 方法的第一次插桩可能会导致所有编译的方法去优化。虽有的插桩只会刷新依赖代码。</p><br><div id="comment-container"></div><div id="disqus_thread"></div><div id="lv-container"></div><div class="giscus"></div></div></div></div></div><footer class="footer"><ul class="list-inline text-center"><li><a target="_blank" href="https://github.com/wu3227834" rel="external nofollow noreferrer"><span class="fa-stack fa-lg"><i class="iconfont icon-github"></i></span></a></li></ul><p><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span>PV </span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span>UV </span>Created By <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> Theme <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script><script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script type="text/javascript" src="/js/clipboard.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body><script>window.hexo_search_path="search.json",window.hexo_root="/",window.isPost=!0</script><script src="/js/index.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/jquery.min.js"></script><script src="/js/prism.js"></script><script src="https://giscus.app/client.js" data-repo="wu3227834/wu3227834.github.io" data-repo-id="R_kgDOIh8vuA" data-category="General" data-category-id="DIC_kwDOIh8vuM4CpDjz" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></html><script src="/js/fancybox/jquery.fancybox.min.js" key="fancybox_js"></script><script src="/js/fancybox/wrapImage.js" key="wrap_image_js"></script><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" key="fancybox_css">