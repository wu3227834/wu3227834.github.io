<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:description" content="这里是小布丁的私有小屋"><meta property="og:type" content="website"><meta name="description" content="这里是小布丁的私有小屋"><link rel="shortcut icon" href="/img/favicon.ico"><title>为什么（大多数）取样 javaprofiler 都很难用</title><link rel="stylesheet" href="/css/aircloud.css"><link rel="stylesheet" href="/css/gitment.css"><link rel="stylesheet" href="/css/prism.css"><link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css"><script></script><script defer src="https://cloud.umami.is/script.js" data-website-id="bad0a741-25cb-4dd6-bbcf-f5710aeb243c"></script><script type="text/javascript">((e,t,s,n,a,c)=>{e[s]=e[s]||function(){(e[s].q=e[s].q||[]).push(arguments)},(a=t.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/sgs6id3d37",(c=t.getElementsByTagName(n)[0]).parentNode.insertBefore(a,c)})(window,document,"clarity","script")</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Pudding 日常" type="application/atom+xml"></head><body><div class="site-nav-toggle" id="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><div class="index-about"><i>a week is 2% of the year</i></div><div class="index-container"><div class="index-left"><div class="nav" id="nav"><div class="avatar-name"><div class="avatar"><img src="/img/avatar.png"></div><div class="name"><i>Pudding</i></div></div><div class="contents" id="nav-content"><ul><li><a href="/"><i class="iconfont icon-shouye1"></i> <span>主页</span></a></li><li><a href="/tags"><i class="iconfont icon-biaoqian1"></i> <span>标签</span></a></li><li><a href="/archive"><i class="iconfont icon-guidang2"></i> <span>存档</span></a></li><li><a href="/about/"><i class="iconfont icon-guanyu2"></i> <span>关于</span></a></li><li><a id="search"><i class="iconfont icon-sousuo1"></i> <span>搜索</span></a></li></ul></div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%87%E6%A0%B7%E6%89%A7%E8%A1%8C%E6%8E%A2%E6%9F%A5%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C-%E7%90%86%E8%AE%BA%E4%B8%8A"><span class="toc-text">采样执行探查器如何工作 (理论上)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%95%86%E4%B8%9A-Java-%E9%87%87%E6%A0%B7%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90%E5%99%A8%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-text">通用商业 Java 采样执行分析器如何工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E9%87%87%E6%A0%B7%EF%BC%9A%E7%90%86%E8%AE%BA"><span class="toc-text">安全点采样：理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E9%87%87%E6%A0%B7%EF%BC%9A%E7%8E%B0%E5%AE%9E"><span class="toc-text">安全点采样：现实</span></a></li></ol></div></div><div class="search-field" id="search-field"><div class="search-bg" id="search-bg"></div><div class="search-container"><div class="search-input"><span id="esc-search"><i class="icon-fanhui iconfont"></i></span> <input id="search-input"> <span id="begin-search">搜索</span></div><div class="search-result-container" id="search-result-container"></div></div></div><div class="index-about-mobile"><i>a week is 2% of the year</i></div></div><div class="index-middle"><div class="post-container"><div class="post-title">为什么（大多数）取样 javaprofiler 都很难用</div><div class="post-meta"><span class="attr">发布于：<span>2025-08-12</span></span> <span class="attr">标签：/ <a class="tag" href="/tags/#Java" title="Java">Java</a> <span>/</span> </span><span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span></div><div class="post-content no-indent"><blockquote><p>本文是一篇英文翻译转载文章，主要介绍了 javaprofiler 的工作原理。<br><br>原英文链接：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html">https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html</a><br></p></blockquote><p>这篇文章建立在之前的一篇<a href="https://wu3227834.github.io/2025/08/12/2025-08-12-jian-shu-jvm-zhong-de-an-quan-dian-ji-zhi/">关于安全点的文章</a>的基础上。如果你没有读过它，你可能会感到迷茫和困惑。如果你读过这篇文章，仍然感到迷茫和困惑，并且您确定这种感觉与当前的问题有关（而不是生存危机），请继续提问。</p><p>那么，既然我们已经确定了什么是安全点，那么：</p><ol><li>安全点轮询分散在相当多的任意点（取决于执行模式，主要是在未计数的循环后端或方法返回/入口）</li><li>将 JVM 带到全局安全点的成本很高</li></ol><p>我们已经掌握了所有需要的信息，可以得出结论，通过在安全点采样来进行剖析可能有点糟糕。这对于某些人来说并不奇怪，但是这个问题在最常见的分析器中是存在的。根据 RebelLabs 的调查，以下是详细情况：</p><p><img src="/img/2025-08-12-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%8F%96%E6%A0%B7javaprofiler%E9%83%BD%E5%BE%88%E9%9A%BE%E7%94%A8/which-profiler.png" alt="which-profiler"></p><p>VisualVM、NB Profiler（同上）、YourKit 和 JProfiler 都提供了一个 CPU 分析器，可以在安全点进行采样。鉴于这是一个相当常见的问题，让我们深入研究一下。</p><h2 id="采样执行探查器如何工作-理论上"><a href="#采样执行探查器如何工作-理论上" class="headerlink" title="采样执行探查器如何工作 (理论上)"></a>采样执行探查器如何工作 (理论上)</h2><p>抽样分析器应该通过收集应用程序在不同时间点所处位置的样本，来接近应用程序中“花费的时间”的分布。在每个样本中收集的数据可以是：</p><ul><li>current instruction</li><li>current line of code</li><li>current method</li><li>current stack trace</li></ul><p>数据可以为单个线程收集，也可以为每个样本中的所有线程收集。我们需要保存哪些数据才能进行有效的采样？</p><blockquote><p>然而，要使采样结果与完整（未采样）分析结果相媲美，必须满足以下两个条件。<br><strong>首先，我们必须拥有大量样本才能获得具有统计意义的结果。</strong>例如，如果一个分析器在整个程序运行过程中只收集了一个样本，那么该分析器会将程序执行时间的 100% 分配给它进行采样的代码，而将 0% 分配给其他所有代码。[…]<br><strong>其次，分析器应该以相同的概率对程序运行中的所有点进行采样。</strong>如果分析器不这样做，它的分析结果最终会出现偏差。例如，假设我们的分析器只能对包含调用的方法进行采样。即使不包含调用的方法可能占据了程序执行时间的很大一部分，该分析器也不会将执行时间分配给这些方法。<br>——摘自<a target="_blank" rel="noopener external nofollow noreferrer" href="http://plv.colorado.edu/papers/mytkowicz-pldi10.pdf">《评估 Java 分析器的准确性》</a>，我们稍后会回到这篇文章。</p></blockquote><p>这听起来很简单，对吧？</p><p>一旦我们有了大量的样本，我们就可以构建一个热方法列表，甚至是这些方法中的代码行（如果样本报告了它），我们可以查看分布在调用树上的样本（如果收集了调用跟踪）并且度过一段美好的时光！</p><h2 id="通用商业-Java-采样执行分析器如何工作"><a href="#通用商业-Java-采样执行分析器如何工作" class="headerlink" title="通用商业 Java 采样执行分析器如何工作"></a>通用商业 Java 采样执行分析器如何工作</h2><p>好吧，我可以在这里从不同的解决方案进行逆向工程，或者通读开源代码库，但是我会提供一些没有支持的猜测，如果你知道更多的话，可以自由地告诉我。通用分析器依赖于 JVMTI(JVM Tool Interface) 规范，所有 jvm 都必须满足这一规范：</p><ul><li>JVMTI 仅提供安全点采样堆栈跟踪收集选项（调用线程的 GetStackTrace 不需要安全点，但对分析器来说用处不大；在 Zing 中，对其他线程调用 GetStackTrace 仅会将该线程带到安全点）。因此，希望其工具能在所有 JVM 上运行的厂商只能采用安全点采样方式。</li><li>无论你是在对单个线程进行采样还是对所有线程进行采样（至少在 OpenJDK 上是这样，Zing 略有不同，但作为分析工具供应商，你应假设使用的是 OpenJDK）。我所查看过的所有分析工具都采用对所有线程进行采样的方式。据我所知，它们也不会限制收集的堆栈深度。这相当于以下 JVMTI 调用：JvmtiEnv:：GetAllStackTraces (0，&amp;stack_info，&amp;thread_count)</li><li>因此，这相当于：设置一个定时线程，每隔 ‘sampling_interval’ 时间触发一次，并收集所有的堆栈跟踪信息。</li></ul><p>这有几个坏处，其中一些可以避免的：</p><ol><li>采样分析器需要采样，因此通常会将采样频率设置得相当高（通常为每秒 10 次，或每 100 毫秒一次）。设置 -XX:+PrintGCApplicationStoppedTime 并查看这引入了什么样的暂停时间是有指导意义的。几毫秒的暂停并不罕见，但具体情况具体分析（取决于线程数、堆栈深度、TTSP 等）。每 100 毫秒暂停 5 毫秒意味着分析器会引入 5% 的开销（实际损失可能比这更严重）。通常可以通过设置更长的间隔来控制损失，但这也意味着你需要更长的分析周期才能获得有意义的样本计数。</li><li>从所有线程收集完整的栈跟踪意味着你的安全点操作成本是开发的。你的应用程序拥有的线程越多（想想应用程序服务器、SEDA 架构、大量线程池等），你的栈跟踪越深（想想 Spring 和 Co.），你的应用程序等待单个线程来回采集名称和填写表单的时间就越长。据我所知，当前的分析器对此毫无帮助。如果你正在构建自己的分析器，那么对数量设置限制似乎是明智的，这样你就可以控制开销。JVMTI 功能允许你查看当前线程列表，如果少于 100 个，你可以对所有的线程进行采样，否则可以随机选择 100 个线程的子集进行采样。也许更倾向于采样那些实际在做某事的线程，而不是那些整天被阻塞的线程，这是有道理的。</li><li>仿佛这一切还不够糟糕似的，其实我感觉在安全点进行抽样似乎也有些毫无意义</li></ol><p>第 1 点和第 2 点是关于剖析开销的，这基本上是关于成本的。在我之前关于安全点的文章中，我查看了这些成本，所以没有必要重复这个练习。对于良好的剖析信息，成本可能是可以接受的，但正如我们将看到的，这些信息并不那么重要。</p><p>第 3 点需要解释，所以我们开始寻找其含义。</p><h2 id="安全点采样：理论"><a href="#安全点采样：理论" class="headerlink" title="安全点采样：理论"></a>安全点采样：理论</h2><p>那么，在安全点进行采样意味着什么？这意味着只运行代码中的安全点轮询是可见的。考虑到热代码可能是由 C1/C2 (客户端/服务器编译器) 编译的，我们减少了方法退出和未经计数的循环备份的采样机会。这导致了所谓的安全点排查现象，即采样性能分析器的采样偏向于下一个可用的安全点轮询位置（这违反了上面列出的第二个标准“<strong>性能分析器应该以相对概率对程序运行中的所有点进行采样</strong>”）。</p><p>这乍听起来可能没那么糟糕，所以让我们通过一个简单的例子来看看哪一行收到了责备。</p><p><strong>注意：</strong>在以下所有示例中，我将使用 JMH 作为测试工具，并使用 “CompilerControl” 注释来防止内联。这就使我能够控制编译单元的限制，这可能看起来很残酷、不寻常，或者至少是不公平的。在“野生”环境中，内敛决策受到很多因素的影响，（在我看来）将它们视为任意的（在几个编译器/JVM供应商/命令行参数等的手中）是安全的。内联可能是“所有优化之母”，但它在这方面是一个反复无常且狡猾的长辈。</p><p>让我们看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Param(&quot;1000&quot;)</span></span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="type">byte</span>[] buffer;</span><br><span class="line"><span class="type">boolean</span> result;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Setup</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="meta">@CompilerControl(CompilerControl.Mode.DONT_INLINE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotNoInline</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    b += buffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  result = b == <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// SP poll, method exit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Benchmark</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotInline</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">    b += buffer[i];</span><br><span class="line">  &#125;</span><br><span class="line">  result = b == <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// SP poll, method exit (removed when method is inlined)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个容易思考的例子。我们可以通过改变数组的大小来控制方法中的工作量。我们知道技术循环中没有安全点轮询（通过查看汇编输出验证），因此理论上，上述方法在方法退出时将有一个安全点。问题是，如果我们让上述方法内联，方法的末尾安全点轮询将消失，而下一轮轮询将在测试循环中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meSoHotInline_avgt_jmhStub</span><span class="params">(InfraControl control, RawResults result,</span></span><br><span class="line"><span class="params">    SafepointProfiling_jmhType l_safepointprofiling0_0, Blackhole_jmhType l_blackhole1_1)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">operations</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> <span class="variable">realTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  result.startTime = System.nanoTime();</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    l_safepointprofiling0_0.meSoHotInline(); <span class="comment">/* LINE 163 */</span></span><br><span class="line">    operations++;</span><br><span class="line">    <span class="comment">// SP poll, uncounted loop</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!control.isDone); <span class="comment">/* LINE 165 */</span></span><br><span class="line">  result.stopTime = System.nanoTime();</span><br><span class="line">  result.realTime = realTime;</span><br><span class="line">  result.measuredOps = operations;</span><br><span class="line">  <span class="comment">// SP poll, method exit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，如果测量方法没有内联，预期它会受到指责似乎是合理的，但如果它确实内联了，我们可以预期测量方法会受到指责。对吧？非常合理，但有点偏差。</p><h2 id="安全点采样：现实"><a href="#安全点采样：现实" class="headerlink" title="安全点采样：现实"></a>安全点采样：现实</h2><p>在这篇 2010 年发表的精彩论文《评估 Java 性能分析器的准确性》中，作者们讨论了安全点偏差。他们认识到，不用的 Java 性能分析器会在同一基准中识别不同的热点。</p><br><div id="comment-container"></div><div id="disqus_thread"></div><div id="lv-container"></div><div class="giscus"></div></div></div></div></div><footer class="footer"><ul class="list-inline text-center"><li><a target="_blank" href="https://github.com/wu3227834" rel="external nofollow noreferrer"><span class="fa-stack fa-lg"><i class="iconfont icon-github"></i></span></a></li></ul><p><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span>PV </span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span>UV </span>Created By <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> Theme <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script><script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script type="text/javascript" src="/js/clipboard.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body><script>window.hexo_search_path="search.json",window.hexo_root="/",window.isPost=!0</script><script src="/js/index.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/jquery.min.js"></script><script src="/js/prism.js"></script><script src="https://giscus.app/client.js" data-repo="wu3227834/wu3227834.github.io" data-repo-id="R_kgDOIh8vuA" data-category="General" data-category-id="DIC_kwDOIh8vuM4CpDjz" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></html><script src="/js/fancybox/jquery.fancybox.min.js" key="fancybox_js"></script><script src="/js/fancybox/wrapImage.js" key="wrap_image_js"></script><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" key="fancybox_css">