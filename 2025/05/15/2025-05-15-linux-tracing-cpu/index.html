<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:description" content="这里是小布丁的私有小屋"><meta property="og:type" content="website"><meta name="keywords" content="Linux 性能调优,平均负载,CPU 上下文切换,系统调用,性能瓶颈,"><meta name="description" content="本文深入讲解 Linux 系统性能调优中的 CPU 相关知识，重点解析平均负载的含义及其与 CPU 使用率的关系，探讨 CPU 上下文切换（进程、线程、中断）的机制与影响，并通过 sysbench 案例分析高负载场景下的诊断方法，指导如何使用 vmstat、pidstat 等工具定位性能瓶颈。"><link rel="shortcut icon" href="/img/favicon.ico"><title>Linux性能调优：cpu</title><link rel="stylesheet" href="/css/aircloud.css"><link rel="stylesheet" href="/css/gitment.css"><link rel="stylesheet" href="/css/prism.css"><link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css"><script></script><script defer src="https://cloud.umami.is/script.js" data-website-id="bad0a741-25cb-4dd6-bbcf-f5710aeb243c"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Pudding 日常" type="application/atom+xml"></head><body><div class="site-nav-toggle" id="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><div class="index-about"><i>a week is 2% of the year</i></div><div class="index-container"><div class="index-left"><div class="nav" id="nav"><div class="avatar-name"><div class="avatar"><img src="/img/avatar.png"></div><div class="name"><i>Pudding</i></div></div><div class="contents" id="nav-content"><ul><li><a href="/"><i class="iconfont icon-shouye1"></i> <span>主页</span></a></li><li><a href="/tags"><i class="iconfont icon-biaoqian1"></i> <span>标签</span></a></li><li><a href="/archive"><i class="iconfont icon-guidang2"></i> <span>存档</span></a></li><li><a href="/about/"><i class="iconfont icon-guanyu2"></i> <span>关于</span></a></li><li><a id="search"><i class="iconfont icon-sousuo1"></i> <span>搜索</span></a></li></ul></div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E2%80%9C%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD%E2%80%9D"><span class="toc-text">怎么理解“平均负载”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="toc-text">CPU 上下文切换（上）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">进程上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">线程上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">中断上下文切换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%88%E4%B8%8B%EF%BC%89"><span class="toc-text">CPU上下文切换（下）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">查看上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="toc-text">案例分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E7%A7%92%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%A4%9A%E5%B0%91%E6%AC%A1%E6%AD%A3%E5%B8%B8"><span class="toc-text">每秒上下文切换多少次正常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E8%BD%BD"><span class="toc-text">转载</span></a></li></ol></div></div><div class="search-field" id="search-field"><div class="search-bg" id="search-bg"></div><div class="search-container"><div class="search-input"><span id="esc-search"><i class="icon-fanhui iconfont"></i></span> <input id="search-input"> <span id="begin-search">搜索</span></div><div class="search-result-container" id="search-result-container"></div></div></div><div class="index-about-mobile"><i>a week is 2% of the year</i></div></div><div class="index-middle"><div class="post-container"><div class="post-title">Linux性能调优：cpu</div><div class="post-meta"><span class="attr">发布于：<span>2025-05-15</span></span> <span class="attr">标签：/ <a class="tag" href="/tags/#linux" title="linux">linux</a> <span>/</span> <a class="tag" href="/tags/#性能测试" title="性能测试">性能测试</a> <span>/</span> </span><span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span></div><div class="post-content no-indent"><h2 id="怎么理解“平均负载”"><a href="#怎么理解“平均负载”" class="headerlink" title="怎么理解“平均负载”"></a>怎么理解“平均负载”</h2><p>简单来说，平均负载是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数。它和 CPU 使用率没有直接关系，因为 CPU 使用率是指单位时间内 CPU 繁忙程度的百分比。</p><blockquote><p>可运行状态：进程正在运行或准备运行。也就是我们常用 ps 命令看到的处于 R 状态的进程<br>不可中断状态：进程正在等待某个事件的完成，例如 I/O 操作、等待锁、等待信号量等。也就是我们常用 ps 命令看到的处于 D 状态的进程</p></blockquote><p>那么，在实际生产环境中，平均负载多高时，需要我们重点关注呢？</p><p>在我看来，当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。平均负载提供了一个快速查看系统整体性能的手段，反映了整体的负载情况。但是平均负载本身，我们不能直接发现到底是哪里出现了瓶颈。所以，在理解平均负载时，也要注意：</p><ul><li>平均负载高可能是 CPU 密集型进程导致的</li><li>平均负载高不一定代表 CPU 利用率高，还有可能是 I/0 更繁忙了</li><li>当发现负载高的时候，你可看到使用 mpstat、pidstat 等工具，辅助分析负载的来源</li></ul><h2 id="CPU-上下文切换（上）"><a href="#CPU-上下文切换（上）" class="headerlink" title="CPU 上下文切换（上）"></a>CPU 上下文切换（上）</h2><ul><li>CPU 上下文：包括 CPU 寄存器和程序计数器</li><li>CPU 寄存器：是 CPU 内置的容量小、但速度极快的内存</li><li>程序计数器：是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置的寄存器</li></ul><p><img src="/img/2025-05-15-linux_tracing_cpu/image.png" alt="cpu 架构"></p><ul><li>CPU 上下文切换：是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载到新任务的上下文到这些寄存器和程序计数器，然后再跳转到程序计数器指向的新位置，运行新任务</li><li>这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载出来</li></ul><p>根据任务的不同，CPU 的上下文切换可分为进程上下文切换、线程上下文切换和中断上下文切换。</p><h3 id="进程上下文切换"><a href="#进程上下文切换" class="headerlink" title="进程上下文切换"></a>进程上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，对应着下图，CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源</li></ul><p><img src="/img/2025-05-15-linux_tracing_cpu/image2.png" alt="运行空间"></p><p>从进程用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成，系统调用的过程中会发生<strong>两次 CPU 上下文切换</strong>。CPU 里原本用户态指令的执行位置需要先保存起来，然后更新为内核态的指令位置，最后跳转到内核态运行内核任务；在系统调用结束后，CPU 寄存器需要恢复原本保存的用户态，然后再切换到用户空间，继续执行进程。</p><p><strong>注意：</strong></p><ol><li>系统调用的过程中，不会涉及到虚拟内存等进程态的资源，不会切换进程，系统调用过程和进程上下文切换不一样，整个过程都是同一个进程</li><li>系统调用称为特权模式切换，不是上下文切换</li></ol><p>进程上下文切换和系统调用的区别是，进程的上下文切换比系统调用多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><p><img src="/img/2025-05-15-linux_tracing_cpu/image3.png" alt="进程上下文切换"></p><p><strong>保存上下文和恢复上下文的过程需要内核在 CPU 上运行才能完成</strong>（上下文切换过程是 CPU 密集型），每次上下文切换都需要几十纳秒到数微妙的 CPU 时间。</p><p>在进程上下文切换次数过多的情况下，很容易导致 CPU 将大量时间耗费在<strong>寄存器、内核栈以及虚拟内存</strong>等资源的保存和恢复上，进而大大缩短了真正运行进程的时间，从而导致系统平均负载升高。</p><p>Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在<strong>多处理器系统</strong>上，缓存是被多个处理器<strong>共享</strong>的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><p>Linux 为每个 CPU 都维护了一个就绪队列，将活跃进程（即正在运行和正在等待 CPU 的进程）按照优先级和等待 CPU 的时间排序，然后选在最需要 CPU 的进程，也就是<strong>优先级最高和等待 CPU 时间最长</strong>的进程来运行。</p><p>进程被 CPU 重新调度的时机：</p><ol><li>进程执行完终止了，它之前使用的 CPU 会释放出来，这个时候再从就绪队列里，拿一个新的进程过来运行</li><li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待 CPU 的进程运行</li><li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其它进程运行</li><li>进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度</li><li>有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</li><li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序</li></ol><h3 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h3><p>线程和进程的区别：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。</p><p>所谓内核中的任务调度，实际上的调度对象是<strong>线程</strong>；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><ul><li>当进程只有一个线程时，可以认为进程就等于线程</li><li>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的</li><li>另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的</li></ul><p>因此，线程的上下文切换分为两种情况：</p><ul><li>前后两个进程属于不同进程。此时，因为资源部共享，所以切换过程就跟进程上下文切换是一样的</li><li>前后两个线程属于用一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<strong>私有数据、寄存器</strong>等不共享的资源</li></ul><p><strong>注意：</strong>同进程的线程切换要比进程间的切换消耗更少的资源，更加轻量级</p><h3 id="中断上下文切换"><a href="#中断上下文切换" class="headerlink" title="中断上下文切换"></a>中断上下文切换</h3><p>为了响应硬件事件，<strong>中断处理会打断进程的正常调度和执行</strong>，转而调用中断处理程序，响应设备事件。</p><p>中断上下文切换不会涉及进程的用户态，它其实只包括内核态中断服务程序执行所必需的状态，包括 <strong>CPU 寄存器、内核堆栈、硬件中断参数</strong>等</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级，所以<strong>中断上下文切换不会与进程上下文切换同步发生</strong></p><p>大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>中断上下文切换也需要消耗 CPU，切换次数过多也会消耗大量的 CPU，甚至严重降低系统的整体性能</p><h2 id="CPU上下文切换（下）"><a href="#CPU上下文切换（下）" class="headerlink" title="CPU上下文切换（下）"></a>CPU上下文切换（下）</h2><h3 id="查看上下文切换"><a href="#查看上下文切换" class="headerlink" title="查看上下文切换"></a>查看上下文切换</h3><p>1、查看系统的总体情况</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">5</span> <span class="number">5</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">4</span>  <span class="number">0 1218196</span> <span class="number">17324820</span>     <span class="number">60 8417344</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">25</span>    <span class="number">97</span>    <span class="number">0</span>    <span class="number">0</span> <span class="number">12</span>  <span class="number">6</span> <span class="number">82</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218196</span> <span class="number">17311424</span>     <span class="number">60 8426964</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">900</span>    <span class="number">97 15273</span> <span class="number">28505 11</span>  <span class="number">6</span> <span class="number">83</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">0 1218196</span> <span class="number">17399080</span>     <span class="number">60 8343224</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">410</span>   <span class="number">310 15800</span> <span class="number">29604</span>  <span class="number">8</span>  <span class="number">6</span> <span class="number">86</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">0 1218196</span> <span class="number">17385124</span>     <span class="number">60 8350312</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">787</span>   <span class="number">300 13754</span> <span class="number">26351</span>  <span class="number">7</span>  <span class="number">4</span> <span class="number">89</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">0 1218196</span> <span class="number">17415052</span>     <span class="number">60 8336488</span>    <span class="number">0</span>    <span class="number">0</span>   <span class="number">276</span>   <span class="number">132 15567</span> <span class="number">29585</span>  <span class="number">8</span>  <span class="number">5</span> <span class="number">87</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cs：context switch，每秒上下文切换的次数</li><li>in：interrupt，每秒中断的次数</li><li>r：运行队列的长度（正在运行和等待CPU的进程数）</li><li>b：处于阻塞状态的进程数</li></ul><p>2、查看进程的详细信息</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ pidstat -w 5</span><br><span class="line">Linux 3.10.0-957.el7.x86_64 (xxx)       05/27/2025      _x86_64_        (8 CPU)</span><br><span class="line"></span><br><span class="line">07:35:35 PM   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 1 </span>     3.77      0.40  systemd</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 3 </span>     2.58      0.00  ksoftirqd/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 7 </span>     7.34      0.00  migration/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>       <span class="number"> 9 </span>   218.45      0.00  rcu_sched</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 11 </span>     0.40      0.00  watchdog/0</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 12 </span>     0.40      0.00  watchdog/1</span><br><span class="line">07:35:40 PM    <span class="number"> 0 </span>      <span class="number"> 13 </span>     3.57      0.00  migration/1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>cswch/s：每秒自愿上下文切换的次数</li><li>nvcswch/s：每秒非自愿上下文切换的次数</li></ul><blockquote><p>自愿上下文切换：进程无法获取所需资源导致的上下文切换，比如 I/O，内存等系统资源不足时发生的上下文切换<br>非自愿上下文切换：进程因时间片已到等原因，被系统强制调度发生的上下文切换，比如多个进程竞争 CPU 是发生的上下文切换</p></blockquote><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>sysbench 模拟多线程调度切换</p><p>1、运行 sysbench</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以 10 个线程运行 5 分钟的基准测试，模拟多线程切换的问题</span></span><br><span class="line">$ sysbench <span class="attribute">--threads</span>=10 <span class="attribute">--max-time</span>=300 threads run</span><br></pre></td></tr></table></figure><p>2、运行 vmstat</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ vmstat <span class="number">1</span></span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> <span class="number">9</span>  <span class="number">0</span>      <span class="number">0 107736672</span>     <span class="number">64 88038080</span>    <span class="number">0</span>    <span class="number">0</span>    <span class="number">24</span>   <span class="number">199</span>    <span class="number">0</span>    <span class="number">1</span>  <span class="number">2</span>  <span class="number">1</span> <span class="number">97</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">0</span>      <span class="number">0 107731792</span>     <span class="number">64 88045280</span>    <span class="number">0</span>    <span class="number">0 16384</span>    <span class="number">40 105267</span> <span class="number">1167081 12</span> <span class="number">15</span> <span class="number">72</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">0</span>      <span class="number">0 107733720</span>     <span class="number">64 88038080</span>    <span class="number">0</span>    <span class="number">0</span>  <span class="number">4192</span>    <span class="number">20 100233</span> <span class="number">1237404</span>  <span class="number">6</span> <span class="number">16</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">0</span>      <span class="number">0 107726368</span>     <span class="number">64 88045280</span>    <span class="number">0</span>    <span class="number">0 14464</span>    <span class="number">68 128551</span> <span class="number">1548455</span>  <span class="number">6</span> <span class="number">17</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">10</span>  <span class="number">0</span>      <span class="number">0 107735168</span>     <span class="number">64 88039216</span>    <span class="number">0</span>    <span class="number">0</span>  <span class="number">4096</span>    <span class="number">64 111126</span> <span class="number">1468157</span>  <span class="number">6</span> <span class="number">16</span> <span class="number">78</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>指标观察：</p><ul><li>cs 列：上升到 100w</li><li>r 列：就绪队列长度上升到 10</li><li>in 列：终端次数上升到 10w</li><li>us（user）和sy（system）列：使用率加起来接近 100%，sy 为 78%，主要被内核占用</li></ul><p>3、查看进程情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔1秒输出1组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -w 参数表示输出进程切换指标，而 -u 参数则表示输出 CPU 使用指标</span></span><br><span class="line">$ pidstat -w -u 1</span><br><span class="line">19时34分55秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 561077 </span>   0.00    1.00    0.00    1.00    <span class="number"> 2 </span> sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 562599 </span> 100.00  100.00    0.00  100.00   <span class="number"> 13 </span> sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 566600 </span>   0.00    2.00    0.00    2.00   <span class="number"> 32 </span> pidstat</span><br><span class="line"></span><br><span class="line">19时34分55秒   UID       PID   cswch/s nvcswch/s  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 256312 </span>     1.00      0.00  kworker/37:31</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 263655 </span>     1.00      0.00  kworker/33:2</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 299865 </span>     1.00      0.00  kworker/21:2</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 562931 </span>     1.00      2.00  vmstat</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 560904 </span>     1.00      0.00  sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 561077 </span>    78.00      0.00  sshd</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 566600 </span>     1.00    671.00  pidstat</span><br></pre></td></tr></table></figure><p>分析：CPU 使用率的升高果然是 sysbench 导致的，它的 CPU 使用率已经达到了 100%。但上下文切换则是来自其他进程，包括非自愿上下文切换频率最高的 pidstat ，以及自愿上下文切换频率最高的内核线程 kworker 和 sshd</p><p><strong>注意：</strong>pidstat 输出的上下文切换次数，加起来也就几百，比 vmstat 的 100 万明显小了太多？</p><table><thead><tr><th>工具</th><th>统计粒度</th><th>上下文切换数据来源</th><th>显示内容</th></tr></thead><tbody><tr><td>pidstat</td><td>按进程/线程级别</td><td>/proc/[pid]/sched 或 /proc/[pid]/status</td><td>显示某些（非全部）PID 的上下文切换次数</td></tr><tr><td>vmstat</td><td>系统全局级别</td><td>内核调度器</td><td>显示全系统每秒上下文切换总数</td></tr></tbody></table><p>4、查看线程情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每隔 1 秒输出一组数据（需要 Ctrl+C 才结束）</span></span><br><span class="line"><span class="comment"># -wt 参数表示输出线程的上下文切换指标</span></span><br><span class="line">$ pidstat -wt 1</span><br><span class="line">19时34分55秒  UID      TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>  <span class="number"> 616348 </span>        -      0.00      0.00  sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616348 </span>     0.00      0.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616349 </span> 67080.00      6.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616350 </span> 63009.00      3.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616351 </span> 68060.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616352 </span> 69808.00      4.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616353 </span> 68806.00      5.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616354 </span> 73688.00      6.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616355 </span> 72296.00      4.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616356 </span> 63978.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616357 </span> 67409.00      1.00  |__sysbench</span><br><span class="line">19时34分56秒    <span class="number"> 0 </span>        -   <span class="number"> 616358 </span> 67859.00      2.00  |__sysbench</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，sysbench 进程（也就是主线程）的上下文切换次数看起来并不多，但它的子线程的上下文切换次数却有很多。上下文切换罪魁祸首，还是过多的 sysbench 线程</p><p>5、查看中断升高的原因</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ watch -d cat /<span class="keyword">proc</span>/interrupts<span class="title"></span></span><br><span class="line"><span class="title">           CPU0</span> <span class="title">      CPU1</span> <span class="title">      CPU2</span></span><br><span class="line">...<span class="title"></span></span><br><span class="line"><span class="title"> RES:</span>  117962220   27310354   17986708<span class="title">   Rescheduling</span> interrupts</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>观察发现，变化速度最快的是重调度中断（RES），它代表唤醒空闲状态的 CPU 来调度新的任务运行，这是在多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）</p><p><strong>分析：</strong>过多任务导致了重调度中断的升高，和前面分析结果一致</p><h2 id="每秒上下文切换多少次正常"><a href="#每秒上下文切换多少次正常" class="headerlink" title="每秒上下文切换多少次正常"></a>每秒上下文切换多少次正常</h2><p><strong>上下文切换次数取决于系统本身的CPU性能。</strong>如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级增长时，就很有可能出现了性能问题，这时根据具体上下文切换的类型具体分析：</p><ul><li>资源上下文切换变多了，说明进程在等在资源，可能发生了 I/O 等其他问题</li><li>非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈</li><li>中断次数变多了，说明 CPU 被中断处理程序占用，还序号通过查看 /proc/interrupts 文件来分析具体的中断类型</li></ul><h2 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h2><ul><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Miller-Xie/Linux-kernel-notes/blob/master/Linux%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.md#cpu%E6%80%A7%E8%83%BD%E7%AF%87">CPU性能篇</a></li></ul><br><div id="comment-container"></div><div id="disqus_thread"></div><div id="lv-container"></div><div class="giscus"></div></div></div></div></div><footer class="footer"><ul class="list-inline text-center"><li><a target="_blank" href="https://github.com/wu3227834" rel="external nofollow noreferrer"><span class="fa-stack fa-lg"><i class="iconfont icon-github"></i></span></a></li></ul><p><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span>PV </span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span>UV </span>Created By <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> Theme <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script><script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script type="text/javascript" src="/js/clipboard.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body><script>window.hexo_search_path="search.json",window.hexo_root="/",window.isPost=!0</script><script src="/js/index.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/jquery.min.js"></script><script src="/js/prism.js"></script><script src="https://giscus.app/client.js" data-repo="wu3227834/wu3227834.github.io" data-repo-id="R_kgDOIh8vuA" data-category="General" data-category-id="DIC_kwDOIh8vuM4CpDjz" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></html><script src="/js/fancybox/jquery.fancybox.min.js" key="fancybox_js"></script><script src="/js/fancybox/wrapImage.js" key="wrap_image_js"></script><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" key="fancybox_css">