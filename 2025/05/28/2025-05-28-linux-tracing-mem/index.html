<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:description" content="这里是小布丁的私有小屋"><meta property="og:type" content="website"><meta name="description" content="12313"><link rel="shortcut icon" href="/img/favicon.ico"><title>Linux性能调优：内存</title><link rel="stylesheet" href="/css/aircloud.css"><link rel="stylesheet" href="/css/gitment.css"><link rel="stylesheet" href="/css/prism.css"><link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css"><script></script><script defer src="https://cloud.umami.is/script.js" data-website-id="bad0a741-25cb-4dd6-bbcf-f5710aeb243c"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Pudding 日常" type="application/atom+xml"></head><body><div class="site-nav-toggle" id="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><div class="index-about"><i>a week is 2% of the year</i></div><div class="index-container"><div class="index-left"><div class="nav" id="nav"><div class="avatar-name"><div class="avatar"><img src="/img/avatar.png"></div><div class="name"><i>Pudding</i></div></div><div class="contents" id="nav-content"><ul><li><a href="/"><i class="iconfont icon-shouye1"></i> <span>主页</span></a></li><li><a href="/tags"><i class="iconfont icon-biaoqian1"></i> <span>标签</span></a></li><li><a href="/archive"><i class="iconfont icon-guidang2"></i> <span>存档</span></a></li><li><a href="/about/"><i class="iconfont icon-guanyu2"></i> <span>关于</span></a></li><li><a id="search"><i class="iconfont icon-sousuo1"></i> <span>搜索</span></a></li></ul></div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%86%85%E5%AD%98%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">Linux内存工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="toc-text">内存分配与回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-text">如何查看内存使用情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84-Buffer-%E5%92%8C-Cache"><span class="toc-text">内存的 Buffer 和 Cache</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#free-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90"><span class="toc-text">free 的数据来源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proc-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-text">proc 文件系统</span></a></li></ol></li></ol></div></div><div class="search-field" id="search-field"><div class="search-bg" id="search-bg"></div><div class="search-container"><div class="search-input"><span id="esc-search"><i class="icon-fanhui iconfont"></i></span> <input id="search-input"> <span id="begin-search">搜索</span></div><div class="search-result-container" id="search-result-container"></div></div></div><div class="index-about-mobile"><i>a week is 2% of the year</i></div></div><div class="index-middle"><div class="post-container"><div class="post-title">Linux性能调优：内存</div><div class="post-meta"><span class="attr">发布于：<span>2025-05-28</span></span> <span class="attr">标签：/ <a class="tag" href="/tags/#linux" title="linux">linux</a> <span>/</span> <a class="tag" href="/tags/#性能测试" title="性能测试">性能测试</a> <span>/</span> </span><span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span></div><div class="post-content no-indent"><h2 id="Linux内存工作原理"><a href="#Linux内存工作原理" class="headerlink" title="Linux内存工作原理"></a>Linux内存工作原理</h2><h3 id="内存分配与回收"><a href="#内存分配与回收" class="headerlink" title="内存分配与回收"></a>内存分配与回收</h3><p>malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。</p><p>对小块内存（小于 128K），C 标准库使用 brk() 来分配，也就是通过移动堆顶的位置来分配内存。这些内存释放后并不会立刻归还系统，而是被缓存起来，这样就可以重复使用。</p><p>对大块内存（大于 128K），则使用内存映射 mmap() 来分配，也就是在文件映射找一块空闲内存分配出去。</p><p>各自的<strong>优缺点</strong>：</p><ul><li>brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率；不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片</li><li>mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大</li></ul><p>整体来说，Linux 使用<strong>伙伴系统</strong>来管理内存分配。前面我们提到过，这些内存在 MMU 中以页为单位进行管理，伙伴系统也一样，以页为单位来管理内存，并且会通过相邻页的合并，减少内存碎片化（比如 brk 方法造成的内存碎片）。</p><p>在用户空间，malloc 通过 brk() 分配的内存，在释放时并不立即归还系统，而是缓存起来重复利用。在内核空间，Linux 通过 slab 分配器来管理小内存，可以把 slab 堪称构建在<strong>伙伴系统上的一个缓存</strong>，主要作用就是分配并释放内核中的小对象。</p><p>系统也不会任由某个进程用完所有内存。在发现内存紧张时，系统会通过一系列机制来回收内存：</p><ul><li>回收内存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面</li><li>回收不常访问的内存，把不常用的内存交换分区直接写到磁盘中（会用到交换分区）</li><li>杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程</li></ul><p>OOM 是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：</p><ul><li>进程消耗的内存越大，oom_score 就越大</li><li>进程运行占用的 CPU 越多，oom_score 就越小</li></ul><p>可以手动设置进程的 oom_adj 来调整 oom_score。oom_adj 的范围是 [-17, 15]，数值越大，进程越容易被杀死；反之，越不容易被杀死。</p><h3 id="如何查看内存使用情况"><a href="#如何查看内存使用情况" class="headerlink" title="如何查看内存使用情况"></a>如何查看内存使用情况</h3><p>1、free 命令</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:     <span class="number"> 262695500 </span> <span class="number"> 106731876 </span> <span class="number"> 141173212 </span>   <span class="number"> 4257008 </span>  <span class="number"> 14790412 </span>  149168720</span><br><span class="line">Swap:            <span class="number"> 0 </span>         <span class="number"> 0 </span>          0</span><br></pre></td></tr></table></figure><ul><li>total：总内存</li><li>used：已使用内存，包括共享内存</li><li>free：空闲内存</li><li>shared：共享内存</li><li>buff/cache：缓存内存，包括缓冲区和缓存</li><li>available：可用内存，包括空闲内存和缓存内存</li></ul><p><strong>注意</strong>：available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p><p>2、top 命令</p><p>可以查看每个进程的内存使用情况</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">top - 19:28:02 up<span class="number"> 201 </span>days,  2:48, <span class="number"> 2 </span>users,  load average: 134.36, 136.81, 111.38</span><br><span class="line">Tasks:<span class="number"> 1284 </span>total,  <span class="number"> 6 </span>running,<span class="number"> 1278 </span>sleeping,  <span class="number"> 0 </span>stopped,  <span class="number"> 0 </span>zombie</span><br><span class="line">%Cpu(s): 87.2 us,  8.9 sy,  0.0 ni,  0.9 id,  0.0 wa,  1.8 hi,  1.1 si,  0.0 st</span><br><span class="line">MiB Mem : 256538.6 total, 137892.3 free, 104201.3 used,  14445.0 buff/cache</span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used. 145701.9 avail Mem</span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line"><span class="number"> 607070 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span> 266.3g  82.5g <span class="number"> 79228 </span>S <span class="number"> 4861 </span> 33.0  40025:32 tabletserver_ma</span><br><span class="line"><span class="number"> 835494 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>8557368<span class="number"> 207048 </span><span class="number"> 10872 </span>S 121.7   0.1 357:04.40 java</span><br><span class="line"><span class="number"> 842048 </span>1001     <span class="number"> 20 </span> <span class="number"> 0 </span>  32.8g <span class="number"> 31168 </span><span class="number"> 14888 </span>S 113.0   0.0   0:03.41 java</span><br><span class="line"><span class="number"> 840498 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span><span class="number"> 727932 </span><span class="number"> 31336 </span> <span class="number"> 7304 </span>R  91.3   0.0   2164:46 node_exporter</span><br><span class="line"><span class="number"> 653917 </span>root     <span class="number"> 20 </span> <span class="number"> 0 </span>  12.3g<span class="number"> 997944 </span><span class="number"> 46948 </span>S  78.3   0.4  15877:42 kubelet</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>VIRT：虚拟内存，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内</li><li>RES：实际内存，也就是进程<strong>实际使用的物理内存</strong>大小，但<strong>不包括 Swap 和共享内存</strong></li><li>SHR：共享内存，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等</li><li>%MEM：进程占用的物理内存占系统总内存的百分比</li></ul><p><strong>注意</strong>：</p><ul><li>虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都大于实际内存，这是因为虚拟内存是进程申请的内存，即使进程没有真正分配物理内存，也会计算在内。</li><li>共享内存 SHR 并不一定是共享的，比方说，<strong>程序的代码段、非共享的动态内存链接库</strong>，也都在 SHR 里。SHR 也包括了<strong>进程间真正共享的内存</strong>。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果</li></ul><h2 id="内存的-Buffer-和-Cache"><a href="#内存的-Buffer-和-Cache" class="headerlink" title="内存的 Buffer 和 Cache"></a>内存的 Buffer 和 Cache</h2><h3 id="free-的数据来源"><a href="#free-的数据来源" class="headerlink" title="free 的数据来源"></a>free 的数据来源</h3><p>man free 查看</p><p><img src="/img/2025-05-28-linux_tracing_mem/image.png" alt="man free"></p><p>从手册看到：</p><ul><li>Buffers：Memory used by kernel buffers (Buffers in /proc/meminfo)</li><li>Cache：Memory used by the page cache and slabs (Cached and Slab in /proc/meminfo)</li></ul><h3 id="proc-文件系统"><a href="#proc-文件系统" class="headerlink" title="proc 文件系统"></a>proc 文件系统</h3><p>man proc 查看</p><br><div id="comment-container"></div><div id="disqus_thread"></div><div id="lv-container"></div><div class="giscus"></div></div></div></div></div><footer class="footer"><ul class="list-inline text-center"><li><a target="_blank" href="https://github.com/wu3227834" rel="external nofollow noreferrer"><span class="fa-stack fa-lg"><i class="iconfont icon-github"></i></span></a></li></ul><p><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span>PV </span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span>UV </span>Created By <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> Theme <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script><script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script type="text/javascript" src="/js/clipboard.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body><script>window.hexo_search_path="search.json",window.hexo_root="/",window.isPost=!0</script><script src="/js/index.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/jquery.min.js"></script><script src="/js/prism.js"></script><script src="https://giscus.app/client.js" data-repo="wu3227834/wu3227834.github.io" data-repo-id="R_kgDOIh8vuA" data-category="General" data-category-id="DIC_kwDOIh8vuM4CpDjz" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></html><script src="/js/fancybox/jquery.fancybox.min.js" key="fancybox_js"></script><script src="/js/fancybox/wrapImage.js" key="wrap_image_js"></script><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" key="fancybox_css">