<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:description" content="这里是小布丁的私有小屋"><meta property="og:type" content="website"><meta name="keywords" content="Robot Framework, 自动化测试, 关键字驱动, 测试框架, Remote Library,"><meta name="description" content="本译文全面介绍了 Robot Framework 的概念、架构与关键字驱动测试原理，涵盖测试库、资源文件、Remote Library及语言选择等核心内容。"><link rel="shortcut icon" href="/img/favicon.ico"><title>RobotFramework教程 - 概述</title><link rel="stylesheet" href="/css/aircloud.css"><link rel="stylesheet" href="/css/gitment.css"><link rel="stylesheet" href="/css/prism.css"><link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css"><script></script><script defer src="https://cloud.umami.is/script.js" data-website-id="bad0a741-25cb-4dd6-bbcf-f5710aeb243c"></script><script type="text/javascript">((e,t,s,n,a,c)=>{e[s]=e[s]||function(){(e[s].q=e[s].q||[]).push(arguments)},(a=t.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/sgs6id3d37",(c=t.getElementsByTagName(n)[0]).parentNode.insertBefore(a,c)})(window,document,"clarity","script")</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Pudding 日常" type="application/atom+xml"></head><body><div class="site-nav-toggle" id="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><div class="index-about"><i>a week is 2% of the year</i></div><div class="index-container"><div class="index-left"><div class="nav" id="nav"><div class="avatar-name"><div class="avatar"><img src="/img/avatar.png"></div><div class="name"><i>Pudding</i></div></div><div class="contents" id="nav-content"><ul><li><a href="/"><i class="iconfont icon-shouye1"></i> <span>主页</span></a></li><li><a href="/tags"><i class="iconfont icon-biaoqian1"></i> <span>标签</span></a></li><li><a href="/archive"><i class="iconfont icon-guidang2"></i> <span>存档</span></a></li><li><a href="/about/"><i class="iconfont icon-guanyu2"></i> <span>关于</span></a></li><li><a id="search"><i class="iconfont icon-sousuo1"></i> <span>搜索</span></a></li></ul></div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6"><span class="toc-text">什么是自动化测试框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E9%94%AE%E5%AD%97%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-text">什么是关键字驱动测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%BF%E8%AF%BA%E7%9A%84%E6%A6%82%E5%86%B5"><span class="toc-text">承诺的概况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%8B%E8%AF%95%E5%8A%9F%E8%83%BD%E8%AF%A5%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80"><span class="toc-text">自定义测试功能该用什么语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Remote-Libraries"><span class="toc-text">Remote Libraries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><span class="toc-text">持续集成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BF%BB%E8%AF%91"><span class="toc-text">翻译</span></a></li></ol></div></div><div class="search-field" id="search-field"><div class="search-bg" id="search-bg"></div><div class="search-container"><div class="search-input"><span id="esc-search"><i class="icon-fanhui iconfont"></i></span> <input id="search-input"> <span id="begin-search">搜索</span></div><div class="search-result-container" id="search-result-container"></div></div></div><div class="index-about-mobile"><i>a week is 2% of the year</i></div></div><div class="index-middle"><div class="post-container"><div class="post-title">RobotFramework教程 - 概述</div><div class="post-meta"><span class="attr">发布于：<span>2025-10-17</span></span> <span class="attr">标签：/ <a class="tag" href="/tags/#Robot Framework" title="Robot Framework">Robot Framework</a> <span>/</span> <a class="tag" href="/tags/#自动化框架" title="自动化框架">自动化框架</a> <span>/</span> </span><span class="attr">访问：<span id="busuanzi_value_page_pv"></span></span></div><div class="post-content no-indent"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://code.google.com/p/robotframework/">Robot Framework</a> 是一个通用的自动化测试框架。这是本系列的第一篇文章，将会给出一个全面的概述。</p><p>请注意，第一篇文章几乎不会包含任何“真正实现方面的东西”，而是讲述一些高级别、抽象的概念，来为以后的文章打下坚实的基础。</p><h2 id="什么是自动化测试框架"><a href="#什么是自动化测试框架" class="headerlink" title="什么是自动化测试框架"></a>什么是自动化测试框架</h2><p>如果你已经有自动化测试的经验（例如，使用一些自动化测试工具），你可以直接跳过本小节。</p><p>现在，我想先问一个问题：什么是自动化测试？以及它为何不同于手动执行的测试？Michael Bolton 写的<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.developsense.com/blog/2009/08/testing-vs-checking/">这篇文章</a>对这两个问题给出了一个非常好的答案：</p><blockquote><p>核对是机器干的事儿，测试则需要智慧</p></blockquote><p>然而请注意，当我们下面讨论自动化测试时，会同时使用测试和核对两个术语。</p><p>让我们来看看具体的例子，比如说一个保险公司的评级引擎。这个引擎会根据输入的某些参数（数字）来计算值。对于这样一个算法已知的系统而言，显然大量（自动化）核对时非常合适的。但检验这个算法正确与否，则需要一些思考。</p><p>假设我们有一个基于数据库的接口，和一个批处理程序：从一个表中取出数据，计算后与另一个表中的数据核对结果。</p><p>首先，我们需要测试脚本语言（取决于个人喜好，可以是 Shell，Perl，Java 等等）。此外我们还要准备一些基本的测试功能。然后访问数据库表，执行一个又一个脚本，测试结果最好以某种报告的形式返回。一旦脚本运行完毕，我们便可以开始核对检查工作。基本上，我们认为，一个典型的自动化测试框架应该提供上述的功能。</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/GenericFrameworkView.png" alt="GenericFrameworkView"></p><p>上图描述了一个非常基本的自动化测试框架。该框架有一个可执行测试的核心系统，可以输出一些可执行测试的核心系统，可以输出一些报告，并提供接口来插入特定的测试功能。这个插入接口实现会非常简单。</p><p>这就带来一个基本的问题：当我用这些测试框架时，改用什么编程语言来实现我的测试功能？稍后我们会详细回答这个问题，但现在我们可以说，<strong>Robot Framework</strong> 测试框架允许使用很多不同的语言。</p><p>在了解 <strong>Robot Framework</strong> 的具体体系之前，我们先讨论下 <strong>Robot Framework</strong> 的核心术语，即<strong>关键字驱动测试</strong>。</p><h2 id="什么是关键字驱动测试"><a href="#什么是关键字驱动测试" class="headerlink" title="什么是关键字驱动测试"></a>什么是关键字驱动测试</h2><p>每当我试图解释什么是关键字的时候，我总会把它称为函数或方法，其能够用于测试被测系统的一个方面。</p><p>真正强大的是，一个关键字可以有其关键字来定义。这就是为什么通常说：</p><ul><li><strong>高级别关键字</strong>：这些关键字实际上是在测试被测系统的某个业务逻辑</li><li><strong>低级别关键字</strong>：为了将高级关键字的实现保持在一个合适的“大小”，通常需要将所需的功能分解为几个低级关键字</li><li><strong>技术关键字</strong>：这些关键字提供了访问和测试系统的技术实现</li></ul><p>下面这张图用一个关键字例子描述了这三者的关系。</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/Keywords.png" alt="Keywords"></p><p>通常技术关键字可以由任何编程语言来实现（好吧，也不一定）。其他的关键字则是有已存在的关键字组合而成。即本文关注的是抽象的概念，我们还是来看一个具体的关键字定义：</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/KeywordGoogleSearch.png" alt="KeywordGoogleSearch"></p><p>这个例子表明， Google Search 这个关键字可以由 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://robotframework.org/SeleniumLibrary/SeleniumLibrary.html">Selenium Library 库</a> 中的关键字来创建。好消息是已经有大量预定义的关键字，它们的集合称为测试库。</p><p>好，让我们开始。。。</p><h2 id="承诺的概况"><a href="#承诺的概况" class="headerlink" title="承诺的概况"></a>承诺的概况</h2><p>最后开始我们的主题，<strong>Robot Framework</strong> 概览。安装 <strong>Robot Framework</strong> 时，一些标准测试库会随核心框架一起安装。</p><p>除了<a target="_blank" rel="noopener external nofollow noreferrer" href="http://code.google.com/p/robotframework/wiki/TestLibraries">标准测试库</a>外，还有很多<a target="_blank" rel="noopener external nofollow noreferrer" href="http://code.google.com/p/robotframework/wiki/TestLibraries#External_test_libraries">额外的外部测试库</a>。它们通常是社区由不同的目的贡献的。在写特定测试用例的时候，你完全可以混用不同测试库的所有关键字。这意味着，在测试一个 web 应用时，可以用 <strong>Selenium Library</strong> 来与 web 前端交互，用 <strong>Database Library</strong> 来检测数据库中数据的正确性。理想情况下，完全不需要编程，只需组合库中的关键字来构成高级别关键字。</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/Overview_3.png" alt="Overview_3"></p><p>Robot Framework 除了核心功能和测试库外，还提供一个 IDE（RIDE, Robot Integrated Development Environment），用户可以在此编写和组织自己的测试用例和关键字。请注意，这个 RIDE 不是用来写技术性关键字的。技术性关键字取决于你的开发环境，比如 Eclipse 来开发 Java 写的关键字。</p><p>上图中尚未包含<strong>资源文件</strong>。我们测试用例的集合称作<strong>测试套件</strong>，听起来很有道理。现在为<strong>测试套件</strong>添加新关键字也是可行的。但最好在外部的<strong>资源文件</strong>中定义关键字。</p><p>现在，我们在使用 Robot Framwwork 框架时，有三个重要的概念：</p><ul><li><strong>测试套件</strong>：这是测试用例（机器的核对工作）的容器。通常每个项目至少有一个测试套件。在大型工程中，需要根据功能来划分不同的测试套件。</li><li><strong>资源文件</strong>：为了让测试设计者的角度看，几乎总会定义高级别关键字。反过来说，通常会有自己的资源文件。特别是对产品开发或者一些长期项目而言，肯定能益于关键字，而且还能被其他项目组使用。</li><li><strong>测试库</strong>：通常不需要编写自己的技术性关键字，除非你在使用特定技术细节，你才需要自己实现一个新的测试库，不过这并不费时。</li></ul><p>需要强调的是，<strong>测试库</strong>中的关键字和<strong>资源文件</strong>中组合成的关键字，在使用时没有区别。</p><h2 id="自定义测试功能该用什么语言"><a href="#自定义测试功能该用什么语言" class="headerlink" title="自定义测试功能该用什么语言"></a>自定义测试功能该用什么语言</h2><p>Robot Framework 自身和其核心库都是由 Python 实现的。因此，如果熟悉 Python（或者打算熟悉），用其写自己的关键字是个好的选择。我一直认为 python 是很酷的语言，但如果 Robot Framework 局限于 Python，它不会这么成功。这就是为什么会有 Jython。有了 Jython 就可以在 Java 的虚拟机上运行 python 代码。这就使得我们能够用 Java 来编写测试库，甚至是任何编译成 Java Byte Code 的语言。</p><blockquote><p>在 .NET 系中，IronPython 和 Jython 是类似的</p></blockquote><p>这引出了以下的安全堆栈：</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/InstallationStacks.png" alt="InstallationStacks"></p><p>Robot Framework 历史上是上图最左边的安装堆栈（在没有 RIDE 的情况下）。早期 Jython 的安装和支持欠佳。然而，现在 Java 已经适配的很好了，只有很少的问题。</p><p>现在还有 JAR 安装方式的 Robot Framework，Python 的测试库和 Jython 都被打包成一个大的 JAR 文件。这有很大的优势，你可以将 JAR 放入版本控制中，或者是放入本地的 Maven 仓库中。这样就能保证团队成员都使用相同版本的 Robot Framework，且能够实时更新。不过也有缺点，这种情况下，RIDE 无法显示 JAR 文件关键字的帮助信息，所以 RIDE 还需要单独安装。</p><p>好，现在回到我们的主题：用什么语言来实现自己的测试功能。</p><h2 id="Remote-Libraries"><a href="#Remote-Libraries" class="headerlink" title="Remote Libraries"></a>Remote Libraries</h2><p>目前为止，无论是本地还是服务器，Robot Framework 都是安装在同一台机器。然后我们也看到可以用 Python, Jython 和纯 Java 语言来开发测试库。</p><p>用 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://code.google.com/p/robotframework/wiki/RemoteLibrary">Remote Libraries</a>，可以在其他机器中，用支持 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://en.wikipedia.org/wiki/XML-RPC">XML-RPC protocol</a> 的任何语言来编写测试库。</p><p><img src="/img/2025-10-17-RobotFramework%E6%95%99%E7%A8%8B_%E6%A6%82%E8%BF%B0/RemoteLibrary.png" alt="RemoteLibrary"></p><p>当在测试用例和资源文件中导入 Remote Library，它们用起来和普通的库没有区别。还有一个优点是，你也可以从 Remote Library 中获取帮助文件。如果对其实现感兴趣，可以看看 Database Library 的源码。需要指出的是，Remote Library 功能本身就是某些测试库的附加功能。</p><p>Remote Library 作为一个远程的服务器，而 Robot Framework 作为一个客户端。当然这两个库完全能在本地使用。</p><p>这是绝对不能被低估的一个非常强大的功能。</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>把 Robot Framework 集成到持续集成服务器中非常直接，因为框架本身是用脚本语言写成的。Java 版本当然也可以使用 Maven 集成。</p><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><ul><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.codecentric.de/en/knowledge-hub/blog/robot-framework-tutorial-overview">Robot Framework Tutorial – Overview</a></li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.lyyyuna.com/2016/01/07/robotframework-tutorial-overview/">Robot Framework 教程 - 概览（译）</a></li></ul><br><div id="comment-container"></div><div id="disqus_thread"></div><div id="lv-container"></div><div class="giscus"></div></div></div></div></div><footer class="footer"><ul class="list-inline text-center"><li><a target="_blank" href="https://github.com/wu3227834" rel="external nofollow noreferrer"><span class="fa-stack fa-lg"><i class="iconfont icon-github"></i></span></a></li></ul><p><span id="busuanzi_container_site_pv"><span id="busuanzi_value_site_pv"></span>PV </span><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span>UV </span>Created By <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io/">Hexo</a> Theme <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p></footer><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.js"></script><script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script><script type="text/javascript" src="/js/clipboard.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body><script>window.hexo_search_path="search.json",window.hexo_root="/",window.isPost=!0</script><script src="/js/index.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/jquery.min.js"></script><script src="/js/prism.js"></script><script src="https://giscus.app/client.js" data-repo="wu3227834/wu3227834.github.io" data-repo-id="R_kgDOIh8vuA" data-category="General" data-category-id="DIC_kwDOIh8vuM4CpDjz" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script></html><script src="/js/fancybox/jquery.fancybox.min.js" key="fancybox_js"></script><script src="/js/fancybox/wrapImage.js" key="wrap_image_js"></script><link rel="stylesheet" href="/js/fancybox/jquery.fancybox.min.css" key="fancybox_css">